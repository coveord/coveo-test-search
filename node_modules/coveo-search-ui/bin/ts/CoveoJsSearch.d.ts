/// <reference path="Externals.d.ts" />
declare module Coveo {
	export class Logger {
	    private owner;
	    static TRACE: number;
	    static DEBUG: number;
	    static INFO: number;
	    static WARN: number;
	    static ERROR: number;
	    static NOTHING: number;
	    static level: number;
	    static executionTime: boolean;
	    constructor(owner: any);
	    trace(...stuff: any[]): void;
	    debug(...stuff: any[]): void;
	    info(...stuff: any[]): void;
	    warn(...stuff: any[]): void;
	    error(...stuff: any[]): void;
	    private log(level, stuff);
	    static enable(): void;
	    static disable(): void;
	}

}
declare module Coveo {
	export interface IHighlight {
	    offset: number;
	    length: number;
	    dataHighlightGroup?: number;
	    dataHighlightGroupTerm?: string;
	}
	export interface IHighlightTerm {
	    [originalTerm: string]: string[];
	}
	export interface IHighlightPhrase {
	    [phrase: string]: IHighlightTerm;
	}

}
declare module Coveo {
	
	/**
	 * Describe a single result returned by the Coveo Search API.
	 */
	export interface IQueryResult {
	    /**
	     * The title of the document
	     */
	    title: string;
	    titleHighlights: IHighlight[];
	    /**
	     * The uri of the document
	     */
	    uri: string;
	    /**
	     * A printable uri, or path to the document
	     */
	    printableUri: string;
	    printableUriHighlights: IHighlight[];
	    /**
	     * The clickable uri of the document, which can be set on an href in the interface.
	     */
	    clickUri: string;
	    /**
	     * The document unique id, useful for different call on the {@link SearchEndpoint}
	     */
	    uniqueId: string;
	    /**
	     * The excerpt for the document. Can be empty for some type of documents.
	     */
	    excerpt: string;
	    excerptHighlights: IHighlight[];
	    firstSentences: string;
	    firstSentencesHighlights: IHighlight[];
	    /**
	     * Whether the document has an htmlVersion (quickview)
	     */
	    hasHtmlVersion: boolean;
	    hasMobileHtmlVersion: boolean;
	    /**
	     * List of flags on the document, separated by ;<br/>
	     */
	    flags: string;
	    summary: string;
	    summaryHighlights: IHighlight[];
	    /**
	     * Returned on a document if the {@link IQuery.debug} was set to true
	     */
	    rankingInfo: string;
	    /**
	     * The rating for the given document. This can be set on a document using the {@link ResultRating} component, and if the collaborative rating is enabled on the index.
	     */
	    rating?: number;
	    /**
	     * Contains the raw field values on the document, as key->value properties
	     */
	    raw: any;
	    /**
	     * The parent result, if parent child loading was performed using the {@link Folding} component.
	     */
	    parentResult?: IQueryResult;
	    /**
	     * The parent result, if parent child loading was performed using the {@link Folding} component.
	     */
	    childResults: IQueryResult[];
	    /**
	     * This value specifies whether the result was recommended by Coveo Reveal.
	     */
	    isRecommendation: boolean;
	    termsToHighlight?: IHighlightTerm;
	    phrasesToHighlight: IHighlightPhrase;
	    rankingModifier?: string;
	    index?: number;
	    queryUid?: string;
	    pipeline?: string;
	    splitTestRun?: string;
	    moreResults?: () => Promise<IQueryResult[]>;
	    totalNumberOfChildResults?: number;
	    attachments?: IQueryResult[];
	    state: {
	        [attribute: string]: any;
	    };
	    orphan?: boolean;
	    fields?: {
	        [name: string]: any;
	    };
	}

}
declare module Coveo {
	
	export class Utils {
	    static isUndefined(obj: any): boolean;
	    static isNull(obj: any): boolean;
	    static isNullOrUndefined(obj: any): boolean;
	    static exists(obj: any): boolean;
	    static toNotNullString(str: string): string;
	    static anyTypeToString(value: any): string;
	    static isNullOrEmptyString(str: string): boolean;
	    static isNonEmptyString(str: string): boolean;
	    static isEmptyString(str: string): boolean;
	    static stringStartsWith(str: string, startWith: string): boolean;
	    static isNonEmptyArray(obj: any): boolean;
	    static isEmptyArray(obj: any): boolean;
	    static isHtmlElement(obj: any): boolean;
	    static parseIntIfNotUndefined(str: string): number;
	    static parseFloatIfNotUndefined(str: string): number;
	    static round(num: number, decimals: number): number;
	    static parseBooleanIfNotUndefined(str: string): boolean;
	    static trim(value: string): string;
	    static encodeHTMLEntities(rawStr: string): string;
	    static decodeHTMLEntities(rawString: string): string;
	    static arrayEqual(array1: any[], array2: any[], sameOrder?: boolean): boolean;
	    static objectEqual(obj1: Object, obj2: Object): boolean;
	    static isCoveoField(field: string): boolean;
	    static escapeRegexCharacter(str: string): string;
	    static getCaseInsensitiveProperty(object: {}, name: string): any;
	    static getFieldValue(result: IQueryResult, name: string): any;
	    static throttle(func: any, wait: any, options?: {
	        leading?: boolean;
	        trailing?: boolean;
	    }, context?: any, args?: any): () => any;
	    static extendDeep(target: any, src: any): {};
	    static getQueryStringValue(key: any, queryString?: string): string;
	    static isValidUrl(str: string): boolean;
	    static debounce(func: Function, wait: number): (...args: any[]) => void;
	    static readCookie(name: string): string;
	    static toDashCase(camelCased: string): string;
	    static parseXml(xml: string): XMLDocument;
	    static copyObject<T>(target: T, src: T): void;
	    static copyObjectAttributes<T>(target: T, src: T, attributes: string[]): void;
	}

}
declare module Coveo {
	export class Assert {
	    private static logger;
	    static failureHandler: (message?: string) => void;
	    static fail(message?: string): void;
	    static check(condition: boolean, message?: string): void;
	    static isUndefined(obj: any): void;
	    static isNotUndefined(obj: any): void;
	    static isNull(obj: any): void;
	    static isNotNull(obj: any): void;
	    static exists(obj: any): void;
	    static doesNotExists(obj: any): void;
	    static isString(obj: any): void;
	    static stringStartsWith(str: string, start: string): void;
	    static isNonEmptyString(str: string): void;
	    static isNumber(obj: any): void;
	    static isLargerThan(expected: number, actual: number): void;
	    static isLargerOrEqualsThan(expected: number, actual: number): void;
	    static isSmallerThan(expected: number, actual: number): void;
	    static isSmallerOrEqualsThan(expected: number, actual: number): void;
	}
	export class PreconditionFailedException {
	    message: string;
	    constructor(message: string);
	    toString(): string;
	}

}
declare module Coveo {
	/**
	 * Describe a field value returned by index
	 */
	export interface IIndexFieldValue {
	    /**
	     * The value
	     */
	    value: string;
	    /**
	     * The optional lookupValue, if requested in the {@link IGroupByRequest}
	     */
	    lookupValue?: string;
	    /**
	     * The number of results in the index which have this value
	     */
	    numberOfResults: number;
	    /**
	     * The optional computedFieldResults, if requested in the {@link IGroupByRequest}
	     */
	    computedFieldResults?: number[];
	}

}
declare module Coveo {
	
	/**
	 * Describe a single group by value, returned by a {@link IGroupByResult}
	 */
	export interface IGroupByValue extends IIndexFieldValue {
	    /**
	     * The string value. Think : Facet label.
	     */
	    value: string;
	    /**
	     * The lookup value if it was specified.
	     */
	    lookupValue?: string;
	    /**
	     * The number of results that match this value in the index for this particular group by request
	     */
	    numberOfResults: number;
	    /**
	     * The relevance score.
	     */
	    score: number;
	    /**
	     * If there was ny computed field request, the results will be available here.
	     */
	    computedFieldResults?: number[];
	}

}
declare module Coveo {
	
	/**
	 * A result for a {@link IGroupByRequest}.
	 *
	 * This is typically what the {@link Facet} component will use to render themselves.
	 */
	export interface IGroupByResult {
	    /**
	     * The field on which the group by was performed.
	     */
	    field: string;
	    /**
	     * The differents values for this result
	     */
	    values: IGroupByValue[];
	    /**
	     * Available if there was any computed field request.
	     */
	    globalComputedFieldResults?: number[];
	}

}
declare module Coveo {
	
	
	
	/**
	 * A class which holds information and operation available on a single facet value returned by a {@link IGroupByRequest}.<br/>
	 * This class is used extensibely in the {@link Facet} component.
	 */
	export class FacetValue {
	    value: string;
	    lookupValue: string;
	    occurrences: number;
	    computedField: number;
	    delta: number;
	    score: number;
	    selected: boolean;
	    excluded: boolean;
	    waitingForDelta: boolean;
	    reset(): void;
	    updateCountsFromNewValue(newValue: FacetValue): void;
	    cloneWithZeroOccurrences(): FacetValue;
	    cloneWithDelta(count: number, delta: number): FacetValue;
	    getFormattedCount(): string;
	    getFormattedComputedField(format: string): any;
	    static create(value: any): FacetValue;
	    static createFromValue(value: string): FacetValue;
	    static createFromGroupByValue(groupByValue: IGroupByValue): FacetValue;
	    static createFromFieldValue(fieldValue: IIndexFieldValue): FacetValue;
	}
	export class FacetValues {
	    private values;
	    constructor(groupByResult?: IGroupByResult);
	    add(facetValue: FacetValue): void;
	    remove(value: string): void;
	    size(): number;
	    isEmpty(): boolean;
	    at(index: number): FacetValue;
	    get(value: string): FacetValue;
	    contains(value: string): boolean;
	    getAll(): FacetValue[];
	    getSelected(): FacetValue[];
	    getExcluded(): FacetValue[];
	    hasSelectedOrExcludedValues(): boolean;
	    reset(): void;
	    
	    updateCountsFromNewValues(newValues: FacetValues): void;
	    updateDeltaWithFilteredFacetValues(filtered: FacetValues): void;
	    mergeWithUnfilteredFacetValues(unfiltered: FacetValues): void;
	    sortValuesDependingOnStatus(excludeLastIndex?: number): void;
	}

}
declare module Coveo {
	export class JQueryUtils {
	    static getJQuery(): any;
	    static isInstanceOfJQuery(obj: Object): boolean;
	    static isInstanceOfJqueryEvent(obj: Object): boolean;
	}

}
declare module Coveo {
	export interface IOffset {
	    left: number;
	    top: number;
	}
	/**
	 * This is essentially an helper class for dom manipulation.<br/>
	 * This is intended to provide some basic functionality normally offered by jQuery.<br/>
	 * To minimize the multiple jQuery conflict we have while integrating in various system, we implemented the very small subset that the framework needs.<br/>
	 * See {@link $$}, which is a function that wraps this class constructor, for less verbose code.
	 */
	export class Dom {
	    private static CLASS_NAME_REGEX;
	    private static ONLY_WHITE_SPACE_REGEX;
	    el: HTMLElement;
	    /**
	     * Create a new Dom object with the given HTMLElement
	     * @param el The HTMLElement to wrap in a Dom object
	     */
	    constructor(el: HTMLElement);
	    private static handlers;
	    /**
	     * Helper function to quickly create an HTMLElement
	     * @param type The type of the element (e.g. div, span)
	     * @param props The props (id, className, attributes) of the element<br/>
	     * Can be either specified in dashed-case strings ('my-attribute') or camelCased keys (myAttribute),
	     * the latter of which will automatically get replaced to dash-case.
	     * @param innerHTML The contents of the new HTMLElement, either in string form or as another HTMLElement
	     */
	    static createElement(type: string, props?: Object, ...children: Array<string | HTMLElement | Dom>): HTMLElement;
	    /**
	     * Adds the element to the children of the current element
	     * @param element The element to append
	     * @returns {string}
	     */
	    append(element: HTMLElement): void;
	    /**
	     * Get the css value of the specified property.<br/>
	     * @param property The property
	     * @returns {string}
	     */
	    css(property: string): string;
	    /**
	     * Get or set the text content of the HTMLElement.<br/>
	     * @param txt Optional. If given, this will set the text content of the element. If not, will return the text content.
	     * @returns {string}
	     */
	    text(txt?: string): string;
	    /**
	     * Performant way to transform a NodeList to an array of HTMLElement, for manipulation<br/>
	     * http://jsperf.com/nodelist-to-array/72
	     * @param nodeList a {NodeList} to convert to an array
	     * @returns {HTMLElement[]}
	     */
	    nodeListToArray(nodeList: NodeList): HTMLElement[];
	    /**
	     * Empty (remove all child) from the element;
	     */
	    empty(): void;
	    /**
	     * Empty the element and all childs from the dom;
	     */
	    remove(): void;
	    /**
	     * Show the element;
	     */
	    show(): void;
	    /**
	     * Hide the element;
	     */
	    hide(): void;
	    /**
	     * Toggle the element visibility.<br/>
	     * Optional visible parameter, if specified will set the element visibility
	     * @param visible Optional parameter to display or hide the element
	     */
	    toggle(visible?: boolean): void;
	    /**
	     * Returns the value of the specified attribute.
	     * @param name The name of the attribute
	     */
	    getAttribute(name: string): string;
	    /**
	     * Sets the value of the specified attribute.
	     * @param name The name of the attribute
	     * @param value The value to set
	     */
	    setAttribute(name: string, value: string): void;
	    /**
	     * Find a child element, given a CSS selector
	     * @param selector A CSS selector, can be a .className or #id
	     * @returns {HTMLElement}
	     */
	    find(selector: string): HTMLElement;
	    /**
	     * Check if the element match the selector.<br/>
	     * The selector can be a class, an id or a tag.<br/>
	     * Eg : .is('.foo') or .is('#foo') or .is('div').
	     */
	    is(selector: string): boolean;
	    /**
	     * Get the first element that matches the classname by testing the element itself and traversing up through its ancestors in the DOM tree.<br/>
	     * Stops at the body of the document
	     * @param className A CSS classname
	     */
	    closest(className: string): HTMLElement;
	    /**
	     * Return all children
	     * @returns {HTMLElement[]}
	     */
	    children(): HTMLElement[];
	    /**
	     * Return all siblings
	     * @returns {HTMLElement[]}
	     */
	    siblings(selector: string): HTMLElement[];
	    private matches(element, selector);
	    /**
	     * Find all children that match the given CSS selector
	     * @param selector A CSS selector, can be a .className
	     * @returns {HTMLElement[]}
	     */
	    findAll(selector: string): HTMLElement[];
	    /**
	     * Find the child elements using a className
	     * @param className Class of the childs elements to find
	     * @returns {HTMLElement[]}
	     */
	    findClass(className: string): HTMLElement[];
	    /**
	     * Find an element using an ID
	     * @param id ID of the element to find
	     * @returns {HTMLElement}
	     */
	    findId(id: string): HTMLElement;
	    /**
	     * Add a class to the element. Takes care of not adding the same class if the element already has it.
	     * @param className Classname to add to the element
	     */
	    addClass(classNames: string[]): void;
	    addClass(className: string): void;
	    /**
	     * Remove the class on the element. Works even if the element does not possess the class.
	     * @param className Classname to remove on the the element
	     */
	    removeClass(className: string): void;
	    /**
	     * Toggle the class on the element.
	     * @param className Classname to toggle
	     * @swtch If true, add the class regardless and if false, remove the class
	     */
	    toggleClass(className: string, swtch?: boolean): void;
	    /**
	     * Sets the inner html of the element
	     * @param html The html to set
	     */
	    setHtml(html: string): void;
	    /**
	     * Return an array with all the classname on the element. Empty array if the element has not classname
	     * @returns {any|Array}
	     */
	    getClass(): string[];
	    /**
	     * Check if the element has the given class name
	     * @param className Classname to verify
	     * @returns {boolean}
	     */
	    hasClass(className: string): boolean;
	    /**
	     * Detach the element from the DOM.
	     */
	    detach(): void;
	    /**
	     * Insert the current node after the given reference node
	     * @param refNode
	     */
	    insertAfter(refNode: HTMLElement): void;
	    /**
	     * Insert the current node before the given reference node
	     * @param refNode
	     */
	    insertBefore(refNode: HTMLElement): void;
	    /**
	     * Insert the given node as the first child of the current node
	     * @param toPrepend
	     */
	    prepend(toPrepend: HTMLElement): void;
	    /**
	     * Bind an event handler on the element. Accepts either one (a string) or multiple (Array<String>) event type.<br/>
	     * @param types The {string} or {Array<String>} of types on which to bind an event handler
	     * @param eventHandle The function to execute when the event is triggered
	     */
	    on(types: string[], eventHandle: (evt: Event, data: any) => void): void;
	    on(type: string, eventHandle: (evt: Event, data: any) => void): void;
	    /**
	     * Bind an event handler on the element. Accepts either one (a string) or multiple (Array<String>) event type.<br/>
	     * The event handler will execute only ONE time.
	     * @param types The {string} or {Array<String>} of types on which to bind an event handler
	     * @param eventHandle The function to execute when the event is triggered
	     */
	    one(types: string[], eventHandle: (evt: Event, args?: any) => void): void;
	    one(type: string, eventHandle: (evt: Event, args?: any) => void): void;
	    /**
	     * Remove an event handler on the element. Accepts either one (a string) or multiple (Array<String>) event type.<br/>
	     * @param types The {string} or {Array<String>} of types on which to remove an event handler
	     * @param eventHandle The function to remove on the element
	     */
	    off(types: string[], eventHandle: (evt: Event, arg?: any) => void): void;
	    off(type: string, eventHandle: (evt: Event, arg?: any) => void): void;
	    /**
	     * Trigger an event on the element.
	     * @param type The event type to trigger
	     * @param data
	     */
	    trigger(type: string, data?: {
	        [key: string]: any;
	    }): void;
	    /**
	     * Check if the element is "empty" (has no innerHTML content). Whitespace is considered empty</br>
	     * @returns {boolean}
	     */
	    isEmpty(): boolean;
	    /**
	     * Check if the element is a descendant of parent
	     * @param other
	     */
	    isDescendant(parent: HTMLElement): boolean;
	    /**
	     * Replace the current element with the other element, then detach the current element
	     * @param otherElem
	     */
	    replaceWith(otherElem: HTMLElement): void;
	    /**
	     * Return the position relative to the offset parent.
	     */
	    position(): IOffset;
	    /**
	     * Returns the offset parent. The offset parent is the closest parent that is positioned.
	     * An element is positioned when its position property is not 'static', which is the default.
	     */
	    offsetParent(): HTMLElement;
	    /**
	     * Return the position relative to the document.
	     */
	    offset(): IOffset;
	    /**
	     * Returns the offset width of the element
	     */
	    width(): number;
	    /**
	     * Returns the offset height of the element
	     */
	    height(): number;
	}
	export class Win {
	    win: Window;
	    constructor(win: Window);
	    height(): number;
	    width(): number;
	}
	export class Doc {
	    doc: Document;
	    constructor(doc: Document);
	    height(): number;
	    width(): number;
	}
	/**
	 * Convenience wrapper for the {@link Dom} class. Used to do $$(element).<br/>
	 * If passed with an argument which is not an HTMLElement, it will call {@link Dom.createElement}.
	 * @param el The HTMLElement to wrap in a Dom object
	 * @param type See {@link Dom.createElement}
	 * @param props See {@link Dom.createElement}
	 * @param ...children See {@link Dom.createElement}
	 */
	export function $$(dom: Dom): Dom;
	export function $$(html: HTMLElement): Dom;
	export function $$(type: string, props?: Object, ...children: Array<string | HTMLElement | Dom>): Dom;
	export function htmlToDom(html: string): Element;

}
declare module Coveo {
	export class DebugEvents {
	    static showDebugPanel: string;
	}

}
declare module Coveo {
	
	export interface IComponentHtmlElement extends HTMLElement {
	    CoveoBoundComponents?: BaseComponent[];
	}
	/**
	 * Every component in the framework ultimately inherits from this base component class.
	 */
	export class BaseComponent {
	    element: HTMLElement;
	    type: string;
	    /**
	     * Allows component to log in the dev console
	     */
	    logger: Logger;
	    /**
	     * A disabled component will not participate in the query, or listen to {@link ComponentEvents}
	     * @type {boolean}
	     */
	    disabled: boolean;
	    /**
	     * The static ID that each component need to be identified.<br/>
	     * For example, SearchButton -> static ID : SearchButton -> className : CoveoSearchButton
	     */
	    static ID: string;
	    constructor(element: HTMLElement, type: string);
	    /**
	     * Return the debug info about this component
	     * @returns {any}
	     */
	    debugInfo(): any;
	    /**
	     * Disable the component.
	     * Normally this means that the component won't execute handlers for the framework events (query events, for example).
	     * Component are enabled by default on creation.
	     */
	    disable(): void;
	    /**
	     * Enable the component.
	     * Normally this means that the component will execute handlers for the framework events (query events, for example).
	     * Components are enabled by default on creation.
	     */
	    enable(): void;
	    private initDebugInfo();
	    static bindComponentToElement(element: HTMLElement, component: BaseComponent): void;
	    static computeCssClassName(componentClass: any): string;
	    static computeCssClassNameForType(type: string): string;
	    static computeSelectorForType(type: string): string;
	    static getBoundComponentsForElement(element: IComponentHtmlElement): BaseComponent[];
	    static getComponentRef(component: string): any;
	}

}
declare module Coveo {
	
	export const MODEL_EVENTS: {
	    PREPROCESS: string;
	    CHANGE_ONE: string;
	    CHANGE: string;
	    RESET: string;
	    ALL: string;
	};
	export interface IModelSetOptions {
	    silent?: boolean;
	    customAttribute?: boolean;
	    validateType?: boolean;
	}
	export interface IAttributeChangedEventArg {
	    attribute: string;
	    value: any;
	}
	export interface IAttributesChangedEventArg {
	    attributes: {};
	}
	export interface IModelChangedEventArg {
	    model: Model;
	}
	/**
	 * A model is basically a key -> value store that trigger letious javascript event when one of the value for each of it's key changes.<br/>
	 * This is a class that is meant to be extended : the most 
	 * Component set values in this key -> value store, and listen to event triggered to react accordingly.<br/>
	 */
	export class Model extends BaseComponent {
	    /**
	     * The attributes contained in this model. Normally, you should not set attribute directly on this property, as this will not cause the required events to be triggered.
	     */
	    attributes: {
	        [key: string]: any;
	    };
	    defaultAttributes: {
	        [key: string]: any;
	    };
	    private eventNameSpace;
	    /**
	     * The event type that can be triggered :<br/>
	     * -- preprocess -> triggered before a value is set on an attribute, to allow to modify it before it's set.<br/>
	     * -- changeOne -> triggered when a single value change.
	     * @type {{preprocess: string, changeOne: string, change: string, reset: string, all: string}}
	     */
	    static eventTypes: {
	        preprocess: string;
	        changeOne: string;
	        change: string;
	        reset: string;
	        all: string;
	    };
	    constructor(element: HTMLElement, id: string, attributes: {
	        [key: string]: any;
	    });
	    set(attribute: string, value: any, options?: IModelSetOptions): void;
	    getAttributes(): {
	        [key: string]: any;
	    };
	    setMultiple(toSet: {
	        [key: string]: any;
	    }, options?: IModelSetOptions): void;
	    setNewDefault(attribute: string, value: any, options?: IModelSetOptions): void;
	    setDefault(attribute: string, options?: IModelSetOptions): void;
	    get(attribute?: string): any;
	    getDefault(attribute?: string): any;
	    reset(): void;
	    registerNewAttribute(attribute: string, defaultValue: any): void;
	    getEventName(event: string): string;
	    private attributesHasChangedEvent();
	    private attributeHasChangedEvent(attr);
	    private preprocessEvent(attributes);
	    private modelWasResetEvent();
	    private anyEvent();
	    private createAttributeChangedArgument(attribute);
	    private createAttributesChangedArgument();
	    private createModelChangedArgument();
	    private checkIfAttributeExists(attribute);
	    private validateType(attribute, value);
	    private parseToCorrectType(attribute, value);
	    private checkIfAttributeChanged(attribute, newValue);
	    debugInfo(): any;
	}

}
declare module Coveo {
	export interface IStringMap<T> {
	    [paramName: string]: T;
	}

}
declare module Coveo {
	
	
	export const QUERY_STATE_ATTRIBUTES: {
	    Q: string;
	    FIRST: string;
	    T: string;
	    TG: string;
	    SORT: string;
	    HD: string;
	    HQ: string;
	    QUICKVIEW: string;
	};
	export interface IQueryStateIncludedAttribute {
	    title: string;
	    included: string[];
	}
	export interface IQueryStateExcludedAttribute {
	    title: string;
	    excluded: string[];
	}
	/**
	 * The QueryStateModel is a key->value store of the state of every component that can affect a query.<br/>
	 * Component set values in this key -> value store, and listen to event triggered to react accordingly.<br/>
	 * For example, when a query is launched, the searchbox will set the 'q' attribute, the pager will set the 'first' attribute, etc.<br/>
	 * At the same time, this class will trigger the associated event when a value is modified.<br/>
	 * eg : The user change the content of the searchbox, and submit a query. This will trigger the following events :<br/>
	 * -- state:change:q (because the value of 'q' changed)</br>
	 * -- state:change (because at least one value changed in the query state)<br/>
	 * Component or external code could hook handler on those events : document.addEventListener('state:change:q', handler);<br/>
	 * See : {@link Model}, as all the relevant method are exposed in the base class.<br/>
	 * Optionally, the state can be persisted to the query string to allow browser history management : See {@link HistoryController}
	 */
	export class QueryStateModel extends Model {
	    static ID: string;
	    static defaultAttributes: {
	        q: string;
	        first: number;
	        t: string;
	        hd: string;
	        hq: string;
	        sort: string;
	        tg: string;
	        quickview: string;
	    };
	    static attributesEnum: {
	        q: string;
	        first: string;
	        t: string;
	        sort: string;
	        hd: string;
	        hq: string;
	        tg: string;
	        quickview: string;
	    };
	    static getFacetId(id: string, include?: boolean): string;
	    static getFacetOperator(id: string): string;
	    static getFacetLookupValue(id: string): string;
	    /**
	     * Create a new QueryState
	     * @param element
	     * @param attributes
	     * @param bindings
	     */
	    constructor(element: HTMLElement, attributes?: IStringMap<string>);
	    /**
	     * Determine if at least one facet is currently active in the interface (this means that a facet has selected or excluded values)
	     * @returns {boolean}
	     */
	    atLeastOneFacetIsActive(): boolean;
	    set(attribute: string, value: any, options?: IModelSetOptions): void;
	    private validate(attribute, value);
	}
	export function setState(model: Model, args: any[]): any;

}
declare module Coveo {
	
	
	export class ComponentStateModel extends Model {
	    static ID: string;
	    constructor(element: HTMLElement);
	    registerComponent(componentId: string, component: BaseComponent): void;
	}

}
declare module Coveo {
	
	export interface IComponentOptionsAttributes {
	    resultLink: any;
	    searchHub: string;
	}
	export class ComponentOptionsModel extends Model {
	    static ID: string;
	    static defaultAttributes: IComponentOptionsAttributes;
	    static attributesEnum: {
	        resultLink: string;
	        searchHub: string;
	    };
	    constructor(element: HTMLElement, attributes?: IComponentOptionsAttributes);
	}

}
declare module Coveo {
	
	export class RootComponent extends BaseComponent {
	    element: HTMLElement;
	    type: string;
	    constructor(element: HTMLElement, type: string);
	}

}
declare module Coveo {
	/**
	 * Describe the identity of a user on the Coveo platform
	 */
	export interface IUserIdentity {
	    /**
	     * The name of the identity
	     */
	    name: string;
	    /**
	     * The provider of the identity in the Coveo platform
	     */
	    provider: string;
	    type: string;
	}

}
declare module Coveo {
	/**
	 * Describe a ranking expression performed against the index (qre)
	 */
	export interface IRankingExpression {
	    /**
	     * The expression that was executed in the ranking expression
	     */
	    expression: string;
	    /**
	     * The relevance modifier that was applied
	     */
	    modifier: string;
	}

}
declare module Coveo {
	/**
	 * Describe an exception that was triggered by the index when performing the query.
	 */
	export interface IQueryException {
	    /**
	     * The exception code
	     */
	    code: string;
	    context: string;
	}

}
declare module Coveo {
	/**
	 * Describe correction for a query
	 */
	export interface IQueryCorrection {
	    /**
	     * The query once corrected
	     */
	    correctedQuery: string;
	    /**
	     * Array of correction for each word in the query
	     */
	    wordCorrections: IWordCorrection[];
	}
	export interface IWordCorrection {
	    /**
	     * Offset, from the beginning of the query
	     */
	    offset: number;
	    /**
	     * Length of the correction
	     */
	    length: number;
	    /**
	     * The original word that was corrected
	     */
	    originalWord: string;
	    /**
	     * The new corrected word
	     */
	    correctedWord: string;
	}

}
declare module Coveo {
	/**
	 * A trigger is an action that the interface will perform (show a message, execute a function, redirect users) depending on the query that was performed.<br/>
	 * A trigger that can be configured in the Coveo Query Pipeline.
	 */
	export interface ITrigger<T> {
	    type: string;
	    content: T;
	}
	/**
	 * Notify (show a message) to a user
	 */
	export interface ITriggerNotify extends ITrigger<string> {
	}
	/**
	 * Redirect the user to another url
	 */
	export interface ITriggerRedirect extends ITrigger<string> {
	}
	/**
	 * Perform a new query with a different query expression
	 */
	export interface ITriggerQuery extends ITrigger<string> {
	}
	/**
	 * Execute a javascript function present in the page.
	 */
	export interface ITriggerExecute extends ITrigger<{
	    name: string;
	    params: any[];
	}> {
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	/**
	 * Describe a set a results returned by the Search API
	 */
	export interface IQueryResults {
	    /**
	     * When an error occurs, and the errorsAsSuccess flag is passed, the error will be returned in the body of the response
	     */
	    error?: {
	        /**
	         * The error message
	         */
	        message: string;
	        /**
	         * The type of error
	         */
	        type: string;
	        /**
	         * A detailed execution report sent by the Search API
	         */
	        executionReport: any;
	    };
	    /**
	     * A detailed execution report sent by the Search API.<br/>
	     * Only sent if {@link IQuery.debug} is true
	     */
	    executionReport?: any;
	    /**
	     * The basic expression that was executed.<br/>
	     * Only sent if {@link IQuery.debug} is true
	     */
	    basicExpression?: string;
	    /**
	     * The advanced expression that was executed.<br/>
	     * Only sent if {@link IQuery.debug} is true
	     */
	    advancedExpression?: string;
	    /**
	     * The constant expression that was executed.<br/>
	     * Only sent if {@link IQuery.debug} is true
	     */
	    constantExpression?: string;
	    /**
	     * A list of user identities that were used to perform this query.<br/>
	     * Only sent if {@link IQuery.debug} is true
	     */
	    userIdentities?: IUserIdentity[];
	    /**
	     * A list of ranking expression that were used to tweak the relevance.<br/>
	     * Only sent if {@link IQuery.debug} is true
	     */
	    rankingExpressions?: IRankingExpression[];
	    /**
	     * The total number of results that matched the query in the index.
	     */
	    totalCount: number;
	    /**
	     * The total number of results that matched the query in the index, but with the duplicate filtered.
	     */
	    totalCountFiltered: number;
	    /**
	     * The duration of the query on the Coveo platform.
	     */
	    duration: number;
	    /**
	     * The duration of the query on the Coveo Index.
	     */
	    indexDuration: number;
	    /**
	     * The duration of the query on the proxy (not always applicable, can be optional)
	     */
	    proxyDuration?: number;
	    /**
	     * The duration of the query for the client.
	     */
	    clientDuration: number;
	    /**
	     * A unique identifier for this query, used mainly for the {@link Analytics} service.
	     */
	    searchUid?: string;
	    /**
	     * The pipeline that was used for this query.
	     */
	    pipeline?: string;
	    /**
	     * The search api version that was used for this query.
	     */
	    apiVersion?: number;
	    /**
	     * The split test run that was used for this query. (A/B tests feature of the Coveo Query Pipeline)
	     */
	    splitTestRun?: string;
	    /**
	     * The exception that can be returned by the index if the query triggered an error
	     */
	    exception?: IQueryException;
	    /**
	     * The results of the query
	     */
	    results: IQueryResult[];
	    /**
	     * The group by results of the query
	     */
	    groupByResults: IGroupByResult[];
	    /**
	     * Possible query corrections (eg : {@link DidYouMean})
	     */
	    queryCorrections: IQueryCorrection[];
	    /**
	     * Terms to highlight (with stemming) in the results
	     */
	    termsToHighlight: {
	        [originalTerm: string]: string[];
	    };
	    /**
	     * Phrases to highlight (with stemming) in the results
	     */
	    phrasesToHighlight: {
	        [originalTerm: string]: string[];
	    };
	    /**
	     * The Coveo Query Pipeline triggers, if any were configured.
	     */
	    triggers: ITrigger<any>[];
	    _folded: boolean;
	    _reusedSearchUid?: boolean;
	}

}
declare module Coveo {
	/**
	 * Describe a query function that can be executed against the index<br/>
	 * See : https://developers.coveo.com/display/SearchREST/Query+Function
	 */
	export interface IQueryFunction {
	    /**
	     * Function to execute, as a string
	     */
	    'function': string;
	    /**
	     * The field name on which to store the query function result when the query returns
	     */
	    fieldName: string;
	}

}
declare module Coveo {
	/**
	 * Describe a ranking function that can be executed against the index.<br/>
	 * See : https://developers.coveo.com/display/SearchREST/Ranking+Function
	 */
	export interface IRankingFunction {
	    /**
	     * The mathematical expression that calculates the ranking value to add to the result score.
	     */
	    expression: string;
	    /**
	     * Whether to normalize the value using the standard index scale or not. If you don't want to completely override the index ranking and use the qrf as a boost, you should turn this on.
	     */
	    normalizeWeight: boolean;
	}

}
declare module Coveo {
	/**
	 * Describe a computed field request<br/>
	 * See : https://developers.coveo.com/display/SearchREST/Computed+Field+Parameters
	 */
	export interface IComputedFieldRequest {
	    /**
	     * This specifies the field on which the aggregate operation will be performed. This field is typically a numerical value.
	     */
	    field: string;
	    /**
	     * This specifies the operation to execute on the field value.<br/>
	     * Possible operations:
	     * -- sum: Computes the sum of all values.
	     * -- average: Computes the average of all values.
	     * --minimum: Retrieves the smallest of all values.
	     * --maximum: Retrieves the largest of all values.
	     */
	    operation: string;
	}

}
declare module Coveo {
	/**
	 * Describe a single rangle value in a group by
	 */
	export interface IRangeValue {
	    /**
	     * Start of the range.
	     */
	    start?: any;
	    /**
	     * End of the range
	     */
	    end?: any;
	    /**
	     * Label to generate for this range
	     */
	    label?: string;
	    /**
	     * Is the end parameter included or excluded in this range.
	     */
	    endInclusive?: boolean;
	}

}
declare module Coveo {
	
	
	/**
	 * Describe a group by request to perform against the index.<br/>
	 * See : https://developers.coveo.com/display/SearchREST/Group+By+Parameters
	 */
	export interface IGroupByRequest {
	    /**
	     * This specifies the field on which the Group By operation is performed. The Group By will return a Group By value for each distinct value of this field within the result set.
	     */
	    field: string;
	    lookupField?: string;
	    /**
	     * This specifies how the Group By values should be sorted by the indexer. If not specified, the default value is Score.<br/>
	     * Possible values are :<br/>
	     * -- score : the score is computed from the number of occurrences as well as from the position in the result set where the items having this value are appearing. Using this criterion, an item with 100 occurrences might appear after one with only 10 occurrences if those occurrences tend to appear sooner in the ranked result set.<br/>
	     * -- occurrences : Sort by number of occurrences, with values having the highest number appearing first. <br/>
	     * -- alphaascending / alphadescending : Sort alphabetically on the field values. <br/>
	     * -- computedfieldascending / computedfielddescending : Sort on the values of the first computed field for each Group By value. <br/>
	     * -- chisquare : Sort based on the relative frequency of values in the result set compared to the frequency in the whole index. This means that a value that doesn't appear often in the index but does appear often in the result set will tend to appear higher in the list.<br/>
	     * -- nosort : Do not sort the Group By values. The values will be returned in a random order.
	     */
	    sortCriteria?: string;
	    /**
	     * This specifies the maximum number of values that the Group By operation will return.<br/>
	     * If not specified, the default value is 10.
	     */
	    maximumNumberOfValues?: number;
	    /**
	     * This specifies how deep the index will scan the results to identify missing Group By values.<br/>
	     * If not specified, the default value is 1000.<br/>
	     * When executing a Group By operation, the index uses various heuristics to list all the values that are appearing in the result set. In some corner cases, some values might be omitted (it's a classical trade-off of precision vs performance). Using injection means that the index will explicitly scan the field values of the top n results of the query, and ensure that the values present in those results are included. Using higher values for this parameter may impact query performance.
	     */
	    injectionDepth?: number;
	    /**
	     * This specifies a different query expression on which to compute the Group By operation.<br/>
	     * By default, the query expression being executed is used.<br/>
	     * This feature is typically used for performance reasons to retrieve Group By values on separate expressions while executing a normal query in a single operation.
	     */
	    queryOverride?: string;
	    advancedQueryOverride?: string;
	    /**
	     * This specifies a constant query expression on which to compute the Group By operation.<br/>
	     * By default, the constant part of the query expression being executed is used.<br/>
	     * This feature is much like the normal queryOverride except that the index will keep the query expression in cache for faster queries. Do no put dynamic query expression in this parameter, as it will negatively impact the performance.
	     */
	    constantQueryOverride?: string;
	    /**
	     * This explicitly specifies a list of values for which Group By values should be generated.<br/>
	     * Trailing wildcards can be used to include ranges of values.<br/>
	     * eg : The array ["foo", "bar*"] would return Group By values for foo and any value starting with bar.
	     */
	    allowedValues?: string[];
	    /**
	     * This specifies an array of computed fields that should be computed for each Group By value that is returned.<br/>
	     * Computed fields are used to perform aggregate operations on other fields for all the matching documents having a specific value in the Group By field in the results
	     */
	    computedFields?: IComputedFieldRequest[];
	    /**
	     * This explicitly specifies a list of range values for which Group By values should be generated.
	     */
	    rangeValues?: IRangeValue[];
	    /**
	     * By setting the parameter generateAutomaticRanges to true, the ranges will be calculated by the Coveo index.
	     */
	    generateAutomaticRanges?: boolean;
	    completeFacetWithStandardValues?: boolean;
	}

}
declare module Coveo {
	
	
	
	/**
	 * Describe a query that can be performed on the Coveo Search API.<br/>
	 * For basic usage, see the {@link IQuery.q} and {@link IQuery.aq} properties.<br/>
	 * In a normal scenario, a query is built using the {@link QueryBuilder}
	 */
	export interface IQuery {
	    /**
	     * The basic query expression. <br/>
	     * This is typically the query expression entered by the user in a query box.<br/>
	     * Since this part of the query is expected to come from user input, it is processed by the Did You Mean feature.
	     */
	    q: string;
	    /**
	     * The advanced query expression.<br/>
	     * This is the part of the query expression generated by code based on various rules.<br/>
	     * eg: Selecting a facet value will cause an expression to be added to the advanced query expression.
	     */
	    aq?: string;
	    /**
	     * The constant query expression.<br/>
	     * This part of the expression is much alike the advanced query expression, but it is meant to hold expressions that are constant for all users of a search interface/widget.<br/>
	     * The results of evaluating those expressions are kept in a special index cache, to avoid re-evaluating them on each query.<br/>
	     * You must be careful to not include dynamic parts in this expression, otherwise you risk filling up the cache with useless data and this might have a negative impact on performance.<br/>
	     * Expressions other than cq also benefit from caching in the index, but using cq allows to explicitly require that a part of the query be included in the cache.
	     */
	    cq?: string;
	    /**
	     * The disjunction query expression.<br/>
	     * This is the disjunctive part of the query expression that is merged with the other expression parts using an OR boolean operator.<br/>
	     * When specified, the final expression evaluated by the index ends up being (q aq cq) OR (dq).
	     */
	    dq?: string;
	    /**
	     * The hub value set from the {@link Analytics} component.<br/>
	     * Used for analytics reporting in the Coveo platform
	     */
	    searchHub?: string;
	    /**
	     * The tab value set from the {@link Tab} component.
	     */
	    tab?: string;
	    language?: string;
	    /**
	     * Name of the query pipeline to use.<br/>
	     * This specifies the name of the query pipeline to use for the query. If not specified, the default value is default, which means the default query pipeline will be used.
	     */
	    pipeline?: string;
	    /**
	     * The maximum age for cached query results, in milliseconds.<br/>
	     * If results for the exact same request (including user identities) are available in the in-memory cache, they will be used if they are not older than the specified value.<br/>
	     * Otherwise, the query will be sent to the index.
	     */
	    maximumAge?: number;
	    /**
	     * Whether to enable wildcards on the basic expression keywords.<br/>
	     * This enables the wildcard features of the index. Coveo Platform will expand keywords containing wildcard characters to the possible matching keywords to broaden the query.<br/>
	     * See : https://onlinehelp.coveo.com/en/ces/7.0/user/using_wildcards_in_queries.htm<br/>
	     * If not specified, this parameter defaults to false.
	     */
	    wildcards?: boolean;
	    /**
	     * Whether to enable question marks with wildcards.<br/>
	     * This enables using the question mark ? character within wildcard expressions.
	     */
	    questionMark?: boolean;
	    /**
	     * Whether to enable the support for operator in lowercase (AND OR -> and or)
	     */
	    lowercaseOperators?: boolean;
	    /**
	     * Whether to enable partial matching of the basic expression keywords.<br/>
	     * By activating this, when the basic expression contains at least {@link IQuery.partialMatchKeywords}, documents containing only the number of keywords specified by {@link IQuery.partialMatchThreshold} will also match the query.<br/>
	     * Without this option, documents are required to contain all the keywords in order to match the query.<br/>
	     * If not specified, this parameter defaults to false.
	     */
	    partialMatch?: boolean;
	    /**
	     * The minimum number of keywords needed to activate partial match.<br/>
	     * This specifies the minimum number of keywords needed for the partial match feature to activate.<br/>
	     * If the basic expression contains less than this number of keywords, no transformation is applied on the query.<br/>
	     * If not specified, this parameter defaults to 5.
	     */
	    partialMatchKeywords?: number;
	    /**
	     * The threshold to use for matching documents when partial match is enabled.<br/>
	     * This specifies the minimum number of query keywords that a document must contain when partial match is enabled. This value can either be an absolute number or a percentage value based on the total number of keywords.<br/>
	     * If not specified, this parameter defaults to 50%.
	     */
	    partialMatchThreshold?: string;
	    /**
	     * This is the 0-based index of the first result to return.<br/>
	     * If not specified, this parameter defaults to 0.
	     */
	    firstResult?: number;
	    /**
	     * This is the number of results to return, starting from {@link IQuery.firstResult}.<br/>
	     * If not specified, this parameter defaults to 10.
	     */
	    numberOfResults?: number;
	    /**
	     * This specifies the sort criterion(s) to use to sort results. If not specified, this parameter defaults to Relevancy.<br/>
	     * Possible values are : <br/>
	     * -- relevancy :  This uses all the configured ranking weights as well as any specified ranking expressions to rank results.<br/>
	     * -- dateascending / datedescending : Sort using the value of the @date field, which is typically the last modification date of an item in the index.<br/>
	     * -- qre : Sort using only the weights applied through ranking expressions. This is much like using Relevancy except that automatic weights based on keyword proximity etc, are not computed.<br/>
	     * -- nosort : Do not sort the results. The order in which items are returned is essentially random.<br/>
	     * -- @field ascending / @field descending : Sort using the value of a custom field.
	     */
	    sortCriteria?: string;
	    sortField?: string;
	    /**
	     * This specifies a field on which {@link Folding} should be performed.<br/>
	     * Folding is a kind of duplicate filtering where only the first result with any given value of the field is included in the result set.<br/>
	     * It's typically used to return only one result in a conversation, for example when forum posts in a thread are indexed as separate items.
	     */
	    filterField?: string;
	    /**
	     * Number of results that should be folded, using the {@link IQuery.filterField}
	     */
	    filterFieldRange?: number;
	    /**
	     * This specifies an array of fields that should be returned for each result.<br/>
	     * eg: ['@foo','@bar']
	     *
	     */
	    fieldsToInclude?: string[];
	    /**
	     * This specifies an array of fields that should be excluded from the query results.<br/>
	     * eg: ['@foo','@bar']
	     *
	     */
	    fieldsToExclude?: string[];
	    /**
	     * This specifies the length (in number of characters) of the excerpts generated by the indexer based on the keywords present in the query.<br/>
	     * The index includes the top most interesting sentences (in the order they appear in the document) that fit in the specified number of characters.<br/>
	     * When not specified, the default value is 200.
	     */
	    excerptLength?: number;
	    /**
	     * This specifies whether the first sentences of the document should be included in the results.<br/>
	     * The retrieveFirstSentences option is typically used instead of excerpts when displaying email items, where the first sentence of the email might be of more interest than a contextually generated excerpt.
	     */
	    retrieveFirstSentences?: boolean;
	    /**
	     * This enables the query correction feature of the index.<br/>
	     * By activating this, the index returns an array of {link IQueryCorrection} with suggested word corrections.
	     */
	    enableDidYouMean?: boolean;
	    /**
	     * This specifies an array of Query Function operation that will be executed on the results.
	     */
	    queryFunctions?: IQueryFunction[];
	    /**
	     * This specifies an array of Ranking Function operations that will be executed on the result
	     */
	    rankingFunctions?: IRankingFunction[];
	    /**
	     * This specifies an array of Group By operations that can be performed on the query results to extract facets
	     */
	    groupBy?: IGroupByRequest[];
	    /**
	     * Setting this property to true will return more debugging information from both the index and the search API.
	     * Use this with care as this will negatively impact the performance of the query.
	     *
	     * It should probably never be set to `true` in production mode...
	     */
	    debug?: boolean;
	    timezone?: string;
	    /**
	     * Whether to disable the special query syntax such as field references for the basic query expression (parameter q).
	     * It is equivalent to a No syntax block applied to the basic query expression.
	     * If not specified, the parameter defaults to false
	     */
	    disableQuerySyntax?: boolean;
	    enableDuplicateFiltering?: boolean;
	    /**
	     * Whether the index should take collaborative rating in account when ranking result. See : {@link ResultRating}
	     */
	    enableCollaborativeRating?: boolean;
	    /**
	     * Specifies the childField when doing parent-child loading (See : {@link Folding})
	     */
	    childField?: string;
	    /**
	     * Specifies the parentField when doing parent-child loading (See : {@link Folding})
	     */
	    parentField?: string;
	    /**
	     * The context is a map of key_value that can be used in the Query pipeline in the Coveo platform.<br/>
	     */
	    context?: {
	        [name: string]: any;
	    };
	    /**
	     * The actions history represents the past actions a user made and is used by reveal to suggest recommendations.
	     * It is generated by the page view script (https://github.com/coveo/coveo.analytics.js)
	     */
	    actionsHistory?: string;
	    /**
	     * This is the id of the recommendation interface that generated the query.
	     */
	    recommendation?: string;
	}

}
declare module Coveo {
	
	
	
	export class QueryUtils {
	    static createGuid(): string;
	    static generateWithRandom(): string;
	    static generateWithCrypto(): string;
	    static setStateObjectOnQueryResults(state: any, results: IQueryResults): void;
	    static setStateObjectOnQueryResult(state: any, result: IQueryResult): void;
	    static setIndexAndUidOnQueryResults(query: IQuery, results: IQueryResults, queryUid: string, pipeline: string, splitTestRun: string): void;
	    static setTermsToHighlightOnQueryResults(query: IQuery, results: IQueryResults): void;
	    static splitFlags(flags: string, delimiter?: string): string[];
	    static isAttachment(result: IQueryResult): boolean;
	    static containsAttachment(result: IQueryResult): boolean;
	    static hasHTMLVersion(result: IQueryResult): boolean;
	    static hasThumbnail(result: IQueryResult): boolean;
	    static hasExcerpt(result: IQueryResult): boolean;
	    static quoteAndEscapeIfNeeded(str: string): string;
	    static quoteAndEscape(str: string): string;
	    static escapeString(str: string): string;
	    static isAtomicString(str: string): boolean;
	    static isRangeString(str: string): boolean;
	    static isRangeWithoutOuterBoundsString(str: string): boolean;
	    static buildFieldExpression(field: string, operator: string, values: string[]): string;
	    static buildFieldNotEqualExpression(field: string, values: string[]): string;
	    static mergeQueryString(url: string, queryString: string): string;
	    static mergePath(url: string, path: string): string;
	    static setPropertyOnResults(results: IQueryResults, property: string, value: any, afterOneLoop?: () => any): void;
	    static setPropertyOnResult(result: IQueryResult, property: string, value: any): void;
	    static getUrlParameter(name: string): string;
	    static isStratusAgnosticField(fieldToVerify: string, fieldToMatch: string): boolean;
	}

}
declare module Coveo {
	/**
	 * An ExpressionBuilder that is mostly used by the {@link QueryBuilder}<br/>
	 * It is used to build a single query expression.<br/>
	 * It allows combining multiple expression parts into a single string and provides utilities to generate common expression parts.
	 */
	export class ExpressionBuilder {
	    private parts;
	    wrapParts: boolean;
	    /**
	     * Add a new part to the expression.
	     * @param expression
	     */
	    add(expression: string): void;
	    /**
	     * Take another ExpressionBuilder, and copy it.
	     * @param expression
	     */
	    fromExpressionBuilder(expression: ExpressionBuilder): void;
	    /**
	     * Add a new part to the expression, but specific for field values<br/>
	     * eg @field=(value1,value2,value3)
	     * @param field The field for which to create an expression eg: @foo
	     * @param operator The operator to use eg: = (equal) == (strict equal) <> (not equal)
	     * @param values The values to put in the expression
	     */
	    addFieldExpression(field: string, operator: string, values: string[]): void;
	    /**
	     * Add a new part to the expression, but specific for field values<br/>
	     * eg : NOT @field==(value1, value2, value3)
	     * @param field The field for which to create an expression eg: @foo
	     * @param values The values to put in the expression
	     */
	    addFieldNotEqualExpression(field: string, values: string[]): void;
	    /**
	     * Removes an expression from the builder.
	     * @param expression
	     */
	    remove(expression: string): void;
	    /**
	     * Checks if the builder is currently empty.
	     * @returns {boolean}
	     */
	    isEmpty(): boolean;
	    /**
	     * Builds the expression string by combining all the parts together.<br/>
	     * @param exp expression to join the different parts, default to a space
	     * @returns {any}
	     */
	    build(exp?: string): string;
	    /**
	     * Merges several ExpressionBuilder together.
	     * @param builders Builders that should be merged
	     * @returns {Coveo.ExpressionBuilder}
	     */
	    static merge(...builders: ExpressionBuilder[]): ExpressionBuilder;
	    /**
	     * Merges several ExpressionBuilder together, using the OR operator
	     * @param builders Builders that should be merged
	     * @returns {Coveo.ExpressionBuilder}
	     */
	    static mergeUsingOr(...builders: ExpressionBuilder[]): ExpressionBuilder;
	}

}
declare module Coveo {
	
	
	
	
	
	/**
	 * Describe the expressions part of a QueryBuilder
	 */
	export interface IQueryBuilderExpression {
	    /**
	     * The whole expression
	     */
	    full?: string;
	    /**
	     * The full part, but without the constant
	     */
	    withoutConstant?: string;
	    /**
	     * The constant part of the expression
	     */
	    constant?: string;
	    /**
	     * The basic part of the expression
	     */
	    basic?: string;
	    /**
	     * The advanced part of the expression
	     */
	    advanced?: string;
	}
	/**
	 * The QueryBuilder is used to build a {@link IQuery} that will be able to be executed using the Search API.<br/>
	 * The class exposes several members and methods that help components and external code to build up the final query that is sent to the Search API.<br/>
	 */
	export class QueryBuilder {
	    /**
	     * Used to build the basic part of the query expression.<br/>
	     * This part typically consists of user-entered content such as query keywords, etc.
	     * @type {Coveo.ExpressionBuilder}
	     */
	    expression: ExpressionBuilder;
	    /**
	     * Used to build the advanced part of the query expression.<br/>
	     * This part is typically formed of filter expressions generated by components such as facets, external code, etc.
	     * @type {Coveo.ExpressionBuilder}
	     */
	    advancedExpression: ExpressionBuilder;
	    /**
	     * Used to build the advanced part of the query expression.<br/>
	     * This part is similar to advancedExpression, but its content is interpreted as a constant expression by the index and it takes advantage of special caching features.
	     * @type {Coveo.ExpressionBuilder}
	     */
	    constantExpression: ExpressionBuilder;
	    /**
	     * Used to build the disjunctive part of the query expression.<br/>
	     * When present, this part is evaluated separately from the other expressions and the matching results are merged to those matching expression, advancedExpression and constantExpression.<br/>
	     * The final boolean expression for the query is thus (basic advanced constant) OR (disjunction).
	     * @type {Coveo.ExpressionBuilder}
	     */
	    disjunctionExpression: ExpressionBuilder;
	    /**
	     * The hub value set from the {@link Analytics} component.<br/>
	     * Used for analytics reporting in the Coveo platform
	     */
	    searchHub: string;
	    /**
	     * The tab value set from the {@link Tab} component.
	     */
	    tab: string;
	    language: string;
	    /**
	     * Name of the query pipeline to use.<br/>
	     * This specifies the name of the query pipeline to use for the query. If not specified, the default value is default, which means the default query pipeline will be used.
	     */
	    pipeline: string;
	    /**
	     * The maximum age for cached query results, in milliseconds.<br/>
	     * If results for the exact same request (including user identities) are available in the in-memory cache, they will be used if they are not older than the specified value.<br/>
	     * Otherwise, the query will be sent to the index.
	     */
	    maximumAge: number;
	    /**
	     * Whether to enable wildcards on the basic expression keywords.<br/>
	     * This enables the wildcard features of the index. Coveo Platform will expand keywords containing wildcard characters to the possible matching keywords to broaden the query.<br/>
	     * See : https://onlinehelp.coveo.com/en/ces/7.0/user/using_wildcards_in_queries.htm<br/>
	     * If not specified, this parameter defaults to false.
	     */
	    enableWildcards: boolean;
	    /**
	     * Whether to enable question marks with wildcards.<br/>
	     * This enables using the question mark ? character within wildcard expressions.
	     */
	    enableQuestionMarks: boolean;
	    /**
	     * Whether to disable the special query syntax such as field references for the basic query expression (parameter q).
	     * It is equivalent to a No syntax block applied to the basic query expression.
	     * If not specified, the parameter defaults to false
	     */
	    disableQuerySyntax: boolean;
	    /**
	     * Whether to enable the support for operator in lowercase (AND OR -> and or)
	     */
	    enableLowercaseOperators: boolean;
	    /**
	     * Whether to enable partial matching of the basic expression keywords.<br/>
	     * By activating this, when the basic expression contains at least {@link IQuery.partialMatchKeywords}, documents containing only the number of keywords specified by {@link IQuery.partialMatchThreshold} will also match the query.<br/>
	     * Without this option, documents are required to contain all the keywords in order to match the query.<br/>
	     * If not specified, this parameter defaults to false.
	     */
	    enablePartialMatch: boolean;
	    /**
	     * The minimum number of keywords needed to activate partial match.<br/>
	     * This specifies the minimum number of keywords needed for the partial match feature to activate.<br/>
	     * If the basic expression contains less than this number of keywords, no transformation is applied on the query.<br/>
	     * If not specified, this parameter defaults to 5.
	     */
	    partialMatchKeywords: number;
	    /**
	     * The threshold to use for matching documents when partial match is enabled.<br/>
	     * This specifies the minimum number of query keywords that a document must contain when partial match is enabled. This value can either be an absolute number or a percentage value based on the total number of keywords.<br/>
	     * If not specified, this parameter defaults to 50%.
	     */
	    partialMatchThreshold: string;
	    /**
	     * This is the 0-based index of the first result to return.<br/>
	     * If not specified, this parameter defaults to 0.
	     */
	    firstResult: number;
	    /**
	     * This is the number of results to return, starting from {@link IQuery.firstResult}.<br/>
	     * If not specified, this parameter defaults to 10.
	     */
	    numberOfResults: number;
	    /**
	     * This specifies the length (in number of characters) of the excerpts generated by the indexer based on the keywords present in the query.<br/>
	     * The index includes the top most interesting sentences (in the order they appear in the document) that fit in the specified number of characters.<br/>
	     * When not specified, the default value is 200.
	     */
	    excerptLength: number;
	    /**
	     * This specifies a field on which {@link Folding} should be performed.<br/>
	     * Folding is a kind of duplicate filtering where only the first result with any given value of the field is included in the result set.<br/>
	     * It's typically used to return only one result in a conversation, for example when forum posts in a thread are indexed as separate items.
	     */
	    filterField: string;
	    /**
	     * Number of results that should be folded, using the {@link IQuery.filterField}
	     */
	    filterFieldRange: number;
	    /**
	     * Specifies the parentField when doing parent-child loading (See : {@link Folding})
	     */
	    parentField: string;
	    /**
	     * Specifies the childField when doing parent-child loading (See : {@link Folding})
	     */
	    childField: string;
	    fieldsToInclude: string[];
	    requiredFields: string[];
	    includeRequiredFields: boolean;
	    fieldsToExclude: string[];
	    /**
	     * Whether to enable query corrections on this query. See {@link DidYouMean}
	     */
	    enableDidYouMean: boolean;
	    /**
	     * Whether to enable debug info on the query.<br/>
	     * This will return additional information on the resulting JSON response from the Search API.<br/>
	     * Mostly : execution report (a detailed breakdown of the parsed and executed query)
	     */
	    enableDebug: boolean;
	    /**
	     * Whether the index should take collaborative rating in account when ranking result. See : {@link ResultRating}
	     */
	    enableCollaborativeRating: boolean;
	    /**
	     * This specifies the sort criterion(s) to use to sort results. If not specified, this parameter defaults to Relevancy.<br/>
	     * Possible values are : <br/>
	     * -- relevancy :  This uses all the configured ranking weights as well as any specified ranking expressions to rank results.<br/>
	     * -- dateascending / datedescending : Sort using the value of the @date field, which is typically the last modification date of an item in the index.<br/>
	     * -- qre : Sort using only the weights applied through ranking expressions. This is much like using Relevancy except that automatic weights based on keyword proximity etc, are not computed.<br/>
	     * -- nosort : Do not sort the results. The order in which items are returned is essentially random.<br/>
	     * -- @field ascending / @field descending : Sort using the value of a custom field.
	     */
	    sortCriteria: string;
	    sortField: string;
	    retrieveFirstSentences: boolean;
	    timezone: string;
	    queryUid: string;
	    /**
	     * This specifies an array of Query Function operation that will be executed on the results.
	     */
	    queryFunctions: IQueryFunction[];
	    /**
	     * This specifies an array of Ranking Function operations that will be executed on the result
	     */
	    rankingFunctions: IRankingFunction[];
	    /**
	     * This specifies an array of Group By operations that can be performed on the query results to extract facets
	     */
	    groupByRequests: IGroupByRequest[];
	    enableDuplicateFiltering: boolean;
	    /**
	     * The context is a map of key_value that can be used in the Query pipeline in the Coveo platform.<br/>
	     */
	    context: {
	        [key: string]: any;
	    };
	    /**
	     * The actions history represents the past actions a user made and is used by reveal to suggest recommendations.
	     * It is generated by the page view script (https://github.com/coveo/coveo.analytics.js)
	     */
	    actionsHistory: string;
	    /**
	     * This is the id of the recommendation interface that generated the query.
	     */
	    recommendation: string;
	    /**
	     * Build the current content or state of the query builder and return a {@link IQuery}<br/>
	     * build can be called multiple time on the same QueryBuilder.
	     * @returns {IQuery}
	     */
	    build(): IQuery;
	    /**
	     * Return only the expression(s) part(s) of the query, as a string.<br/>
	     * This means the basic, advanced and constant part in a complete expression {@link IQuery.q}, {@link IQuery.aq}, {@link IQuery.cq}
	     * @returns {string}
	     */
	    computeCompleteExpression(): string;
	    /**
	     * Return only the expression(s) part(s) of the query, as an object
	     * @returns {{full: string, withoutConstant: string, constant: string}}
	     */
	    computeCompleteExpressionParts(): IQueryBuilderExpression;
	    /**
	     * Return only the expression(s) part(s) of the query, as a string, except the given expression.<br/>
	     * This is used by {@link Facet}, to build their group by request with query override.
	     * @param except
	     * @returns {string}
	     */
	    computeCompleteExpressionExcept(except: string): string;
	    /**
	     * Return only the expression(s) part(s) of the query, as an object, except the given expression.<br/>
	     * This is used by {@link Facet}, to build their group by request with query override.
	     * @param except
	     * @returns {{full: string, withoutConstant: string, constant: string}}
	     */
	    computeCompleteExpressionPartsExcept(except: string): IQueryBuilderExpression;
	    /**
	     * Add fields to specifically include when the results return.<br/>
	     * This can be used to accelerate the execution time of every query, as there is much less data to process if you whitelist specific fields
	     * @param fields
	     */
	    addFieldsToInclude(fields: string[]): void;
	    addRequiredFields(fields: string[]): void;
	    /**
	     * Add fields to specifically exclude when the results return.<br/>
	     * This can be used to accelerate the execution time of every query, as there is much less data to process if you blacklist specific fields
	     * @param fields
	     */
	    addFieldsToExclude(fields: string[]): void;
	    computeFieldsToInclude(): string[];
	    /**
	     * Add a single context key->value pair to the query.<br/>
	     * This is used by the Query pipeline in the Coveo platform.
	     * @param key
	     * @param value
	     */
	    addContextValue(key: string, value: any): void;
	    /**
	     * Add a context object to the query.<br/>
	     * This can contain multiple key->value.<br/>
	     * This is used by the Query pipeline in the Coveo platform.
	     * @param values
	     */
	    addContext(values: {
	        [key: string]: any;
	    }): void;
	}

}
declare module Coveo {
	export interface ITimeSpanUtilsOptions {
	    isMilliseconds: boolean;
	}
	export class TimeSpan {
	    private milliseconds;
	    constructor(time: number, isMilliseconds?: boolean);
	    getMilliseconds(): number;
	    getSeconds(): number;
	    getMinutes(): number;
	    getHours(): number;
	    getDays(): number;
	    getWeeks(): number;
	    getHHMMSS(): string;
	    static fromDates(from: Date, to: Date): TimeSpan;
	}

}
declare module Coveo {
	export class DeviceUtils {
	    static getDeviceName(): string;
	    static isAndroid(): boolean;
	    static isIos(): boolean;
	    static isIE8or9(): boolean;
	    static isMobileDevice(): boolean;
	    static isSmallScreenWidth(): boolean;
	    static isSmallScreenHeight(): boolean;
	}

}
declare module Coveo {
	
	
	/**
	 * Parameters that can be used when calling an {@link EndpointCaller}
	 */
	export interface IEndpointCallParameters {
	    /**
	     * Url to target
	     */
	    url: string;
	    /**
	     * Array of query string params.<br/>
	     * eg: ['foo=1','bar=2']
	     */
	    queryString: string[];
	    /**
	     * Body of the request.<br/>
	     * key -> value map (JSON)
	     */
	    requestData: IStringMap<any>;
	    /**
	     * Request data type.<br/>
	     * eg: "application/json", "application/x-www-form-urlencoded; charset=\"UTF-8\""
	     */
	    requestDataType?: string;
	    /**
	     * Or HTTP verb : GET, POST, PUT, etc.
	     */
	    method: string;
	    /**
	     * responseType of the request.</br>
	     * eg: "text", "arraybuffer" etc.
	     */
	    responseType: string;
	    /**
	     * Flag to specify if the endpoint should return different type of error as actual 200 success for the browser, but with the error code/message contained in the response.
	     */
	    errorsAsSuccess: boolean;
	}
	/**
	 * Information about a request
	 */
	export interface IRequestInfo<T> {
	    /**
	     * Url that was requested
	     */
	    url: string;
	    /**
	     * The query string parameters that were used for this request
	     */
	    queryString: string[];
	    /**
	     * The data that was sent for this request
	     */
	    requestData: IStringMap<any>;
	    /**
	     * The requestDataType that was used for this request
	     */
	    requestDataType: string;
	    /**
	     * The timestamp at which the request started
	     */
	    begun: Date;
	    /**
	     * The method that was used for this request
	     */
	    method: string;
	}
	/**
	 * A generic response
	 */
	export interface IResponse<T> {
	    /**
	     * Data of the response
	     */
	    data?: T;
	}
	/**
	 * A generic success response
	 */
	export interface ISuccessResponse<T> extends IResponse<T> {
	    /**
	     * The time that the successfull response took to complete
	     */
	    duration: number;
	    /**
	     * Data of the response
	     */
	    data: T;
	}
	/**
	 * An error response
	 */
	export interface IErrorResponse extends IResponse<IStringMap<any>> {
	    /**
	     * Status code for the error
	     */
	    statusCode: number;
	    /**
	     * Data about the error
	     */
	    data?: {
	        /**
	         * Message for the error
	         */
	        message?: string;
	        /**
	         * Type of the error
	         */
	        type?: string;
	        /**
	         * A report provided by the search api
	         */
	        executionReport?: string;
	        [key: string]: any;
	    };
	}
	/**
	 * Possible options when creating a {@link EndpointCaller}
	 */
	export interface IEndpointCallerOptions {
	    /**
	     * The access token to use for this endpoint.
	     */
	    accessToken?: string;
	    /**
	     * The username to use to log into this endpoint. Used for basic auth.<br/>
	     * Not used if accessToken is provided.
	     */
	    username?: string;
	    /**
	     * The password to use to log into this endpoint. Used for basic auth.<br/>
	     * Not used if accessToken is provided.
	     */
	    password?: string;
	}
	/**
	 * This class is in charge of calling an endpoint (eg: a {@link SearchEndpoint}).
	 *
	 * This means it's only uses to execute an XMLHttpRequest (for example), massage the response and check if there are errors.
	 *
	 * Will execute the call and return a Promise.
	 *
	 * Call using one of those options :
	 *
	 * * XMLHttpRequest for recent browser that support CORS, or if the endpoint is on the same origin.
	 * * XDomainRequest for older IE browser that do not support CORS.
	 * * Jsonp if all else fails, or is explicitly enabled.
	 */
	export class EndpointCaller {
	    options: IEndpointCallerOptions;
	    logger: Logger;
	    /**
	     * Set this property to true to enable Jsonp call to the endpoint.<br/>
	     * Be aware that jsonp is "easier" to setup endpoint wise, but has a lot of drawback and limitation for the client code.<br/>
	     * Default to false.
	     * @type {boolean}
	     */
	    useJsonp: boolean;
	    /**
	     * Create a new EndpointCaller.
	     * @param options Specify the authentication that will be used for this endpoint. Not needed if the endpoint is public and has no authentication
	     */
	    constructor(options?: IEndpointCallerOptions);
	    /**
	     * Generic call to the endpoint using the provided {@link IEndpointCallParameters}.<br/>
	     * Internally, will decide which method to use to call the endpoint :<br/>
	     * -- XMLHttpRequest for recent browser that support CORS, or if the endpoint is on the same origin.<br/>
	     * -- XDomainRequest for older IE browser that do not support CORS.<br/>
	     * -- Jsonp if all else fails, or is explicitly enabled.
	     * @param params The parameters to use for the call
	     * @returns {any} A promise of the given type
	     */
	    call<T>(params: IEndpointCallParameters): Promise<ISuccessResponse<T>>;
	    /**
	     * Call the endpoint using XMLHttpRequest. Used internally by {@link EndpointCaller.call}.<br/>
	     * Will try internally to handle error if it can.<br/>
	     * Promise will otherwise fail with the error type.
	     * @param requestInfo The info about the request
	     * @param responseType The responseType. Default to text. https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
	     * @returns {Promise<T>|Promise}
	     */
	    callUsingXMLHttpRequest<T>(requestInfo: IRequestInfo<T>, responseType?: string): Promise<ISuccessResponse<T>>;
	    /**
	     * Call the endpoint using XDomainRequest https://msdn.microsoft.com/en-us/library/cc288060(v=vs.85).aspx<br/>
	     * Used for IE8/9
	     * @param requestInfo The info about the request
	     * @returns {Promise<T>|Promise}
	     */
	    callUsingXDomainRequest<T>(requestInfo: IRequestInfo<T>): Promise<IResponse<T>>;
	    /**
	     * Call the endpoint using Jsonp https://en.wikipedia.org/wiki/JSONP<br/>
	     * Should be used for dev only, or for very special setup as using jsonp has a lot of drawbacks.
	     * @param requestInfo The info about the request
	     * @returns {Promise<T>|Promise}
	     */
	    callUsingAjaxJsonP<T>(requestInfo: IRequestInfo<T>): Promise<IResponse<T>>;
	    private parseURL(url);
	    private convertJsonToQueryString(json);
	    private convertJsonToFormBody(json);
	    private handleSuccessfulResponseThatMightBeAnError<T>(requestInfo, data, success, error);
	    private handleSuccess<T>(requestInfo, data, success);
	    private handleError<T>(requestInfo, status, data, error);
	    private combineUrlAndQueryString(url, queryString);
	    private isXDomainRequestSupported();
	    private isCORSSupported();
	    private isSuccessHttpStatus(status);
	    private tryParseResponseText(json, contentType);
	    private isErrorResponseBody(data);
	}

}
declare module Coveo {
	/**
	 * Descrobe a request to list the possible values of a field
	 */
	export interface IListFieldValuesRequest {
	    /**
	     * The field for which to list values
	     */
	    field: string;
	    /**
	     * The lookup field to use
	     */
	    lookupField?: string;
	    /**
	     * Whether to ignore accents in the values
	     */
	    ignoreAccents?: boolean;
	    /**
	     * The sort order for the returned field.
	     */
	    sortCriteria?: string;
	    /**
	     * Maximum number of field values to return
	     */
	    maximumNumberOfValues?: number;
	    /**
	     * A query to execute when returning possible field values
	     */
	    queryOverride?: string;
	    /**
	     * A query to execute when returning possible field values, put in cache in the index
	     */
	    constantQueryOverride?: string;
	    /**
	     * A pattern to filter out results
	     */
	    pattern?: string;
	    /**
	     * The type of the pattern (eg: regex)
	     */
	    patternType?: string;
	}

}
declare module Coveo {
	/**
	 * Information about a single field in the index
	 */
	export interface IFieldDescription {
	    /**
	     * It's type, as a string
	     */
	    type: string;
	    /**
	     * It's name, as a string
	     */
	    name: string;
	    /**
	     * A small(ish) description of the field
	     */
	    description: string;
	    /**
	     * The default value of the field
	     */
	    defaultValue: string;
	    /**
	     * It's fieldType, as a string.<br/>
	     * eg: Date, Double, Integer, LargeString, Long, SmallString
	     */
	    fieldType: string;
	    /**
	     * It's fieldSourceType, as a string.
	     */
	    fieldSourceType: string;
	    /**
	     * Gets whether the field can be referenced in a query.
	     */
	    includeInQuery: boolean;
	    /**
	     * Gets whether the field is returned with results.
	     */
	    includeInResults: boolean;
	    /**
	     * Gets whether the field is considered groupBy (facet)
	     */
	    groupByField: boolean;
	    /**
	     * Gets whether the field is considered splitGroupBy (facet with ; between values)
	     */
	    splitGroupByField: boolean;
	    /**
	     * Gets whether the field can be used to sort results
	     */
	    sortByField: boolean;
	}

}
declare module Coveo {
	/**
	 * Information about a query extension
	 */
	export interface IExtension {
	    /**
	     * The name of the extension
	     */
	    name: string;
	    /**
	     * An array of all possible arguments
	     */
	    argumentNames: string[];
	}

}
declare module Coveo {
	export interface IEndpointError extends Error {
	    message: string;
	    type: string;
	    name: string;
	}

}
declare module Coveo {
	/**
	 * Describe a tag request on a document
	 */
	export interface ITaggingRequest {
	    /**
	     * The field name to tag
	     */
	    fieldName: string;
	    /**
	     * The value to tag
	     */
	    fieldValue: string;
	    /**
	     * Decide whether to add the tag value, or remove the tag value
	     */
	    doAdd: boolean;
	    /**
	     * The unique id of the document to tag
	     */
	    uniqueId: string;
	}

}
declare module Coveo {
	/**
	 * Describe a suggestion of completion from reveal
	 */
	export interface IRevealQuerySuggestCompletion {
	    /**
	     * The expression to complete
	     */
	    expression: string;
	    /**
	     * The degree of confidence from reveal that the suggestion is relevant
	     */
	    score: number;
	    /**
	     * The highlighted expression to complete
	     */
	    highlighted: string;
	}
	/**
	 * Describe a response from reveal query suggestions
	 */
	export interface IRevealQuerySuggestResponse {
	    /**
	     * An array of completions
	     */
	    completions: IRevealQuerySuggestCompletion[];
	}
	/**
	 * Describe a request to reveal query suggest
	 */
	export interface IRevealQuerySuggestRequest {
	    /**
	     * Query / word for which to get completions
	     */
	    q: string;
	    /**
	     * The search hub for which to get suggestions
	     */
	    searchHub?: string;
	    /**
	     * Number of suggestions that the service should return. Default to 5
	     */
	    count?: number;
	    /**
	     * The pipeline to use for the request.
	     */
	    pipeline?: string;
	    language?: string;
	    autoCompleter?: string;
	    additionalData?: any;
	    format?: string;
	}

}
declare module Coveo {
	/**
	 * Describe a request to rate a document in the index
	 */
	export interface IRatingRequest {
	    /**
	     * The uniqueId of the document to rate
	     */
	    uniqueId: string;
	    /**
	     * String to describe the rating.<br/>
	     * Can be 'Undefined' | 'Lowest' | 'Low' | 'Average' | 'Good' | 'Best'
	     */
	    rating: string;
	}

}
declare module Coveo {
	
	export const SUBSCRIPTION_TYPE: {
	    followQuery: string;
	    followDocument: string;
	};
	export interface ISearchAlertsEndpointOptions {
	    restUri: string;
	    accessToken?: string;
	    errorsAsSuccess?: boolean;
	}
	export interface ISearchAlertsEndpointCallOptions {
	    type?: string;
	    page?: number;
	}
	export interface ISearchAlertsEndpointSearchCallOptions {
	    documentIds: string[];
	}
	/**
	 * Describe a subscription to the Coveo Search alerts service
	 */
	export interface ISubscription extends ISubscriptionRequest {
	    /**
	     * The id of the subscription
	     */
	    id: string;
	    /**
	     * The user associated with the subscription
	     */
	    user: ISubscriptionUser;
	}
	/**
	 * Describe a user associated with a subscription to the Coveo Search alerts service
	 */
	export interface ISubscriptionUser {
	    /**
	     * The email of the user
	     */
	    email: string;
	    /**
	     * The token used to manage the alerts via email.
	     */
	    manageToken: string;
	}
	/**
	 * Describe a request to subscribe to the Coveo Search alerts service
	 */
	export interface ISubscriptionRequest {
	    /**
	     * Type of subscription.<br/>
	     * Can be 'followQuery' or 'followDocument'
	     */
	    type: string;
	    /**
	     * Config of the subscription
	     */
	    typeConfig: ISubscriptionQueryRequest | ISubscriptionItemRequest;
	    /**
	     * Frequency of the alerts
	     */
	    frequency?: string;
	}
	/**
	 * Describe a subscription to a single query
	 */
	export interface ISubscriptionQueryRequest {
	    /**
	     * Query to subscribe to
	     */
	    query: IQuery;
	    /**
	     * Which field on the result set represent the modification date for which you wish to receive alerts
	     */
	    modifiedDateField?: string;
	}
	/**
	 * Describe a subscription to a single item (a result)
	 */
	export interface ISubscriptionItemRequest {
	    /**
	     * Unique id of the document
	     */
	    id: string;
	    /**
	     * Title of the document
	     */
	    title: string;
	    /**
	     * Which field on the result represent the modification date for which you wish to receive alerts
	     */
	    modifiedDateField?: string;
	    /**
	     * A list of field to monitor on the given document
	     */
	    watchedFields?: string[];
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	/**
	 * The possible options when creating a {@link SearchEndpoint}
	 */
	export interface ISearchEndpointOptions extends IEndpointCallerOptions {
	    /**
	     * The uri for the search endpoint. eg: cloudplatform.coveo.com/rest/search
	     */
	    restUri?: string;
	    version?: string;
	    /**
	     * Query string arguments to add to every request to the search endpoint.<br/>
	     * eg : {'foo':'bar', 'a':'b'}
	     */
	    queryStringArguments?: IStringMap<any>;
	    /**
	     * Specifies that the request (and the Coveo Search API) does not need any kind of authentication.<br/>
	     * This flag is only needed for specific setups when your requests are being blocked by your browser. If your queries are executing correctly, you do not need to bother.<br/>
	     * Setting this flag will prevent the withCredentials option to be set on the XMLHttpRequest, allowing performing cross-domain requests on a server that returns * in the Access-Control-Allow-Origin HTTP header.
	     */
	    anonymous?: boolean;
	    /**
	     * This allows using an OAuth2 or a search token to authenticate against the Search API.
	     */
	    accessToken?: string;
	    /**
	     * Specifies a function that, when called, will arrange for a new search token to be generated.<br/>
	     * It is expected to return a Promise that should be resolved with the new token once it's available.
	     */
	    renewAccessToken?: () => Promise<string>;
	    /**
	     * This is the username part of the credentials used to authenticate with the Search API using Basic Authentication.<br/>
	     * This option should only be used for development purposes. Including secret credentials in an HTML page that is sent to a client browser is not secure.
	     */
	    username?: string;
	    /**
	     * This is the password part of the credentials used to authenticate with the REST API.<br/>
	     * This option should only be used for development purposes. Including secret credentials in an HTML page that is sent to a client browser is not secure.
	     */
	    password?: string;
	    /**
	     * The uri for the Coveo search alerts service. If not specified, will automatically resolve using the restUri otherwise
	     */
	    searchAlertsUri?: string;
	    isGuestUser?: boolean;
	}
	/**
	 * Available options when calling against the {@link SearchEndpoint}
	 */
	export interface IEndpointCallOptions {
	    authentication?: string[];
	}
	/**
	 * Available options when calling against the {@link SearchEndpoint} to get a document
	 */
	export interface IGetDocumentOptions extends IEndpointCallOptions {
	}
	/**
	 * Available options when calling against the {@link SearchEndpoint} to view a document as an HTMLElement (quickview basically...)
	 */
	export interface IViewAsHtmlOptions extends IEndpointCallOptions {
	    query?: string;
	    queryObject?: IQuery;
	    requestedOutputSize?: number;
	    contentType?: string;
	}
	export interface ISearchEndpoint {
	    options: ISearchEndpointOptions;
	    getBaseUri(): string;
	    getBaseAlertsUri(): string;
	    getAuthenticationProviderUri(provider: string, returnUri: string, message: string): string;
	    isJsonp(): boolean;
	    search(query: IQuery, callOptions?: IEndpointCallOptions): Promise<IQueryResults>;
	    getExportToExcelLink(query: IQuery, numberOfResults: number, callOptions?: IEndpointCallOptions): string;
	    getRawDataStream(documentUniqueId: string, dataStreamType: string, callOptions?: IViewAsHtmlOptions): Promise<ArrayBuffer>;
	    getDocument(documentUniqueID: string, callOptions?: IGetDocumentOptions): Promise<IQueryResult>;
	    getDocumentText(documentUniqueID: string, callOptions?: IEndpointCallOptions): Promise<string>;
	    getDocumentHtml(documentUniqueID: string, callOptions?: IViewAsHtmlOptions): Promise<HTMLDocument>;
	    getViewAsHtmlUri(documentUniqueID: string, callOptions?: IViewAsHtmlOptions): string;
	    getViewAsDatastreamUri(documentUniqueID: string, dataStreamType: string, callOptions?: IViewAsHtmlOptions): string;
	    listFieldValues(request: IListFieldValuesRequest, callOptions?: IEndpointCallOptions): Promise<IIndexFieldValue[]>;
	    listFields(callOptions?: IEndpointCallOptions): Promise<IFieldDescription[]>;
	    extensions(callOptions?: IEndpointCallOptions): Promise<IExtension[]> | Promise<IEndpointError>;
	    tagDocument(taggingRequest: ITaggingRequest, callOptions?: IEndpointCallOptions): Promise<boolean>;
	    getRevealQuerySuggest(request: IRevealQuerySuggestRequest, callOptions?: IEndpointCallOptions): Promise<IRevealQuerySuggestResponse>;
	    rateDocument(ratingRequest: IRatingRequest, callOptions?: IEndpointCallOptions): Promise<boolean>;
	    follow(request: ISubscriptionRequest): Promise<ISubscription>;
	    listSubscriptions(page?: number): Promise<ISubscription[]>;
	    updateSubscription(subscription: ISubscription): Promise<ISubscription>;
	    deleteSubscription(subscription: ISubscription): Promise<ISubscription>;
	}

}
declare module Coveo {
	export var version: {
	    'lib': string;
	    'product': string;
	    'supportedApiVersion': number;
	};

}
declare module Coveo {
	
	export interface IListFieldsResult {
	    fields: IFieldDescription[];
	}

}
declare module Coveo {
	
	export class AjaxError implements IEndpointError {
	    message: string;
	    status: number;
	    type: any;
	    name: any;
	    constructor(message: string, status: number);
	}

}
declare module Coveo {
	
	export class MissingAuthenticationError implements IEndpointError {
	    provider: string;
	    type: string;
	    message: string;
	    isMissingAuthentication: boolean;
	    name: string;
	    constructor(provider: string);
	}

}
declare module Coveo {
	
	
	export class QueryError implements IEndpointError {
	    status: number;
	    message: string;
	    type: string;
	    queryExecutionReport: any;
	    name: string;
	    constructor(errorResponse: IErrorResponse);
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	export class DefaultSearchEndpointOptions implements ISearchEndpointOptions {
	    restUri: string;
	    version: string;
	    queryStringArguments: IStringMap<string>;
	    anonymous: boolean;
	    accessToken: string;
	    renewAccessToken: () => Promise<string>;
	    username: string;
	    password: string;
	    searchAlertsUri: string;
	    isGuestUser: boolean;
	}
	/**
	 * A search endpoint allows to execute letious actions against the Coveo Search API and index.<br/>
	 * For example, you can search, list field values, get the quickview content for a document, etc.<br/>
	 * Any actions that you execute using this class will not trigger a full query cycle for the Coveo components.<br/>
	 * This is because this class will not trigger any query events directly.<br/>
	 * If you wish to execute a query that all components will react to (and trigger the corresponding query events), use the {@link QueryController}
	 */
	export class SearchEndpoint implements ISearchEndpoint {
	    options: ISearchEndpointOptions;
	    /**
	     * A map of all the initialized endpoint.<br/>
	     * eg : Coveo.SearchEndpoint.endpoints['default'] will return the default endpoint that was created at initialization
	     * @type {{}}
	     */
	    static endpoints: {
	        [endpoint: string]: SearchEndpoint;
	    };
	    /**
	     * Configure an endpoint that will point to a Coveo Cloud index, which contains a set of public sources with no security on them.<br/>
	     * Used for demo purposes and ease of setup.
	     * @param otherOptions A set of additional options to use when configuring this endpoint
	     */
	    static configureSampleEndpoint(otherOptions?: ISearchEndpointOptions): void;
	    /**
	     * Configure an endpoint to a Coveo Cloud index.
	     * @param organization The organization id of your Coveo cloud index
	     * @param token The token to use to execute query. If null, you will most probably need to login when querying.
	     * @param uri The uri of your cloud Search API. By default, will point to the production environment
	     * @param otherOptions A set of additional options to use when configuring this endpoint
	     */
	    static configureCloudEndpoint(organization?: string, token?: string, uri?: string, otherOptions?: ISearchEndpointOptions): void;
	    /**
	     * Configure an endpoint to a Coveo on premise index.
	     * @param uri The uri of your Coveo Search API endpoint. eg : http://myserver:8080/rest/search
	     * @param token The token to use to execute query. If null, you will most probably need to login when querying (unless the search api is configured using advanced auth options, like windows auth or claims)
	     * @param otherOptions A set of additional options to use when configuring this endpoint
	     */
	    static configureOnPremiseEndpoint(uri: string, token?: string, otherOptions?: ISearchEndpointOptions): void;
	    static removeUndefinedConfigOption(config: ISearchEndpointOptions): ISearchEndpointOptions;
	    static mergeConfigOptions(first: ISearchEndpointOptions, second: ISearchEndpointOptions): ISearchEndpointOptions;
	    logger: Logger;
	    isRedirecting: boolean;
	    protected caller: EndpointCaller;
	    private onUnload;
	    /**
	     * Create a new SearchEndpoint.<br/>
	     * Will use a set of sane default options, and merge them with the options parameter.<br/>
	     * Will create an {@link EndpointCaller} and use it to communicate with the endpoint internally
	     * @param options
	     */
	    constructor(options?: ISearchEndpointOptions);
	    reset(): void;
	    /**
	     * Return the base uri of the endpoint to perform search
	     * @returns {string}
	     */
	    getBaseUri(): string;
	    /**
	     * Return the base uri of the endpoint for search alert
	     * @returns {string}
	     */
	    getBaseAlertsUri(): string;
	    /**
	     * Get the uri that can be used to authenticate against the given provider
	     * @param provider The provider name
	     * @param returnUri The uri at which to return after the authentication is completed
	     * @param message The message for authentication
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {string}
	     */
	    getAuthenticationProviderUri(provider: string, returnUri?: string, message?: string, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): string;
	    /**
	     * is the search endpoint using jsonp internally to communicate with Search API
	     * @returns {boolean}
	     */
	    isJsonp(): boolean;
	    /**
	     * Perform a search on the index and returns a Promise of {@link IQueryResults}.<br/>
	     * Will modify the query results slightly, by adding additional information on each results (an id, the state object, etc.)
	     * @param query The query to execute. Typically, the query object is built using a {@link QueryBuilder}
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<IQueryResults>}
	     */
	    search(query: IQuery, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<IQueryResults>;
	    /**
	     * Get a link/uri to download a set of results, for a given query, to an xlsx format.<br/>
	     * Note : This does not download automatically the documents, merely provide an url at which to download them.
	     * @param query The query for which to get the xlsx documents
	     * @param numberOfResults The number of results that should be downloaded
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {string}
	     */
	    getExportToExcelLink(query: IQuery, numberOfResults: number, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): string;
	    /**
	     * Get the raw datastream for a given document. This is typically used to get a thumbnail for a document.<br/>
	     * Return an array buffer : <br/>
	     * eg : let rawBinary = String.fromCharCode.apply(null, new Uint8Array(response));<br/>
	     * img.setAttribute('src', 'data:image/png;base64,' + btoa(rawBinary));
	     * @param documentUniqueId Typically the {@link IQueryResult.uniqueId} on each result
	     * @param dataStreamType Normally : '$Thumbnail'
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<TResult>|Promise<U>}
	     */
	    getRawDataStream(documentUniqueId: string, dataStreamType: string, callOptions?: IViewAsHtmlOptions, callParams?: IEndpointCallParameters): Promise<ArrayBuffer>;
	    /**
	     * Return an url that will allow to see the datastream for a given document. This is typically used to get a thumbnail for a document.<br/>
	     * @param documentUniqueID Typically the {@link IQueryResult.uniqueId} on each result
	     * @param dataStreamType Normally : '$Thumbnail'
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {string}
	     */
	    getViewAsDatastreamUri(documentUniqueID: string, dataStreamType: string, callOptions?: IViewAsHtmlOptions, callParams?: IEndpointCallParameters): string;
	    /**
	     * Return a single document, using it's uniqueId
	     * @param documentUniqueID Typically the {@link IQueryResult.uniqueId} on each result
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<IQueryResult>}
	     */
	    getDocument(documentUniqueID: string, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<IQueryResult>;
	    /**
	     * Return the content for a single document, as text.<br/>
	     * Think : quickview
	     * @param documentUniqueID Typically the {@link IQueryResult.uniqueId} on each result
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<string>}
	     */
	    getDocumentText(documentUniqueID: string, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<string>;
	    /**
	     * Return the content for a single document, as an HTMLDocument.<br/>
	     * Think : quickview
	     * @param documentUniqueID Typically the {@link IQueryResult.uniqueId} on each result
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<HTMLDocument>}
	     */
	    getDocumentHtml(documentUniqueID: string, callOptions?: IViewAsHtmlOptions, callParams?: IEndpointCallParameters): Promise<HTMLDocument>;
	    /**
	     * Return an url that will allow to see a single document content, as HTML.<br/>
	     * Think : quickview
	     * @param documentUniqueID Typically the {@link IQueryResult.uniqueId} on each result
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {string}
	     */
	    getViewAsHtmlUri(documentUniqueID: string, callOptions?: IViewAsHtmlOptions, callParams?: IEndpointCallParameters): string;
	    batchFieldValues(request: IListFieldValuesRequest, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<IIndexFieldValue[]>;
	    /**
	     * List the possible values for a given request
	     * @param request The request for which to list the possible field values
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<TResult>|Promise<U>}
	     */
	    listFieldValues(request: IListFieldValuesRequest, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<IIndexFieldValue[]>;
	    /**
	     * List all fields for the index, and return an array of their description
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<TResult>|Promise<U>}
	     */
	    listFields(callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<IFieldDescription[]>;
	    /**
	     * List all available query extensions for the search endpoint
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<IExtension[]>}
	     */
	    extensions(callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<IExtension[]>;
	    /**
	     * Allow to rate a single document in the index (granted that collaborative rating is enabled on your index)
	     * @param ratingRequest Document id and rating
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<boolean>|Promise<T>}
	     */
	    rateDocument(ratingRequest: IRatingRequest, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<boolean>;
	    /**
	     * Allow to tag a single document
	     * @param taggingRequest Document id and tag action to perform
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<boolean>|Promise<T>}
	     */
	    tagDocument(taggingRequest: ITaggingRequest, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<boolean>;
	    /**
	     * Return a list of reveal query suggestions, based on the given request
	     * @param request query and number of suggestions to return
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<IRevealQuerySuggestResponse>}
	     */
	    getRevealQuerySuggest(request: IRevealQuerySuggestRequest, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<IRevealQuerySuggestResponse>;
	    /**
	     * Allow to follow a document or a query on the search alerts service
	     * @param request
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<ISubscription>}
	     */
	    follow(request: ISubscriptionRequest, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<ISubscription>;
	    private currentListSubscriptions;
	    /**
	     * Return a Promise of array of current subscriptions
	     * @param page The page of the subsctiptions
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {any}
	     */
	    listSubscriptions(page: number, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<{}>;
	    /**
	     * Update a subscription with new parameters
	     * @param subscription The subscription to update with new parameters
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<ISubscription>}
	     */
	    updateSubscription(subscription: ISubscription, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<ISubscription>;
	    /**
	     * Delete a subscription
	     * @param subscription The subscription to delete
	     * @param callOptions Additional set of options to use for this call.
	     * @param callParams Options injected by the applied decorators.
	     * @returns {Promise<ISubscription>}
	     */
	    deleteSubscription(subscription: ISubscription, callOptions?: IEndpointCallOptions, callParams?: IEndpointCallParameters): Promise<ISubscription>;
	    nuke(): void;
	    protected createEndpointCaller(): void;
	    private static isDebugArgumentPresent();
	    private static isUseLocalArgumentPresent();
	    private handleUnload();
	    private buildBaseUri(path);
	    buildSearchAlertsUri(path: string): string;
	    private buildAccessToken(tokenKey);
	    private buildBaseQueryString(callOptions?);
	    private buildCompleteQueryString(query?, queryObject?);
	    private buildViewAsHtmlQueryString(uniqueId, callOptions?);
	    private performOneCall<T>(params, callOptions?, autoRenewToken?);
	    private handleErrorResponse(errorResponse);
	    private canRenewAccessToken();
	    private renewAccessToken();
	    private removeTrailingSlash(uri);
	    private hasTrailingSlash(uri);
	    private isMissingAuthenticationProviderStatus(status);
	    private isAccessTokenExpiredStatus(status);
	}

}
declare module Coveo {
	export class LocalStorageUtils<T> {
	    id: string;
	    constructor(id: string);
	    save(data: T): void;
	    load(): T;
	    remove(key?: string): void;
	    private getLocalStorageKey();
	}

}
declare module Coveo {
	
	export class StringUtils {
	    static javascriptEncode(value: string): string;
	    static htmlEncode(value: string): string;
	    static splice(value: string, index: number, remove: number, toAdd: string): string;
	    static removeMiddle(value: string, length: number, toAdd: string): string;
	    static regexEncode(value: string): string;
	    static stringToRegex(value: string, ignoreAccent?: boolean): string;
	    static wildcardsToRegex(value: string, ignoreAccent?: boolean): string;
	    static getHighlights(strToSearch: string, regexToFind: RegExp, dataHighlightGroupTerm: string): IHighlight[];
	    static encodeCarriageReturn(strToEncode: string): string;
	    static equalsCaseInsensitive(str1: string, str2: string): boolean;
	    static match(value: string, regex: RegExp): string[][];
	    static hashCode(str: string): string;
	    static removePunctuation(str: string): string;
	    static accented: {
	        [letter: string]: RegExp;
	    };
	}

}
declare module Coveo {
	/**
	 * Describe the cause of an event for the analytics service
	 */
	export interface IAnalyticsActionCause {
	    /**
	     * The name of the event. Should be unique for each event.<br/>
	     * Eg : searchBoxSubmit or resultSort
	     */
	    name: string;
	    /**
	     * The type of the event. Allow to regroup similar event type together when doing reporting.<br/>
	     * For example, all search box event will be of type "search box"
	     */
	    type: string;
	    metaMap?: {
	        [name: string]: number;
	    };
	}
	export interface IAnalyticsNoMeta {
	}
	export interface IAnalyticsInterfaceChange {
	    interfaceChangeTo: string;
	}
	export interface IAnalyticsContextAddMeta {
	    contextName: string;
	}
	export interface IAnalyticsContextRemoveMeta {
	    contextName: string;
	}
	export interface IAnalyticsResultsSortMeta {
	    resultsSortBy: string;
	}
	/**
	 * The expected metadata when loggin a click event / document view
	 */
	export interface IAnalyticsDocumentViewMeta {
	    /**
	     * The url of the clicked document
	     */
	    documentURL?: string;
	    /**
	     * The title of the clicked document
	     */
	    documentTitle?: string;
	    /**
	     * The author of the clicked document
	     */
	    author: string;
	}
	export interface IAnalyticsOmniboxFacetMeta {
	    facetId: string;
	    facetTitle: string;
	    facetValue?: string;
	    suggestions: string;
	    suggestionRanking: number;
	    query: string;
	}
	export interface IAnalyticsFacetMeta {
	    facetId: string;
	    facetValue?: string;
	    facetTitle: string;
	}
	export interface IAnalyticsQueryErrorMeta {
	    query: string;
	    aq: string;
	    cq: string;
	    dq: string;
	    errorType: string;
	    errorMessage: string;
	}
	export interface IAnalyticsTopSuggestionMeta {
	    suggestionRanking: number;
	    partialQueries: string;
	    suggestions: string;
	    partialQuery: string;
	}
	export interface IAnalyticsOmniboxSuggestionMeta {
	    suggestionRanking: number;
	    partialQueries: string;
	    suggestions: string;
	    partialQuery: string;
	}
	export interface IAnalyticsFacetSliderChangeMeta {
	    facetId: string;
	    facetRangeStart: any;
	    facetRangeEnd: any;
	}
	export interface IAnalyticsFacetGraphSelectedMeta extends IAnalyticsFacetSliderChangeMeta {
	}
	export interface IAnalyticsFacetOperatorMeta extends IAnalyticsFacetMeta {
	    facetOperatorBefore: string;
	    facetOperatorAfter: string;
	}
	export interface IAnalyticsPreferencesChangeMeta {
	    preferenceName: string;
	    preferenceType: string;
	}
	export interface IAnalyticsCustomFiltersChangeMeta {
	    customFilterName: string;
	    customFilterType: string;
	    customFilterExpression: string;
	}
	export interface IAnalyticsCaseAttachMeta {
	    resultUriHash: string;
	    articleID: string;
	    caseID: string;
	    author: string;
	}
	export interface IAnalyticsCaseContextAddMeta {
	    caseID: string;
	}
	export interface IAnalyticsCaseContextRemoveMeta {
	    caseID: string;
	}
	export interface IAnalyticsCaseDetachMeta extends IAnalyticsCaseAttachMeta {
	}
	export interface IAnalyticsCaseCreationInputChangeMeta {
	    inputTitle: string;
	    input: string;
	    value: string;
	}
	export interface IAnalyticsCaseCreationDeflectionMeta {
	    hasClicks: boolean;
	    values: {
	        [field: string]: string;
	    };
	}
	export interface IAnalyticsPagerMeta {
	    pagerNumber: number;
	}
	export interface IAnalyticsResultsPerPageMeta {
	    currentResultsPerPage: number;
	}
	export interface IAnalyticsTriggerNotify {
	    notification: string;
	}
	export interface IAnalyticsTriggerRedirect {
	    redirectedTo: string;
	}
	export interface IAnalyticsTriggerQuery {
	    query: string;
	}
	export interface IAnalyticsTriggerExecute {
	    executed: string;
	}
	export var analyticsActionCauseList: {
	    interfaceLoad: IAnalyticsActionCause;
	    interfaceChange: IAnalyticsActionCause;
	    contextRemove: IAnalyticsActionCause;
	    didyoumeanAutomatic: IAnalyticsActionCause;
	    didyoumeanClick: IAnalyticsActionCause;
	    resultsSort: IAnalyticsActionCause;
	    searchboxSubmit: IAnalyticsActionCause;
	    searchboxClear: IAnalyticsActionCause;
	    searchboxAsYouType: IAnalyticsActionCause;
	    breadcrumbFacet: IAnalyticsActionCause;
	    breadcrumbResetAll: IAnalyticsActionCause;
	    documentTag: IAnalyticsActionCause;
	    documentField: IAnalyticsActionCause;
	    documentQuickview: IAnalyticsActionCause;
	    documentOpen: IAnalyticsActionCause;
	    omniboxFacetSelect: IAnalyticsActionCause;
	    omniboxFacetExclude: IAnalyticsActionCause;
	    omniboxFacetDeselect: IAnalyticsActionCause;
	    omniboxFacetUnexclude: IAnalyticsActionCause;
	    omniboxAnalytics: IAnalyticsActionCause;
	    omniboxField: IAnalyticsActionCause;
	    facetClearAll: IAnalyticsActionCause;
	    facetSearch: IAnalyticsActionCause;
	    facetToggle: IAnalyticsActionCause;
	    facetRangeSlider: IAnalyticsActionCause;
	    facetRangeGraph: IAnalyticsActionCause;
	    facetSelect: IAnalyticsActionCause;
	    facetSelectAll: IAnalyticsActionCause;
	    facetDeselect: IAnalyticsActionCause;
	    facetExclude: IAnalyticsActionCause;
	    facetUnexclude: IAnalyticsActionCause;
	    errorBack: IAnalyticsActionCause;
	    errorClearQuery: IAnalyticsActionCause;
	    errorRetry: IAnalyticsActionCause;
	    noResultsBack: IAnalyticsActionCause;
	    expandToFullUI: IAnalyticsActionCause;
	    caseCreationInputChange: IAnalyticsActionCause;
	    caseCreationSubmitButton: IAnalyticsActionCause;
	    caseCreationCancelButton: IAnalyticsActionCause;
	    caseCreationUnloadPage: IAnalyticsActionCause;
	    casecontextAdd: IAnalyticsActionCause;
	    casecontextRemove: IAnalyticsActionCause;
	    preferencesChange: IAnalyticsActionCause;
	    getUserHistory: IAnalyticsActionCause;
	    userActionDocumentClick: IAnalyticsActionCause;
	    caseAttach: IAnalyticsActionCause;
	    caseDetach: IAnalyticsActionCause;
	    customfiltersChange: IAnalyticsActionCause;
	    pagerNumber: IAnalyticsActionCause;
	    pagerNext: IAnalyticsActionCause;
	    pagerPrevious: IAnalyticsActionCause;
	    pagerScrolling: IAnalyticsActionCause;
	    pagerResize: IAnalyticsActionCause;
	    searchFromLink: IAnalyticsActionCause;
	    triggerNotify: IAnalyticsActionCause;
	    triggerExecute: IAnalyticsActionCause;
	    triggerQuery: IAnalyticsActionCause;
	    triggerRedirect: IAnalyticsActionCause;
	    queryError: IAnalyticsActionCause;
	    exportToExcel: IAnalyticsActionCause;
	    recommendation: IAnalyticsActionCause;
	    recommendationInterfaceLoad: IAnalyticsActionCause;
	    recommendationOpen: IAnalyticsActionCause;
	};

}
declare module Coveo {
	
	/**
	 * Describe a request to get top queries
	 */
	export interface ITopQueries extends IStringMap<any> {
	    /**
	     * Determine how many suggestions to receive
	     */
	    pageSize: number;
	    /**
	     * The query text for which to receive suggestions
	     */
	    queryText: string;
	}

}
declare module Coveo {
	export interface IAnalyticsEvent {
	    actionCause: string;
	    actionType: string;
	    username?: string;
	    userDisplayName?: string;
	    anonymous?: boolean;
	    device: string;
	    mobile: boolean;
	    originLevel1: string;
	    originLevel2: string;
	    originLevel3?: string;
	    language: string;
	    responseTime: number;
	    userAgent?: string;
	    userGroups?: string;
	    customData?: {
	        [key: string]: any;
	    };
	}

}
declare module Coveo {
	
	export interface ISearchEvent extends IAnalyticsEvent {
	    searchQueryUid: string;
	    queryPipeline: string;
	    splitTestRunName: string;
	    splitTestRunVersion: string;
	    mobile: boolean;
	    queryText: string;
	    numberOfResults: number;
	    responseTime: number;
	    resultsPerPage: number;
	    pageNumber: number;
	    advancedQuery: string;
	    didYouMean: boolean;
	    contextual: boolean;
	}

}
declare module Coveo {
	export interface IAPIAnalyticsVisitResponseRest {
	    id: string;
	}

}
declare module Coveo {
	export interface IAPIAnalyticsEventResponse {
	    visitId: string;
	    visitorId: string;
	}

}
declare module Coveo {
	
	export interface IAPIAnalyticsSearchEventsResponse {
	    searchEventResponses: IAPIAnalyticsEventResponse[];
	}

}
declare module Coveo {
	
	export interface IClickEvent extends IAnalyticsEvent {
	    searchQueryUid: string;
	    queryPipeline: string;
	    splitTestRunName: string;
	    splitTestRunVersion: string;
	    documentUri: string;
	    documentUriHash: string;
	    documentUrl: string;
	    documentTitle: string;
	    documentCategory: string;
	    collectionName: string;
	    sourceName: string;
	    documentPosition: number;
	    viewMethod: string;
	    rankingModifier: string;
	}

}
declare module Coveo {
	
	export interface ICustomEvent extends IAnalyticsEvent {
	    eventType: string;
	    eventValue: string;
	}

}
declare module Coveo {
	export class Cookie {
	    private static prefix;
	    static set(name: string, value: string, expiration?: number): void;
	    static get(name: string): string;
	    static erase(name: string): void;
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	
	export interface IAnalyticsEndpointOptions {
	    token: string;
	    serviceUrl: string;
	    organization: string;
	}
	export class AnalyticsEndpoint {
	    options: IAnalyticsEndpointOptions;
	    logger: Logger;
	    static DEFAULT_ANALYTICS_URI: string;
	    static DEFAULT_ANALYTICS_VERSION: string;
	    static CUSTOM_ANALYTICS_VERSION: any;
	    static VISITOR_COOKIE_TIME: number;
	    static pendingRequest: Promise<any>;
	    private visitId;
	    private organization;
	    endpointCaller: EndpointCaller;
	    constructor(options: IAnalyticsEndpointOptions);
	    getCurrentVisitId(): string;
	    getCurrentVisitIdPromise(): Promise<string>;
	    sendSearchEvents(searchEvents: ISearchEvent[]): Promise<IAPIAnalyticsSearchEventsResponse>;
	    sendDocumentViewEvent(documentViewEvent: IClickEvent): Promise<IAPIAnalyticsEventResponse>;
	    sendCustomEvent(customEvent: ICustomEvent): Promise<{}>;
	    getTopQueries(params: ITopQueries): Promise<string[]>;
	    private sendToService<D, R>(data, path, paramName);
	    private getFromService<T>(url, params);
	    private handleAnalyticsEventResponse(response);
	    private buildAnalyticsUrl(path);
	}

}
declare module Coveo {
	export class Defer {
	    private static functions;
	    static defer(code: () => void): void;
	    static flush(): void;
	    private static arm();
	    private static popOne();
	}

}
declare module Coveo {
	export interface IAPISearchEvent {
	    language: string;
	    device: string;
	    searchInterface: string;
	    searchHub: string;
	    responseTime: number;
	    customMetadatas: {
	        [name: string]: string;
	    };
	    queryText: string;
	    advancedQuery: string;
	    didYouMean: boolean;
	    numberOfResults: number;
	    resultsPerPage: number;
	    pageNumber: number;
	    type: string;
	    actionCause: string;
	    queryPipeline: string;
	    splitTestRunName: string;
	    splitTestRunVersion: string;
	    searchQueryUid: string;
	}

}
declare module Coveo {
	export interface IAPIDocumentViewEvent {
	    language: string;
	    device: string;
	    searchInterface: string;
	    searchHub: string;
	    responseTime: number;
	    searchQueryUid: string;
	    title: string;
	    documentUrl: string;
	    documentUri: string;
	    documentUriHash: string;
	    viewMethod: string;
	    actionCause: string;
	    queryPipeline: string;
	    splitTestRunName: string;
	    splitTestRunVersion: string;
	    collectionName: string;
	    sourceName: string;
	    documentPosition: number;
	    customMetadatas: {
	        [name: string]: string;
	    };
	}

}
declare module Coveo {
	export interface IAPICustomEvent {
	    language: string;
	    device: string;
	    searchInterface: string;
	    searchHub: string;
	    responseTime: number;
	    actionType: string;
	    actionCause: string;
	    customMetadatas: {
	        [name: string]: string;
	    };
	}

}
declare module Coveo {
	
	
	
	
	
	
	export class APIAnalyticsBuilder {
	    static convertSearchEventToAPI(searchEvent: ISearchEvent): IAPISearchEvent;
	    static convertDocumentViewToAPI(documentView: IClickEvent): IAPIDocumentViewEvent;
	    static convertCustomEventToAPI(customEvent: ICustomEvent): IAPICustomEvent;
	}

}
declare module Coveo {
	
	
	
	export interface IAnalyticsSearchEventsArgs {
	    searchEvents: IAPISearchEvent[];
	}
	export interface IAnalyticsDocumentViewEventArgs {
	    documentViewEvent: IAPIDocumentViewEvent;
	}
	export interface IAnalyticsCustomEventArgs {
	    customEvent: IAPICustomEvent;
	}
	export interface IChangeAnalyticsCustomDataEventArgs extends IChangeableAnalyticsDataObject {
	    type: string;
	    metaObject: IChangeableAnalyticsMetaObject;
	    actionType: string;
	    actionCause: string;
	}
	export interface IChangeableAnalyticsMetaObject {
	    [name: string]: string;
	}
	export interface IChangeableAnalyticsDataObject {
	    originLevel1: string;
	    originLevel2: string;
	    originLevel3: string;
	    language: string;
	}
	export class AnalyticsEvents {
	    static searchEvent: string;
	    static documentViewEvent: string;
	    static customEvent: string;
	    static changeAnalyticsCustomData: string;
	}

}
declare module Coveo {
	
	
	
	export class PendingSearchEvent {
	    root: HTMLElement;
	    endpoint: AnalyticsEndpoint;
	    templateSearchEvent: ISearchEvent;
	    sendToCloud: boolean;
	    private handler;
	    private searchPromises;
	    private results;
	    protected cancelled: boolean;
	    protected finished: boolean;
	    protected searchEvents: ISearchEvent[];
	    constructor(root: HTMLElement, endpoint: AnalyticsEndpoint, templateSearchEvent: ISearchEvent, sendToCloud: boolean);
	    getEventCause(): string;
	    getEventMeta(): {
	        [key: string]: any;
	    };
	    cancel(): void;
	    protected handleDuringQuery(evt: Event, args: IDuringQueryEventArgs): void;
	    stopRecording(): void;
	    private flush();
	    private fillSearchEvent(searchEvent, searchInterface, query, queryResults);
	}

}
declare module Coveo {
	
	
	
	
	/**
	 * Describe an analytics client, that can log events or return information from the service
	 */
	export interface IAnalyticsClient {
	    isContextual: boolean;
	    /**
	     * Return false if there is no {@link Analytics} component in your page.
	     */
	    isActivated(): boolean;
	    getCurrentEventCause(): string;
	    getCurrentEventMeta(): {
	        [key: string]: any;
	    };
	    /**
	     * Log a search event on the service, using a cause and a meta object.<br/>
	     * Note that the event will be sent on the service when a query successfully return, not immediately after calling this method.<br/>
	     * Normally, this should be called using the following "format" : <br/>
	     * this.usageAnalytics.logSearchEvent<SomeMeta>({name : 'foo', type : 'bar'}, <SomeMeta>{'key':'value'});<br/>
	     * this.queryController.executeQuery();<br/>
	     * This will queue up an analytics search event. Then the query is executed. The search event will be sent to the service when the query successfully complete.<br/>
	     * @param actionCause
	     * @param meta Can be an empty object ( {} )
	     */
	    logSearchEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta): void;
	    /**
	     * Log a search as you type event on the service, using a cause and a meta object.<br/>
	     * This is extremely similar to a search event, except that search as you type, by definition, will be frequently called.<br/>
	     * The {@link PendingSearchAsYouTypeEvent} will take care of logging only the "relevant" last event : After 5 seconds of no event logged, or after another search event is triggered somewhere else in the interface.<br/>
	     * This is to ensure that we do not needlessly log every single partial query, which would make the reporting very confusing.
	     * @param actionCause
	     * @param meta Can be an empty object ( {} )
	     */
	    logSearchAsYouType<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta): void;
	    /**
	     * Log a click event. A click event can be understood as a document view.<br/>
	     * eg : Clicking on a result link of opening a quickview.<br/>
	     * This event will be logged immediately on the service.
	     * @param actionCause
	     * @param meta Can be an empty object ( {} )
	     * @param result The result that was clicked
	     * @param element The HTMLElement that was clicked in the interface
	     */
	    logClickEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta, result: IQueryResult, element: HTMLElement): void;
	    /**
	     * Log a custom event on the service. A custom event can be used to create customized report, or to track events which are not queries or document view.
	     * @param actionCause
	     * @param meta
	     * @param element The HTMLElement that was interacted with for this custom event.
	     */
	    logCustomEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta, element: HTMLElement): void;
	    /**
	     * Get suggested queries from the Coveo analytics service.
	     * @param params
	     */
	    getTopQueries(params: ITopQueries): Promise<string[]>;
	    getCurrentVisitId(): string;
	    /**
	     * Get the current visitor id, for tracking purpose in the Coveo Analytics service
	     */
	    getCurrentVisitIdPromise(): Promise<string>;
	    cancelAllPendingEvents(): void;
	    getPendingSearchEvent(): PendingSearchEvent;
	    sendAllPendingEvents(): void;
	    warnAboutSearchEvent(): void;
	}

}
declare module Coveo {
	
	
	
	
	
	
	/**
	 * The bindings, or environment in which each component exists.
	 */
	export interface IComponentBindings {
	    /**
	     * The root HTMLElement of the {@link SearchInterface} in which the component exists.
	     */
	    root?: HTMLElement;
	    /**
	     * Contains the state of the query. Allows to get/set values. Trigger state event when modified. Each component can listen to those events.
	     */
	    queryStateModel?: QueryStateModel;
	    /**
	     * Contains the state of different component (enabled vs disabled). Allows to get/set values. Trigger component state event when modified. Each component can listen to those events.
	     */
	    componentStateModel?: ComponentStateModel;
	    /**
	     * Contains the singleton that allows to trigger queries.
	     */
	    queryController?: QueryController;
	    /**
	     * A reference to the root of every component, the {@link SearchInterface}
	     */
	    searchInterface?: SearchInterface;
	    /**
	     * A reference to the {@link Analytics.client}.
	     */
	    usageAnalytics?: IAnalyticsClient;
	    /**
	     * Contains the state of options for differents component. Mainly used by {@link ResultLink}
	     */
	    componentOptionsModel?: ComponentOptionsModel;
	}

}
declare module Coveo {
	export interface IBeforeInitializationEventArgs {
	}
	export interface IAfterInitializationEventArgs {
	}
	export class InitializationEvents {
	    static beforeInitialization: string;
	    static afterComponentsInitialization: string;
	    static restoreHistoryState: string;
	    static afterInitialization: string;
	    static nuke: string;
	}

}
declare module Coveo {
	export class HashUtils {
	    private static DELIMITER;
	    static getHash(w?: Window): string;
	    static getValue(value: string, toParse: string): any;
	    static encodeValues(values: {}): string;
	    private static getAjaxcrawlableHash(hash);
	    private static getRawValue(value, toParse);
	    private static getValueDependingOnType(paramValue);
	    private static getValueType(paramValue);
	    private static isArrayStartNotEncoded(value);
	    private static isArrayStartEncoded(value);
	    private static isArrayEndNotEncoded(value);
	    private static isArrayEndEncoded(value);
	    private static isObjectStartNotEncoded(value);
	    private static isObjectStartEncoded(value);
	    private static isObjectEndNotEncoded(value);
	    private static isObjectEndEncoded(value);
	    private static isObject(value);
	    private static isArray(value);
	    static encodeArray(array: string[]): string;
	    static encodeObject(obj: Object): string;
	    private static encodeValue(val);
	    private static decodeObject(obj);
	    private static decodeArray(value);
	}

}
declare module Coveo {
	
	
	
	/**
	 * Represent the initialization parameters required to init a new component
	 */
	export interface IInitializationParameters {
	    options: any;
	    result?: IQueryResult;
	    bindings: IComponentBindings;
	}
	/**
	 * The main purpose of this class is to initialize the framework (a.k.a the code executed when calling Coveo.init).<br/>
	 * It's also in charge or registering the available components, as well as the method that we expost to the global Coveo scope.<br/>
	 * For example, the Coveo.executeQuery function will be registed in this class by the {@link QueryController}.
	 */
	export class Initialization {
	    private static logger;
	    private static autoCreateComponents;
	    private static namedMethods;
	    /**
	     * Register a new set of options for a given element.<br/>
	     * When the element is eventually initialized as a component, those options will be used / merged to create the final option set to use for this component.<br/>
	     * Note that this function should not normally be called directly, but instead using the global Coveo.options function
	     * @param element
	     * @param options
	     */
	    static registerDefaultOptions(element: HTMLElement, options: {}): void;
	    static resolveDefaultOptions(element: HTMLElement, options: {}): {};
	    /**
	     * Register a new Component to be recognized by the framework.<br/>
	     * This essentially mean that when we call Coveo.init, the Initialization class will scan the DOM for known component (which have registed themselves with this call) and create a new component on each element.
	     * @param componentClass
	     */
	    static registerAutoCreateComponent(componentClass: IComponentDefinition): void;
	    /**
	     * Check if a component is already registed, using it's ID (eg : 'Facet')
	     * @param componentClassId
	     * @returns {boolean}
	     */
	    static isComponentClassIdRegistered(componentClassId: string): boolean;
	    /**
	     * Return the list of all known components (the list of ID for each component)
	     * @returns {string[]}
	     */
	    static getListOfRegisteredComponents(): string[];
	    /**
	     * Return the component class definition, using it's ID (eg : 'CoveoFacet')
	     * @param name
	     * @returns {IComponentDefinition}
	     */
	    static getRegisteredComponent(name: string): any;
	    /**
	     * Initialize the framework. Note that this function should not normally be called directly, but instead using a globally registered function (eg: Coveo.init), or {@link Initialization.initSearchInterface} or {@link Initialization.initStandaloneSearchInterface} <br/>
	     * Eg : Coveo.init or Coveo.initSearchbox
	     * @param element The element on which to initialize the interface
	     * @param options The options for all component (eg: {Searchbox : {enableSearchAsYouType : true}})
	     * @param initSearchInterfaceFunction The function to execute to create the {@link SearchInterface} component. Different init call will create different {@link SearchInterface}.
	     */
	    static initializeFramework(element: HTMLElement, options?: any, initSearchInterfaceFunction?: (...args: any[]) => void): void;
	    /**
	     * Create a new standard search interface. This is the function executed when calling Coveo.init
	     * @param element
	     * @param options
	     */
	    static initSearchInterface(element: HTMLElement, options?: any): void;
	    /**
	     * Create a new standalone search interface ( standalone search box ). This is the function executed when calling Coveo.initSearchbox
	     * @param element
	     * @param options
	     */
	    static initStandaloneSearchInterface(element: HTMLElement, options?: any): void;
	    /**
	     * Create a new recommendation search interface. This is the function executed when calling Coveo.initRecommendation
	     * @param element
	     * @param options
	     */
	    static initRecommendationInterface(element: HTMLElement, options?: any): void;
	    /**
	     * Scan the element and all it's children for known component. Initialize every known component found
	     * @param element The element for which to scan it's children
	     * @param initParameters Needed parameters to initialize all the children components
	     * @param ignore An optional list of component ID to ignore and skip when scanning for known components
	     */
	    static automaticallyCreateComponentsInside(element: HTMLElement, initParameters: IInitializationParameters, ignore?: string[]): void;
	    /**
	     * Create a new component on the given element
	     * @param componentClassId The ID of the component to initialize (eg : 'CoveoFacet')
	     * @param element The HTMLElement on which to initialize
	     * @param initParameters Needed parameters to initialize the component
	     * @returns {Component}
	     */
	    static createComponentOfThisClassOnElement(componentClassId: string, element: HTMLElement, initParameters?: IInitializationParameters): Component;
	    /**
	     * Register a new globally available method in the Coveo namespace. (eg: Coveo.init)
	     * @param methodName The method name to register
	     * @param handler The function to execute when the method is called
	     */
	    static registerNamedMethod(methodName: string, handler: (element: HTMLElement, ...args: any[]) => any): void;
	    /**
	     * Check if the method is already registed
	     * @param methodName
	     * @returns {boolean}
	     */
	    static isNamedMethodRegistered(methodName: string): boolean;
	    /**
	     * 'Monkey patch' (replace the function with a new one) a given method on a component instance
	     * @param methodName
	     * @param element
	     * @param handler
	     */
	    static monkeyPatchComponentMethod(methodName: string, element: HTMLElement, handler: (...args: any[]) => any): void;
	    static initBoxInterface(element: HTMLElement, options?: any, type?: string, injectMarkup?: boolean): void;
	    static dispatchNamedMethodCall(methodName: string, element: HTMLElement, args: any[]): any;
	    static dispatchNamedMethodCallOrComponentCreation(token: string, element: HTMLElement, args: any[]): any;
	    private static isThereASingleComponentBoundToThisElement(element);
	    private static dispatchMethodCallOnBoundComponent(methodName, element, args);
	    private static logFirstQueryCause(searchInterface);
	    private static performInitFunctionsOption(options, event);
	    private static performFunctions(option);
	    private static initExternalComponents(element, options?);
	    private static createFunctionThatInitializesComponentOnElements(elements, componentClassId, componentClass, initParameters);
	}

}
declare module Coveo {
	export class Template {
	    dataToString: (object?: any) => string;
	    condition: Function;
	    static getFieldFromString(text: string): string[];
	    private logger;
	    constructor(dataToString?: (object?: any) => string, condition?: Function);
	    instantiateToString(object?: any, checkCondition?: boolean): string;
	    instantiateToElement(object?: any, checkCondition?: boolean): HTMLElement;
	    toHtmlElement(): HTMLElement;
	    getFields(): string[];
	    getType(): string;
	}

}
declare module Coveo {
	/**
	 * A function that describe a templates.
	 *
	 * It can take any number of arguments, but needs to return a simple string.
	 */
	export interface ITemplateHelperFunction {
	    (...args: any[]): string;
	}
	/**
	 * Allow to register and return template helpers (essentially : Utility functions that can be executed in the context of a template to render complex elements)
	 */
	export class TemplateHelpers {
	    private static helpers;
	    static fieldHelpers: string[];
	    static registerFieldHelper<T1>(name: string, helper: (value: string, options?: any) => string): void;
	    static registerTemplateHelper<T1>(name: string, helper: (arg1: T1) => string): any;
	    static registerTemplateHelper<T1, T2>(name: string, helper: (arg1: T1, arg2: T2) => string): any;
	    static registerTemplateHelper<T1, T2, T3>(name: string, helper: (arg1: T1, arg2: T2, arg3: T3) => string): any;
	    static registerTemplateHelper<T1, T2, T3, T4>(name: string, helper: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => string): any;
	    static registerTemplateHelper<T1, T2, T3, T4, T5>(name: string, helper: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => string): any;
	    /**
	     * Return a template helper function
	     * @param name
	     * @returns {any}
	     */
	    static getHelper(name: string): ITemplateHelperFunction;
	    /**
	     * Get all available helpers
	     * @returns {{}}
	     */
	    static getHelpers(): {
	        [templateName: string]: ITemplateHelperFunction;
	    };
	    private static registerTemplateHelperInUnderscore(name, helper);
	}

}
declare module Coveo {
	
	
	export class UnderscoreTemplate extends Template {
	    element: HTMLElement;
	    private template;
	    static templateHelpers: {
	        [templateName: string]: ITemplateHelperFunction;
	    };
	    private fields;
	    static mimeTypes: string[];
	    constructor(element: HTMLElement);
	    toHtmlElement(): HTMLElement;
	    getType(): string;
	    static create(element: HTMLElement): UnderscoreTemplate;
	    static fromString(template: string, condition?: string): UnderscoreTemplate;
	    getFields(): string[];
	    static registerTemplateHelper(helperName: string, helper: ITemplateHelperFunction): void;
	    static isLibraryAvailable(): boolean;
	}

}
declare module Coveo {
	
	export class HtmlTemplate extends Template {
	    element: HTMLElement;
	    static mimeTypes: string[];
	    private fields;
	    constructor(element: HTMLElement);
	    toHtmlElement(): HTMLElement;
	    getType(): string;
	    getFields(): string[];
	    static create(element: HTMLElement): HtmlTemplate;
	    static fromString(template: string, condition?: string): HtmlTemplate;
	}

}
declare module Coveo {
	
	/**
	 * Holds a reference to all template available in the framework
	 */
	export class TemplateCache {
	    private static templates;
	    private static templateNames;
	    private static defaultTemplates;
	    static registerTemplate(name: string, template: Template, publicTemplate?: boolean, defaultTemplate?: boolean): any;
	    static registerTemplate(name: string, template: (data: {}) => string, publicTemplate?: boolean, defaultTemplate?: boolean): any;
	    /**
	     * Return a template by it's name/id.
	     * @param name
	     * @returns {Template}
	     */
	    static getTemplate(name: string): Template;
	    /**
	     * Get all templates currently registered in the framework.
	     * @returns {{}}
	     */
	    static getTemplates(): {
	        [templateName: string]: Template;
	    };
	    /**
	     * Get all templates name currently registered in the framework.
	     * @returns {string[]}
	     */
	    static getTemplateNames(): string[];
	    /**
	     * Get all the "default" templates in the framework.
	     * @returns {string[]}
	     */
	    static getDefaultTemplates(): string[];
	    static getDefaultTemplate(name: string): Template;
	    static scanAndRegisterTemplates(): void;
	    private static scanAndRegisterUnderscoreTemplates();
	    private static scanAndRegisterHtmlTemplates();
	}

}
declare module Coveo {
	
	
	export class DefaultResultTemplate extends Template {
	    constructor();
	    instantiateToString(queryResult?: IQueryResult): string;
	    instantiateToElement(queryResult?: IQueryResult): HTMLElement;
	    getFields(): any[];
	    getType(): string;
	}

}
declare module Coveo {
	
	export class TemplateList extends Template {
	    private templates;
	    constructor(templates: Template[]);
	    instantiateToString(object?: any, checkCondition?: boolean): string;
	    instantiateToElement(object?: any, checkCondition?: boolean): HTMLElement;
	    getFields(): string[];
	    getType(): string;
	}

}
declare module Coveo {
	export var L10N: {
	    format: (key: string, ...args: any[]) => string;
	    formatPlSn: (value: string, count: number | boolean) => string;
	};

}
declare module Coveo {
	export function l(str: "Unknown"): any;
	export function l(str: "And"): any;
	export function l(str: "Authenticating", param0: string): any;
	export function l(str: "Clear", param0: string): any;
	export function l(str: "CompleteQuery"): any;
	export function l(str: "Exclude", param0: string): any;
	export function l(str: "EnterTag"): any;
	export function l(str: "Next"): any;
	export function l(str: "Last"): any;
	export function l(str: "Link"): any;
	export function l(str: "Or"): any;
	export function l(str: "Previous"): any;
	export function l(str: "QueryDidntMatchAnyDocuments"): any;
	export function l(str: "QueryException", param0: string): any;
	export function l(str: "Me"): any;
	export function l(str: "Remove"): any;
	export function l(str: "Search"): any;
	export function l(str: "SearchFor", param0: string): any;
	export function l(str: "ShareQuery"): any;
	export function l(str: "Preferences"): any;
	export function l(str: "LinkOpeningSettings"): any;
	export function l(str: "Reauthenticate", param0: string): any;
	export function l(str: "ResultsFilteringExpression"): any;
	export function l(str: "FiltersInYourPreferences"): any;
	export function l(str: "Create"): any;
	export function l(str: "SearchIn", param0: string): any;
	export function l(str: "Seconds", param0: string, count: number): any;
	export function l(str: "ShowingResultsOf", param0: string, param1: string, param2: string, count: number): any;
	export function l(str: "SwitchTo", param0: string): any;
	export function l(str: "Unexclude", param0: string): any;
	export function l(str: "ClearAllFilters"): any;
	export function l(str: "SkipLogin"): any;
	export function l(str: "LoginInProgress"): any;
	export function l(str: "Login"): any;
	export function l(str: "GetStarted"): any;
	export function l(str: "More"): any;
	export function l(str: "NMore", param0: string): any;
	export function l(str: "Less"): any;
	export function l(str: "Settings"): any;
	export function l(str: "Score"): any;
	export function l(str: "ScoreDescription"): any;
	export function l(str: "Occurrences"): any;
	export function l(str: "OccurrencesDescription"): any;
	export function l(str: "Label"): any;
	export function l(str: "Of"): any;
	export function l(str: "LabelDescription"): any;
	export function l(str: "Value"): any;
	export function l(str: "ValueDescription"): any;
	export function l(str: "AlphaAscending"): any;
	export function l(str: "AlphaDescending"): any;
	export function l(str: "ChiSquare"): any;
	export function l(str: "Nosort"): any;
	export function l(str: "RelativeFrequency"): any;
	export function l(str: "RelativeFrequencyDescription"): any;
	export function l(str: "DateDistribution"): any;
	export function l(str: "Custom"): any;
	export function l(str: "CustomDescription"): any;
	export function l(str: "ComputedField"): any;
	export function l(str: "Ascending"): any;
	export function l(str: "Descending"): any;
	export function l(str: "noResultFor", param0: string): any;
	export function l(str: "autoCorrectedQueryTo", param0: string): any;
	export function l(str: "didYouMean", param0: string): any;
	export function l(str: "SuggestedResults"): any;
	export function l(str: "SuggestedQueries"): any;
	export function l(str: "MostRelevantItems"): any;
	export function l(str: "AllItems"): any;
	export function l(str: "ShowLess"): any;
	export function l(str: "ShowMore"): any;
	export function l(str: "HideFacet"): any;
	export function l(str: "ShowFacet"): any;
	export function l(str: "AndOthers", param0: string, count: number): any;
	export function l(str: "Others", param0: string, count: number): any;
	export function l(str: "MostRelevantPosts"): any;
	export function l(str: "CompleteThread"): any;
	export function l(str: "ShowCompleteThread"): any;
	export function l(str: "ShowOnlyTopMatchingPosts"): any;
	export function l(str: "MostRelevantReplies"): any;
	export function l(str: "AllConversation"): any;
	export function l(str: "ShowAllConversation"): any;
	export function l(str: "ShowAllReplies"): any;
	export function l(str: "ShowOnlyMostRelevantReplies"): any;
	export function l(str: "Close"): any;
	export function l(str: "Open"): any;
	export function l(str: "OpenInOutlookWhenPossible"): any;
	export function l(str: "AlwaysOpenInNewWindow"): any;
	export function l(str: "Quickview"): any;
	export function l(str: "NoQuickview"): any;
	export function l(str: "ErrorReport"): any;
	export function l(str: "OopsError"): any;
	export function l(str: "ProblemPersists"): any;
	export function l(str: "GoBack"): any;
	export function l(str: "Reset"): any;
	export function l(str: "Retry"): any;
	export function l(str: "MoreInfo"): any;
	export function l(str: "Username"): any;
	export function l(str: "Password"): any;
	export function l(str: "PostedBy"): any;
	export function l(str: "CannotConnect"): any;
	export function l(str: "BadUserPass"): any;
	export function l(str: "PleaseEnterYourCredentials", param0: string): any;
	export function l(str: "PleaseEnterYourSearchPage"): any;
	export function l(str: "Collapse"): any;
	export function l(str: "Collapsable"): any;
	export function l(str: "Expand"): any;
	export function l(str: "Today"): any;
	export function l(str: "Yesterday"): any;
	export function l(str: "Tomorrow"): any;
	export function l(str: "Duration", param0: string): any;
	export function l(str: "IndexDuration", param0: string): any;
	export function l(str: "ProxyDuration", param0: string): any;
	export function l(str: "ClientDuration", param0: string): any;
	export function l(str: "Unavailable"): any;
	export function l(str: "Reply"): any;
	export function l(str: "ReplyAll"): any;
	export function l(str: "Forward"): any;
	export function l(str: "From"): any;
	export function l(str: "Caption"): any;
	export function l(str: "Expression"): any;
	export function l(str: "Tab"): any;
	export function l(str: "Tabs"): any;
	export function l(str: "EnterExpressionName"): any;
	export function l(str: "EnterExpressionToFilterWith"): any;
	export function l(str: "SelectTab"): any;
	export function l(str: "SelectAll"): any;
	export function l(str: "PageUrl"): any;
	export function l(str: "ErrorSavingToDevice"): any;
	export function l(str: "ErrorReadingFromDevice"): any;
	export function l(str: "AppIntro"): any;
	export function l(str: "TryDemo"): any;
	export function l(str: "ContactUs"): any;
	export function l(str: "NewToCoveo"): any;
	export function l(str: "LetUsHelpGetStarted"): any;
	export function l(str: "LikesThis", param0: string, count: number): any;
	export function l(str: "CannotConnectSearchPage"): any;
	export function l(str: "AreYouSureDeleteFilter", param0: string, param1: string): any;
	export function l(str: "OnlineHelp"): any;
	export function l(str: "Done"): any;
	export function l(str: "SaveFacetState"): any;
	export function l(str: "ClearFacetState"): any;
	export function l(str: "DisplayingTheOnlyMessage"): any;
	export function l(str: "NoNetworkConnection"): any;
	export function l(str: "UnknownConnection"): any;
	export function l(str: "EthernetConnection"): any;
	export function l(str: "WiFi"): any;
	export function l(str: "CELL"): any;
	export function l(str: "CELL_2G"): any;
	export function l(str: "CELL_3G"): any;
	export function l(str: "CELL_4G"): any;
	export function l(str: "Relevance"): any;
	export function l(str: "Date"): any;
	export function l(str: "Amount"): any;
	export function l(str: "QueryExceptionNoException"): any;
	export function l(str: "QueryExceptionInvalidSyntax"): any;
	export function l(str: "QueryExceptionInvalidCustomField"): any;
	export function l(str: "QueryExceptionInvalidDate"): any;
	export function l(str: "QueryExceptionInvalidExactPhrase"): any;
	export function l(str: "QueryExceptionInvalidDateOp"): any;
	export function l(str: "QueryExceptionInvalidNear"): any;
	export function l(str: "QueryExceptionInvalidWeightedNear"): any;
	export function l(str: "QueryExceptionInvalidTerm"): any;
	export function l(str: "QueryExceptionTooManyTerms"): any;
	export function l(str: "QueryExceptionWildcardTooGeneral"): any;
	export function l(str: "QueryExceptionInvalidSortField"): any;
	export function l(str: "QueryExceptionInvalidSmallStringOp"): any;
	export function l(str: "QueryExceptionRequestedResultsMax"): any;
	export function l(str: "QueryExceptionAggregatedMirrorDead"): any;
	export function l(str: "QueryExceptionAggregatedMirrorQueryTimeOut"): any;
	export function l(str: "QueryExceptionAggregatedMirrorInvalidBuildNumber"): any;
	export function l(str: "QueryExceptionAggregatedMirrorCannotConnect"): any;
	export function l(str: "QueryExceptionNotEnoughLeadingCharsWildcard"): any;
	export function l(str: "QueryExceptionSecurityInverterNotFound"): any;
	export function l(str: "QueryExceptionSecurityInverterAccessDenied"): any;
	export function l(str: "QueryExceptionAggregatedMirrorCannotImpersonate"): any;
	export function l(str: "QueryExceptionUnexpected"): any;
	export function l(str: "QueryExceptionAccessDenied"): any;
	export function l(str: "QueryExceptionSuperUserTokenInvalid"): any;
	export function l(str: "QueryExceptionSuperUserTokenExpired"): any;
	export function l(str: "QueryExceptionLicenseQueriesExpired"): any;
	export function l(str: "QueryExceptionLicenseSuperUserTokenNotSupported"): any;
	export function l(str: "QueryExceptionInvalidSession"): any;
	export function l(str: "QueryExceptionInvalidDocument"): any;
	export function l(str: "QueryExceptionSearchDisabled"): any;
	export function l(str: "FileType"): any;
	export function l(str: "ShowAttachment"): any;
	export function l(str: "OnFeed", param0: string): any;
	export function l(str: "Author"): any;
	export function l(str: "NoTitle"): any;
	export function l(str: "CurrentSelections"): any;
	export function l(str: "AllContent"): any;
	export function l(str: "CancelLastAction"): any;
	export function l(str: "SearchTips"): any;
	export function l(str: "CheckSpelling"): any;
	export function l(str: "TryUsingFewerKeywords"): any;
	export function l(str: "SelectFewerFilters"): any;
	export function l(str: "Document"): any;
	export function l(str: "Time"): any;
	export function l(str: "StartDate"): any;
	export function l(str: "StartTime"): any;
	export function l(str: "DurationTitle"): any;
	export function l(str: "UserQuery"): any;
	export function l(str: "ShowUserActions"): any;
	export function l(str: "NoData"): any;
	export function l(str: "EventType"): any;
	export function l(str: "GoToFullSearch"): any;
	export function l(str: "GoToEdition"): any;
	export function l(str: "RemoveContext"): any;
	export function l(str: "BoxAttachToCase"): any;
	export function l(str: "AttachToCase"): any;
	export function l(str: "Attach"): any;
	export function l(str: "Attached"): any;
	export function l(str: "Detach"): any;
	export function l(str: "Details"): any;
	export function l(str: "AdditionalFilters"): any;
	export function l(str: "SelectNonContextualSearch"): any;
	export function l(str: "CopyPasteToSupport"): any;
	export function l(str: "FollowQueryDescription"): any;
	export function l(str: "SearchAlerts_Panel"): any;
	export function l(str: "SearchAlerts_PanelDescription"): any;
	export function l(str: "SearchAlerts_PanelNoSearchAlerts"): any;
	export function l(str: "SearchAlerts_Fail"): any;
	export function l(str: "SearchAlerts_Type"): any;
	export function l(str: "SearchAlerts_Content"): any;
	export function l(str: "SearchAlerts_Actions"): any;
	export function l(str: "EmptyQuery"): any;
	export function l(str: "SearchAlerts_Type_followQuery"): any;
	export function l(str: "SearchAlerts_Type_followDocument"): any;
	export function l(str: "SearchAlerts_unFollowing"): any;
	export function l(str: "SearchAlerts_follow"): any;
	export function l(str: "SearchAlerts_followed"): any;
	export function l(str: "SearchAlerts_followQuery"): any;
	export function l(str: "Subscription_StopFollowingQuery"): any;
	export function l(str: "SearchAlerts_Frequency"): any;
	export function l(str: "SubscriptionsManageSubscriptions"): any;
	export function l(str: "SubscriptionsMessageFollowQuery", param0: string): any;
	export function l(str: "SubscriptionsMessageFollow", param0: string): any;
	export function l(str: "Expiration"): any;
	export function l(str: "Daily"): any;
	export function l(str: "Monday"): any;
	export function l(str: "Tuesday"): any;
	export function l(str: "Wednesday"): any;
	export function l(str: "Thursday"): any;
	export function l(str: "Friday"): any;
	export function l(str: "Saturday"): any;
	export function l(str: "Sunday"): any;
	export function l(str: "StartTypingCaseForSuggestions"): any;
	export function l(str: "ExportToExcel"): any;
	export function l(str: "ExportToExcelDescription"): any;
	export function l(str: "CaseCreationNoResults"): any;
	export function l(str: "SortBy"): any;
	export function l(str: "BoxCreateArticle"): any;
	export function l(str: "Facets"): any;
	export function l(str: "objecttype_people"): any;
	export function l(str: "objecttype_message"): any;
	export function l(str: "objecttype_feed"): any;
	export function l(str: "objecttype_thread"): any;
	export function l(str: "objecttype_file"): any;
	export function l(str: "objecttype_board"): any;
	export function l(str: "objecttype_category"): any;
	export function l(str: "objecttype_account"): any;
	export function l(str: "objecttype_campaign"): any;
	export function l(str: "objecttype_case"): any;
	export function l(str: "objecttype_contact"): any;
	export function l(str: "objecttype_contract"): any;
	export function l(str: "objecttype_event"): any;
	export function l(str: "objecttype_lead"): any;
	export function l(str: "objecttype_solution"): any;
	export function l(str: "objecttype_task"): any;
	export function l(str: "objecttype_user"): any;
	export function l(str: "objecttype_attachment"): any;
	export function l(str: "objecttype_casecomment"): any;
	export function l(str: "objecttype_opportunity"): any;
	export function l(str: "objecttype_feeditem"): any;
	export function l(str: "objecttype_feedcomment"): any;
	export function l(str: "objecttype_note"): any;
	export function l(str: "objecttype_product"): any;
	export function l(str: "objecttype_partner"): any;
	export function l(str: "objecttype_kbdocumentation"): any;
	export function l(str: "objecttype_kbtechnicalarticle"): any;
	export function l(str: "objecttype_kbsolution"): any;
	export function l(str: "objecttype_kbknowledgearticle"): any;
	export function l(str: "objecttype_kbattachment"): any;
	export function l(str: "filetype_html"): any;
	export function l(str: "filetype_wiki"): any;
	export function l(str: "filetype_webscraperwebpage"): any;
	export function l(str: "filetype_image"): any;
	export function l(str: "filetype_folder"): any;
	export function l(str: "filetype_txt"): any;
	export function l(str: "filetype_zip"): any;
	export function l(str: "filetype_pdf"): any;
	export function l(str: "filetype_xml"): any;
	export function l(str: "filetype_doc"): any;
	export function l(str: "filetype_xls"): any;
	export function l(str: "filetype_ppt"): any;
	export function l(str: "filetype_video"): any;
	export function l(str: "filetype_youtube"): any;
	export function l(str: "filetype_saleforceitem"): any;
	export function l(str: "filetype_exchangemessage"): any;
	export function l(str: "filetype_exchangeappointment"): any;
	export function l(str: "filetype_exchangenote"): any;
	export function l(str: "filetype_exchangetask"): any;
	export function l(str: "filetype_exchangeperson"): any;
	export function l(str: "filetype_activedirperson"): any;
	export function l(str: "filetype_exchangeactivity"): any;
	export function l(str: "filetype_exchangecalendarmessage"): any;
	export function l(str: "filetype_exchangedocument"): any;
	export function l(str: "filetype_exchangerssfeed"): any;
	export function l(str: "filetype_exchangejunkmessage"): any;
	export function l(str: "filetype_exchangeofficecom"): any;
	export function l(str: "filetype_lithiummessage"): any;
	export function l(str: "filetype_lithiumthread"): any;
	export function l(str: "filetype_lithiumboard"): any;
	export function l(str: "filetype_lithiumcategory"): any;
	export function l(str: "filetype_lithiumcommunity"): any;
	export function l(str: "filetype_spportal"): any;
	export function l(str: "filetype_spsite"): any;
	export function l(str: "filetype_spuserprofile"): any;
	export function l(str: "filetype_sparea"): any;
	export function l(str: "filetype_spannouncement"): any;
	export function l(str: "filetype_spannouncementlist"): any;
	export function l(str: "filetype_spcontact"): any;
	export function l(str: "filetype_spcontactlist"): any;
	export function l(str: "filetype_spcustomlist"): any;
	export function l(str: "filetype_spdiscussionboard"): any;
	export function l(str: "filetype_spdiscussionboardlist"): any;
	export function l(str: "filetype_spdocumentlibrarylist"): any;
	export function l(str: "filetype_spevent"): any;
	export function l(str: "filetype_speventlist"): any;
	export function l(str: "filetype_spformlibrarylist"): any;
	export function l(str: "filetype_spissue"): any;
	export function l(str: "filetype_spissuelist"): any;
	export function l(str: "filetype_splink"): any;
	export function l(str: "filetype_splinklist"): any;
	export function l(str: "filetype_sppicturelibrarylist"): any;
	export function l(str: "filetype_spsurvey"): any;
	export function l(str: "filetype_spsurveylist"): any;
	export function l(str: "filetype_sptask"): any;
	export function l(str: "filetype_sptasklist"): any;
	export function l(str: "filetype_spagenda"): any;
	export function l(str: "filetype_spagendalist"): any;
	export function l(str: "filetype_spattendee"): any;
	export function l(str: "filetype_spattendeelist"): any;
	export function l(str: "filetype_spcustomgridlist"): any;
	export function l(str: "filetype_spdecision"): any;
	export function l(str: "filetype_spdecisionlist"): any;
	export function l(str: "filetype_spobjective"): any;
	export function l(str: "filetype_spobjectivelist"): any;
	export function l(str: "filetype_sptextbox"): any;
	export function l(str: "filetype_sptextboxlist"): any;
	export function l(str: "filetype_spthingstobring"): any;
	export function l(str: "filetype_spthingstobringlist"): any;
	export function l(str: "filetype_sparealisting"): any;
	export function l(str: "filetype_spmeetingserie"): any;
	export function l(str: "filetype_spmeetingserielist"): any;
	export function l(str: "filetype_spsitedirectory"): any;
	export function l(str: "filetype_spsitedirectorylist"): any;
	export function l(str: "filetype_spdatasource"): any;
	export function l(str: "filetype_spdatasourcelist"): any;
	export function l(str: "filetype_splisttemplatecataloglist"): any;
	export function l(str: "filetype_spwebpartcataloglist"): any;
	export function l(str: "filetype_spwebtemplatecataloglist"): any;
	export function l(str: "filetype_spworkspacepagelist"): any;
	export function l(str: "filetype_spunknownlist"): any;
	export function l(str: "filetype_spadministratortask"): any;
	export function l(str: "filetype_spadministratortasklist"): any;
	export function l(str: "filetype_spareadocumentlibrarylist"): any;
	export function l(str: "filetype_spblogcategory"): any;
	export function l(str: "filetype_spblogcategorylist"): any;
	export function l(str: "filetype_spblogcomment"): any;
	export function l(str: "filetype_spblogcommentlist"): any;
	export function l(str: "filetype_spblogpost"): any;
	export function l(str: "filetype_spblogpostlist"): any;
	export function l(str: "filetype_spdataconnectionlibrarylist"): any;
	export function l(str: "filetype_spdistributiongroup"): any;
	export function l(str: "filetype_spdistributiongrouplist"): any;
	export function l(str: "filetype_spipfslist"): any;
	export function l(str: "filetype_spkeyperformanceindicator"): any;
	export function l(str: "filetype_spkeyperformanceindicatorlist"): any;
	export function l(str: "filetype_splanguagesandtranslator"): any;
	export function l(str: "filetype_splanguagesandtranslatorlist"): any;
	export function l(str: "filetype_spmasterpagescataloglist"): any;
	export function l(str: "filetype_spnocodeworkflowlibrarylist"): any;
	export function l(str: "filetype_spprojecttask"): any;
	export function l(str: "filetype_spprojecttasklist"): any;
	export function l(str: "filetype_sppublishingpageslibrarylist"): any;
	export function l(str: "filetype_spreportdocumentlibrarylist"): any;
	export function l(str: "filetype_spreportlibrarylist"): any;
	export function l(str: "filetype_spslidelibrarylist"): any;
	export function l(str: "filetype_sptab"): any;
	export function l(str: "filetype_sptablist"): any;
	export function l(str: "filetype_sptranslationmanagementlibrarylist"): any;
	export function l(str: "filetype_spuserinformation"): any;
	export function l(str: "filetype_spuserinformationlist"): any;
	export function l(str: "filetype_spwikipagelibrarylist"): any;
	export function l(str: "filetype_spworkflowhistory"): any;
	export function l(str: "filetype_spworkflowhistorylist"): any;
	export function l(str: "filetype_spworkflowprocess"): any;
	export function l(str: "filetype_spworkflowprocesslist"): any;
	export function l(str: "filetype_sppublishingimageslibrarylist"): any;
	export function l(str: "filetype_spcirculation"): any;
	export function l(str: "filetype_spcirculationlist"): any;
	export function l(str: "filetype_spdashboardslibrarylist"): any;
	export function l(str: "filetype_spdataconnectionforperformancepointlibrarylist"): any;
	export function l(str: "filetype_sphealthreport"): any;
	export function l(str: "filetype_sphealthreportlist"): any;
	export function l(str: "filetype_sphealthrule"): any;
	export function l(str: "filetype_sphealthrulelist"): any;
	export function l(str: "filetype_spimedictionary"): any;
	export function l(str: "filetype_spimedictionarylist"): any;
	export function l(str: "filetype_spperformancepointcontent"): any;
	export function l(str: "filetype_spperformancepointcontentlist"): any;
	export function l(str: "filetype_spphonecallmemo"): any;
	export function l(str: "filetype_spphonecallmemolist"): any;
	export function l(str: "filetype_sprecordlibrarylist"): any;
	export function l(str: "filetype_spresource"): any;
	export function l(str: "filetype_spresourcelist"): any;
	export function l(str: "filetype_spprocessdiagramslibrarylist"): any;
	export function l(str: "filetype_spsitethemeslibrarylist"): any;
	export function l(str: "filetype_spsolutionslibrarylist"): any;
	export function l(str: "filetype_spwfpublibrarylist"): any;
	export function l(str: "filetype_spwhereabout"): any;
	export function l(str: "filetype_spwhereaboutlist"): any;
	export function l(str: "filetype_spdocumentlink"): any;
	export function l(str: "filetype_spdocumentset"): any;
	export function l(str: "filetype_spmicrofeedpost"): any;
	export function l(str: "filetype_spmicrofeedlist"): any;
	export function l(str: "filetype_splistfolder"): any;
	export function l(str: "filetype_youtubevideo"): any;
	export function l(str: "filetype_youtubeplaylistitem"): any;
	export function l(...params: any[]): any;

}
declare module Coveo {
	
	
	export interface IComponentOptionsLoadOption<T> {
	    (element: HTMLElement, name: string, option: IComponentOptionsOption<T>): T;
	}
	export interface IComponentOptionsPostProcessing<T> {
	    (value: T, options: any): T;
	}
	export interface IComponentOptionsOption<T> extends IComponentOptions<T> {
	    type?: ComponentOptionsType;
	    load?: IComponentOptionsLoadOption<T>;
	}
	export interface IComponentOptions<T> {
	    defaultValue?: T;
	    defaultFunction?: (element: HTMLElement) => T;
	    required?: boolean;
	    postProcessing?: IComponentOptionsPostProcessing<T>;
	    attrName?: string;
	    alias?: string;
	    section?: string;
	    depend?: string;
	    priority?: number;
	    deprecated?: string;
	}
	export interface IComponentOptionsNumberOption extends IComponentOptionsOption<number>, IComponentOptionsNumberOptionArgs {
	}
	export interface IComponentOptionsNumberOptionArgs extends IComponentOptions<number> {
	    min?: number;
	    max?: number;
	    float?: boolean;
	}
	export interface IComponentOptionsListOption extends IComponentOptionsOption<string[]>, IComponentOptionsListOptionArgs {
	}
	export interface IComponentOptionsListOptionArgs extends IComponentOptions<string[]> {
	    separator?: RegExp;
	    values?: any;
	}
	export interface IComponentOptionsCustomListOptionArgs<T> extends IComponentOptions<T> {
	    separator?: RegExp;
	    values?: any;
	}
	export interface IComponentOptionsChildHtmlElementOption extends IComponentOptionsOption<HTMLElement>, IComponentOptionsChildHtmlElementOptionArgs {
	}
	export interface IComponentOptionsChildHtmlElementOptionArgs extends IComponentOptions<HTMLElement> {
	    selectorAttr?: string;
	    childSelector?: string;
	}
	export interface IComponentOptionsTemplateOption extends IComponentOptionsOption<Template>, IComponentOptionsTemplateOptionArgs {
	}
	export interface IComponentOptionsTemplateOptionArgs extends IComponentOptions<Template> {
	    selectorAttr?: string;
	    childSelector?: string;
	    idAttr?: string;
	}
	export interface IComponentOptionsFieldOption extends IComponentOptionsOption<string>, IComponentOptionsFieldOptionArgs {
	}
	export interface IComponentOptionsFieldOptionArgs extends IComponentOptions<string> {
	    groupByField?: boolean;
	    includeInResults?: boolean;
	    sortByField?: boolean;
	    splitGroupByField?: boolean;
	    match?: (field: IFieldDescription) => boolean;
	}
	export interface IComponentOptionsFieldsOption extends IComponentOptionsOption<string[]>, IComponentOptionsFieldsOptionArgs {
	}
	export interface IComponentOptionsFieldsOptionArgs extends IComponentOptions<string[]> {
	    groupByField?: boolean;
	    includeInResults?: boolean;
	    sortByField?: boolean;
	    splitGroupByField?: boolean;
	    match?: (field: IFieldDescription) => boolean;
	}
	export interface IComponentOptionsObjectOption extends IComponentOptionsOption<{
	    [key: string]: any;
	}>, IComponentOptionsObjectOptionArgs {
	}
	export interface IComponentOptionsObjectOptionArgs extends IComponentOptions<{
	    [key: string]: any;
	}> {
	    subOptions: {
	        [key: string]: IComponentOptionsOption<any>;
	    };
	}
	export enum ComponentOptionsType {
	    BOOLEAN = 0,
	    NUMBER = 1,
	    STRING = 2,
	    LOCALIZED_STRING = 3,
	    LIST = 4,
	    SELECTOR = 5,
	    CHILD_HTML_ELEMENT = 6,
	    TEMPLATE = 7,
	    FIELD = 8,
	    FIELDS = 9,
	    ICON = 10,
	    OBJECT = 11,
	    QUERY = 12,
	    HELPER = 13,
	    LONG_STRING = 14,
	    JSON = 15,
	    JAVASCRIPT = 16,
	    NONE = 17,
	}
	export class ComponentOptions {
	    static buildBooleanOption(optionArgs?: IComponentOptions<boolean>): boolean;
	    static buildNumberOption(optionArgs?: IComponentOptionsNumberOptionArgs): number;
	    static buildStringOption(optionArgs?: IComponentOptions<string>): string;
	    static buildIconOption(optionArgs?: IComponentOptions<string>): string;
	    static buildHelperOption(optionArgs?: IComponentOptions<string>): string;
	    static buildJsonOption(optionArgs?: IComponentOptions<string>): string;
	    static buildLocalizedStringOption(optionArgs?: IComponentOptions<string>): string;
	    static buildFieldOption(optionArgs?: IComponentOptionsFieldOptionArgs): string;
	    static buildFieldsOption(optionArgs?: IComponentOptionsFieldsOptionArgs): string[];
	    static buildListOption(optionArgs?: IComponentOptionsListOptionArgs): string[];
	    static buildSelectorOption(optionArgs?: IComponentOptions<HTMLElement>): HTMLElement;
	    static buildChildHtmlElementOption(optionArgs?: IComponentOptionsChildHtmlElementOptionArgs): HTMLElement;
	    static buildTemplateOption(optionArgs?: IComponentOptionsTemplateOptionArgs): Template;
	    static buildCustomOption<T>(converter: (value: string) => T, optionArgs?: IComponentOptions<T>): T;
	    static buildCustomListOption<T>(converter: (value: string[]) => T, optionArgs?: IComponentOptionsCustomListOptionArgs<T>): T;
	    static buildObjectOption(optionArgs?: IComponentOptionsObjectOptionArgs): any;
	    static buildOption<T>(type: ComponentOptionsType, load: IComponentOptionsLoadOption<T>, optionArg?: IComponentOptions<T>): T;
	    static attrNameFromName(name: string, optionArgs?: IComponentOptions<any>): string;
	    static camelCaseToHyphen(name: string): string;
	    static mergeCamelCase(parent: string, name: string): string;
	    static initComponentOptions(element: HTMLElement, component: any, values?: any): any;
	    static initOptions(element: HTMLElement, options: {
	        [name: string]: IComponentOptionsOption<any>;
	    }, values?: any, componentID?: any): any;
	    static loadStringOption(element: HTMLElement, name: string, option: IComponentOptions<any>): string;
	    static loadFieldOption(element: HTMLElement, name: string, option: IComponentOptionsOption<any>): string;
	    static loadFieldsOption(element: HTMLElement, name: string, option: IComponentOptionsOption<any>): string[];
	    static loadLocalizedStringOption(element: HTMLElement, name: string, option: IComponentOptionsOption<any>): string;
	    static loadNumberOption(element: HTMLElement, name: string, option: IComponentOptionsNumberOption): number;
	    static loadBooleanOption(element: HTMLElement, name: string, option: IComponentOptionsOption<any>): boolean;
	    static loadListOption(element: HTMLElement, name: string, option: IComponentOptionsListOption): string[];
	    static loadEnumOption(element: HTMLElement, name: string, option: IComponentOptionsOption<any>, _enum: any): number;
	    static loadSelectorOption(element: HTMLElement, name: string, option: IComponentOptionsOption<any>, doc?: Document): HTMLElement;
	    static loadChildHtmlElementOption(element: HTMLElement, name: string, option: IComponentOptionsChildHtmlElementOption, doc?: Document): HTMLElement;
	    static loadChildHtmlElementFromSelector(element: HTMLElement, selector: string): HTMLElement;
	    static loadChildrenHtmlElementFromSelector(element: HTMLElement, selector: string): HTMLElement[];
	    static loadTemplateOption(element: HTMLElement, name: string, option: IComponentOptionsTemplateOption, doc?: Document): Template;
	    static loadResultTemplateFromId(templateId: string): Template;
	    static loadChildrenResultTemplateFromSelector(element: HTMLElement, selector: string): Template;
	    static findParentScrolling(element: HTMLElement, doc?: Document): HTMLElement;
	    static isElementScrollable(element: HTMLElement): boolean;
	    static getAttributeFromAlias(element: HTMLElement, option: IComponentOptions<any>): string;
	    static createResultTemplateFromElement(element: HTMLElement): Template;
	}

}
declare module Coveo {
	
	/**
	 * The bindings, or environment in which each component inside the {@link ResultList} exists.
	 */
	export interface IResultsComponentBindings extends IComponentBindings {
	    resultElement: HTMLElement;
	}

}
declare module Coveo {
	export class Options {
	    merge<T>(provided: T): T;
	    mergeDeep<T>(provided: T): T;
	}

}
declare module Coveo {
	export interface IDateToStringOptions {
	    now?: Date;
	    useTodayYesterdayAndTomorrow?: boolean;
	    useWeekdayIfThisWeek?: boolean;
	    omitYearIfCurrentOne?: boolean;
	    useLongDateFormat?: boolean;
	    includeTimeIfToday?: boolean;
	    includeTimeIfThisWeek?: boolean;
	    alwaysIncludeTime?: boolean;
	    predefinedFormat?: string;
	}
	export class DateUtils {
	    static convertFromJsonDateIfNeeded(date: string): Date;
	    static convertFromJsonDateIfNeeded(date: number): Date;
	    static convertFromJsonDateIfNeeded(date: Date): Date;
	    static keepOnlyDatePart(date: Date): Date;
	    static offsetDateByDays(date: Date, offset: number): Date;
	    static dateToString(d: Date, options?: IDateToStringOptions): string;
	    static timeToString(date: Date, options?: IDateToStringOptions): string;
	    static dateTimeToString(date: Date, options?: IDateToStringOptions): string;
	    static monthToString(month: number): string;
	    static isValid(date: any): boolean;
	    static timeBetween(from: Date, to: Date): string;
	}

}
declare module Coveo {
	
	export interface IFileTypeInfo {
	    icon: string;
	    caption: string;
	}
	export class FileTypes {
	    static get(result: IQueryResult): IFileTypeInfo;
	    static getObjectType(objecttype: string): IFileTypeInfo;
	    static getFileType(filetype: string): IFileTypeInfo;
	    static getFileTypeCaptions(): {
	        [id: string]: string;
	    };
	}

}
declare module Coveo {
	
	
	
	export class DomUtils {
	    static getPopUpCloseButton(captionForClose: string, captionForReminder: string): string;
	    static getBasicLoadingAnimation(): HTMLDivElement;
	    static highlightElement(initialString: string, valueToSearch: string): string;
	    static getLoadingSpinner(): HTMLElement;
	    static getQuickviewHeader(result: IQueryResult, options: {
	        showDate: boolean;
	        title: string;
	    }, bindings: IResultsComponentBindings): Dom;
	}

}
declare module Coveo {
	export interface IBeforeRedirectEventArgs {
	    searchPageUri: string;
	    cancel: boolean;
	}
	export class StandaloneSearchInterfaceEvents {
	    static beforeRedirect: string;
	}

}
declare module Coveo {
	
	
	
	/**
	 * This component is instantiated automatically by the framework on the root if the {@link SearchInterface}.<br/>
	 * When the {@link SearchInterface.options.enableHistory} option is set to true, this component is instantiated.<br/>
	 * It's only job is to apply changes in the {@link QueryStateModel} to the hash in the URL, and vice versa.<br/>
	 * This component does *not* hold the state of the interface, it only represent it in the URL.
	 */
	export class HistoryController extends RootComponent {
	    windoh: Window;
	    model: Model;
	    queryController: QueryController;
	    static ID: string;
	    static attributesThatDoNotTriggerQuery: string[];
	    private ignoreNextHashChange;
	    private initialHashChange;
	    private willUpdateHash;
	    private hashchange;
	    /**
	     * Create a new history controller
	     * @param element
	     * @param windoh For mock / test purpose.
	     * @param model
	     * @param queryController
	     */
	    constructor(element: HTMLElement, windoh: Window, model: Model, queryController: QueryController);
	    /**
	     * Set the given map of key value in the hash of the URL
	     * @param values
	     */
	    setHashValues(values: {}): void;
	    private handleNuke();
	    private handleHashChange();
	    private updateHashFromModel();
	    private updateModelFromHash();
	    private getHashValue(value);
	    debugInfo(): {
	        'state': {
	            [key: string]: any;
	        };
	    };
	}

}
declare module Coveo {
	
	
	
	
	/**
	 * This component acts like the {@link HistoryController} excepts that is saves the {@link QueryStateModel} in the local storage.<br/>
	 * This will not allow 'back' and 'forward' navigation in the history, like the standard {@link HistoryController} allows. Instead, it load the query state only on page load.<br/>
	 * To enable this component, you should set the {@link SearchInterface.options.useLocalStorageForHistory} as well as the {@link SearchInterface.options.enableHistory} options to true.
	 */
	export class LocalStorageHistoryController extends RootComponent {
	    windoh: Window;
	    model: Model;
	    queryController: QueryController;
	    static ID: string;
	    storage: LocalStorageUtils<{
	        [key: string]: any;
	    }>;
	    private omit;
	    /**
	     * Create a new LocalStorageHistoryController instance
	     * @param element
	     * @param windoh For mock purpose
	     * @param model
	     * @param queryController
	     */
	    constructor(element: HTMLElement, windoh: Window, model: Model, queryController: QueryController);
	    /**
	     * Specifies an array of attributes from the query state model that should not be persisted in the local storage
	     * @param attributes
	     */
	    withoutThoseAttribute(attributes: string[]): void;
	    private updateLocalStorageFromModel();
	    private updateModelFromLocalStorage();
	    setStorageValues(values: {
	        [key: string]: any;
	    }): void;
	}

}
declare module Coveo {
	
	
	
	
	export class NoopAnalyticsClient implements IAnalyticsClient {
	    isContextual: boolean;
	    isActivated(): boolean;
	    getCurrentEventCause(): string;
	    getCurrentEventMeta(): {
	        [key: string]: any;
	    };
	    logSearchEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta): void;
	    logSearchAsYouType<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta): void;
	    logClickEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta, result?: IQueryResult, element?: HTMLElement): void;
	    logCustomEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta, element?: HTMLElement): void;
	    getTopQueries(params: ITopQueries): Promise<string[]>;
	    getCurrentVisitIdPromise(): Promise<string>;
	    getCurrentVisitId(): string;
	    sendAllPendingEvents(): void;
	    cancelAllPendingEvents(): void;
	    warnAboutSearchEvent(): void;
	    getPendingSearchEvent(): any;
	}

}
declare module Coveo {
	
	export interface IDisplayedNewResultEventArgs {
	    result: IQueryResult;
	    item: HTMLElement;
	}
	export interface IDisplayedNewResultsEventArgs {
	}
	export interface IOpenQuickviewEventArgs {
	    termsToHighlight: any;
	}
	export class ResultListEvents {
	    static newResultsDisplayed: string;
	    static newResultDisplayed: string;
	    static openQuickview: string;
	}

}
declare module Coveo {
	/// <reference path="../../../../node_modules/modal-box/bin/ModalBox.d.ts" />
	
	
	
	
	export interface IDebugOptions {
	    enableDebug?: boolean;
	}
	export class Debug extends RootComponent {
	    element: HTMLElement;
	    queryController: QueryController;
	    options: IDebugOptions;
	    static ID: string;
	    static options: IDebugOptions;
	    static customOrder: string[];
	    static durationKeys: string[];
	    static maxDepth: number;
	    localStorageDebug: LocalStorageUtils<string[]>;
	    collapsedSections: string[];
	    private debug;
	    private highlightRecommendation;
	    private fields;
	    private stackDebug;
	    constructor(element: HTMLElement, queryController: QueryController, options?: IDebugOptions);
	    private showDebugPanel(builder);
	    private handleShowDebugPanel(info);
	    private handleNewResultDisplayed(args);
	    private handleResultDoubleClick(e, args);
	    private downloadHref(info);
	    buildStackPanel(stackDebug: any, results?: IQueryResults): {
	        body: HTMLElement;
	        json: any;
	    };
	    private buildStackPanelSection(value, results);
	    private buildSearchBox(body);
	    private search(value, body);
	    private findInProperty(element, value);
	    private buildEnableDebugCheckbox(body, search, bodyBuilder);
	    private buildEnabledHighlightRecommendation();
	    private buildSection(id);
	    private fetchFields();
	    private buildFieldsSection(result);
	    private buildRankingInfoSection(result);
	    parseRankingInfo(value: string): {};
	    private parseWeights(value);
	    private buildProperty(value, label?);
	    private buildPromise(promise, label?);
	    private buildObjectProperty(object, label?);
	    private buildBasicProperty(value, label?);
	    private toJson(value, depth?, done?);
	    private toJsonRef(value, stringValue?);
	    private componentToJson(value, depth?);
	    private htmlToJson(value);
	    private templateToJson(template);
	    private selectElementText(el);
	    private highlightSearch(element, search);
	    private removeHighlightSearch(element);
	    debugInfo(): any;
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	
	
	export interface ISearchInterfaceOptions {
	    enableHistory?: boolean;
	    enableAutomaticResponsiveMode?: boolean;
	    useLocalStorageForHistory?: boolean;
	    resultsPerPage?: number;
	    excerptLength?: number;
	    expression?: string;
	    filterField?: string;
	    hideUntilFirstQuery?: boolean;
	    firstLoadingAnimation?: HTMLElement;
	    autoTriggerQuery?: boolean;
	    timezone?: string;
	    enableDebugInfo?: boolean;
	    enableCollaborativeRating?: boolean;
	    enableDuplicateFiltering?: boolean;
	    pipeline?: string;
	    maximumAge?: number;
	    searchPageUri?: string;
	    initOptions?: any;
	    endpoint?: SearchEndpoint;
	    originalOptionsObject?: any;
	}
	/**
	 * This component is the root and main component of your search interface.<br/>
	 * You should place every other component inside this component.<br/>
	 * It is also on this component that you call the initialization function.<br/>
	 * Since this component is the root of your search UI, it is recommended that you give it a unique HTML id attribute in order to reference it easily.
	 */
	export class SearchInterface extends RootComponent {
	    element: HTMLElement;
	    options: ISearchInterfaceOptions;
	    analyticsOptions: any;
	    static ID: string;
	    /**
	     * The options for the search interface
	     * @componentOptions
	     */
	    static options: ISearchInterfaceOptions;
	    static SMALL_INTERFACE_CLASS_NAME: string;
	    private attachedComponents;
	    private isNewDesignAttribute;
	    root: HTMLElement;
	    queryStateModel: QueryStateModel;
	    componentStateModel: ComponentStateModel;
	    queryController: QueryController;
	    componentOptionsModel: ComponentOptionsModel;
	    usageAnalytics: IAnalyticsClient;
	    /**
	     * Create a new search interface. Initialize letious singleton for the interface (eg : Usage analytic, query controller, state model, etc.)<br/>
	     * Bind event related to the query.<br/>
	     * Will hide and show the loading animation, if activated.<br/>
	     * @param element The HTMLElement on which the element will be instantiated. This cannot be an HTMLInputElement for technical reason
	     * @param options The options for the querybox.
	     * @param analyticsOptions The options for the analytics component. Since the analytics component is normally global, it needs to be passed at initialization of the whole interface
	     * @param _window The window object for the search interface. Used for unit tests, which can pass a mock. Default is the global window object.
	     */
	    constructor(element: HTMLElement, options?: ISearchInterfaceOptions, analyticsOptions?: any, _window?: Window);
	    /**
	     * Display the first query animation.<br/>
	     * This is normally the Coveo logo with a css animation (which can be customized with options or css)
	     */
	    showWaitAnimation(): void;
	    /**
	     * Hide the first query animation.<br/>
	     * This is normally the Coveo logo with a css animation (which can be customized with options or css)
	     */
	    hideWaitAnimation(): void;
	    /**
	     * Attach a component to the interface. This allows the interface to easily list and traverse it's component.
	     * @param type Normally a unique identifier without the Coveo prefix. Eg : CoveoFacet -> Facet, CoveoPager -> Pager, CoveoQuerybox -> Querybox, etc.
	     * @param component The component instance to attach
	     */
	    attachComponent(type: string, component: BaseComponent): void;
	    /**
	     * Detach a component from the interface.
	     * @param type Normally a unique identifier without the Coveo prefix. Eg : CoveoFacet -> Facet, CoveoPager -> Pager, CoveoQuerybox -> Querybox, etc.
	     * @param component The component instance to detach
	     */
	    detachComponent(type: string, component: BaseComponent): void;
	    /**
	     * Return the bindings, or environment, for the current component
	     * @returns {IComponentBindings}
	     */
	    getBindings(): {
	        root: HTMLElement;
	        queryStateModel: QueryStateModel;
	        queryController: QueryController;
	        searchInterface: SearchInterface;
	        componentStateModel: ComponentStateModel;
	        componentOptionsModel: ComponentOptionsModel;
	        usageAnalytics: IAnalyticsClient;
	    };
	    /**
	     * Get all the components for a given type
	     * @param type Normally a unique identifier without the Coveo prefix. Eg : CoveoFacet -> Facet, CoveoPager -> Pager, CoveoQuerybox -> Querybox, etc.
	     */
	    getComponents<T>(type: string): T[];
	    /**
	     * Determines whether the interface is using the new design.<br/>
	     * This changes the rendering of multiple components.
	     */
	    isNewDesign(): boolean;
	    protected initializeAnalytics(): IAnalyticsClient;
	    private setupDebugInfo();
	    private showAndHideFirstQueryAnimation();
	    private handlePreprocessQueryStateModel(args);
	    private getTabGroupId(tabGroupId);
	    private getTabId(tabGroupId, tabId);
	    private getSort(tabId, sortId);
	    private getQuickview(quickviewId);
	    private handleQuickviewChanged(args);
	    private handleBuildingQuery(data);
	    private handleQuerySuccess(data);
	    private handleQueryError(data);
	    private toggleSectionState(cssClass, toggle?);
	}
	export interface IStandaloneSearchInterfaceOptions extends ISearchInterfaceOptions {
	    redirectIfEmpty?: boolean;
	}
	export class StandaloneSearchInterface extends SearchInterface {
	    element: HTMLElement;
	    options: IStandaloneSearchInterfaceOptions;
	    analyticsOptions: any;
	    static ID: string;
	    static options: IStandaloneSearchInterfaceOptions;
	    constructor(element: HTMLElement, options?: IStandaloneSearchInterfaceOptions, analyticsOptions?: any, _window?: Window);
	    handleRedirect(e: Event, data: INewQueryEventArgs): void;
	    redirectToSearchPage(searchPage: string): void;
	    private searchboxIsEmpty();
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	export class SearchEndpointWithDefaultCallOptions implements ISearchEndpoint {
	    private endpoint;
	    private callOptions;
	    options: ISearchEndpointOptions;
	    constructor(endpoint: ISearchEndpoint, callOptions?: IEndpointCallOptions);
	    getBaseUri(): string;
	    getBaseAlertsUri(): string;
	    getAuthenticationProviderUri(provider: string, returnUri: string, message: string): string;
	    isJsonp(): boolean;
	    search(query: IQuery, callOptions?: IEndpointCallOptions): Promise<IQueryResults>;
	    getExportToExcelLink(query: IQuery, numberOfResults: number, callOptions?: IEndpointCallOptions): string;
	    tagDocument(taggingRequest: ITaggingRequest, callOptions?: IEndpointCallOptions): Promise<boolean>;
	    getRevealQuerySuggest(request: IRevealQuerySuggestRequest, callOptions?: IEndpointCallOptions): Promise<IRevealQuerySuggestResponse>;
	    rateDocument(ratingRequest: IRatingRequest, callOptions?: IEndpointCallOptions): Promise<boolean>;
	    getRawDataStream(documentUniqueId: string, dataStreamType: string, callOptions?: IViewAsHtmlOptions): Promise<ArrayBuffer>;
	    getDocument(documentUniqueId: string, callOptions?: IGetDocumentOptions): Promise<IQueryResult>;
	    getDocumentText(documentUniqueID: string, callOptions?: IEndpointCallOptions): Promise<string>;
	    getDocumentHtml(documentUniqueID: string, callOptions?: IViewAsHtmlOptions): Promise<HTMLDocument>;
	    getViewAsHtmlUri(documentUniqueID: string, callOptions?: IViewAsHtmlOptions): string;
	    getViewAsDatastreamUri(documentUniqueID: string, dataStreamType: string, callOptions?: IViewAsHtmlOptions): string;
	    listFieldValues(request: IListFieldValuesRequest, callOptions?: IEndpointCallOptions): Promise<IIndexFieldValue[]>;
	    listFields(callOptions?: IEndpointCallOptions): Promise<IFieldDescription[]>;
	    extensions(callOptions?: IEndpointCallOptions): Promise<IExtension[]> | Promise<IEndpointError>;
	    follow(request: ISubscriptionRequest): Promise<ISubscription>;
	    listSubscriptions(page: number): Promise<ISubscription[]>;
	    updateSubscription(subscription: ISubscription): Promise<ISubscription>;
	    deleteSubscription(subscription: ISubscription): Promise<ISubscription>;
	    private enrichCallOptions<T>(callOptions?);
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	/**
	 * Possible options when performing a query with the query controller
	 */
	export interface IQueryOptions {
	    /**
	     * If the analytics component is enabled in the interface, it will look for any query executed by the query controller for which no analytics event was associated.<br/>
	     * By setting this property to true, this will cancel this check when the query is performed
	     */
	    ignoreWarningSearchEvent?: boolean;
	    /**
	     * Specify that the query to execute is a search as you type. This information will be passed down in the query events for component and external code to determine their behavior
	     */
	    searchAsYouType?: boolean;
	    /**
	     * Specify a function that you wish to execute just before the query is executed
	     */
	    beforeExecuteQuery?: () => void;
	    /**
	     * Cancel the query
	     */
	    cancel?: boolean;
	    /**
	     * The component from which the query originated. For example the pager will set the property to tweak it's behaviour
	     */
	    origin?: any;
	    /**
	     * Whether or not to log the query in the user actions history when using the page view script: https://github.com/coveo/coveo.analytics.js.
	     * Only the 'q' part of the query will be logged.
	     * This option is useful, because it prevents the query to be logged twice when a {@link Recommendation} component is present.
	     * It also makes sure that only relevant queries are logged. For exemple, the 'empty' interface load query isn't logged.
	     */
	    logInActionsHistory?: boolean;
	    keepLastSearchUid?: boolean;
	    closeModalBox?: boolean;
	}
	/**
	 * This class is automatically instantiated and bound to the root of your search interface when you initialize the framework.<br/>
	 * It is essentially a singleton that wraps the access to the {@link SearchEndpoint} endpoint to execute query, and is in charge of triggering the different query events.<br/>
	 * This is what every component of the framework uses internally to execute query or access the endpoint.<br/>
	 * When calling <code>Coveo.executeQuery</code> this class is used.
	 */
	export class QueryController extends RootComponent {
	    options: ISearchInterfaceOptions;
	    usageAnalytics: any;
	    searchInterface: any;
	    static ID: string;
	    private currentPendingQuery;
	    private lastQueryBuilder;
	    private lastQueryHash;
	    private lastQuery;
	    private lastSearchUid;
	    private lastQueryResults;
	    private currentError;
	    private firstQuery;
	    private createdOneQueryBuilder;
	    private showingExecutingQueryAnimation;
	    private overrideEndpoint;
	    private localStorage;
	    /**
	     * Create a new query controller
	     * @param element
	     * @param options
	     */
	    constructor(element: HTMLElement, options: ISearchInterfaceOptions, usageAnalytics: any, searchInterface: any);
	    /**
	     * Set the {@link SearchEndpoint} that the query controller should use to execute query
	     * @param endpoint
	     */
	    setEndpoint(endpoint: SearchEndpoint): void;
	    /**
	     * Get the {@link SearchEndpoint} that is currently used by the query controller to execute query
	     * @returns {SearchEndpoint}
	     */
	    getEndpoint(): ISearchEndpoint;
	    /**
	     * Return the last query that was performed by the query controller
	     * @returns {IQuery|Query}
	     */
	    getLastQuery(): IQuery;
	    /**
	     * Execute a query and return a Promise of IQueryResults.<br/>
	     * This will execute the normal query flow, triggering all the necessary query events (newQuery <br/>
	     * All components present in the interface will act accordingly (modify the query and render results if needed).
	     * @param options
	     * @returns {Promise<IQueryResults>}
	     */
	    executeQuery(options?: IQueryOptions): Promise<IQueryResults>;
	    /**
	     * Using the same parameters as the last successful query, fetch another batch of results. Particularly useful for infinite scrolling, for example.
	     * @param count
	     * @returns {any}
	     */
	    fetchMore(count: number): Promise<IQueryResults>;
	    /**
	     * Cancel any pending query
	     */
	    cancelQuery(): void;
	    deferExecuteQuery(options?: IQueryOptions): void;
	    ensureCreatedQueryBuilder(): void;
	    createQueryBuilder(options: IQueryOptions): QueryBuilder;
	    isStandaloneSearchbox(): boolean;
	    saveLastQuery(): void;
	    getLastQueryHash(): string;
	    private getLastSearchUid();
	    private loadLastQueryHash();
	    private continueLastQueryBuilder(queryBuilder, count);
	    private getPipelineInUrl();
	    private cancelAnyCurrentPendingQuery();
	    private showExecutingQueryAnimation();
	    private hideExecutingQueryAnimation();
	    private keepLastSearchUid(query, queryResults);
	    private queryHash(query, queryResults?);
	    private getCallOptions();
	    private newQueryEvent(args);
	    private buildingQueryEvent(args);
	    private doneBuildingQueryEvent(args);
	    private duringQueryEvent(args);
	    private querySuccessEvent(args);
	    private fetchMoreSuccessEvent(args);
	    private deferredQuerySuccessEvent(args);
	    private queryError(args);
	    private preprocessResultsEvent(args);
	    private noResultEvent(args);
	    debugInfo(): any;
	    private buildQueryDurationSection(queryResults);
	    private logQueryInActionsHistory(query);
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	
	
	
	/**
	 * Definition for a Component.
	 */
	export interface IComponentDefinition {
	    /**
	     * The static ID that each component need to be identified.<br/>
	     * For example, SearchButton -> static ID : SearchButton -> className : CoveoSearchButton
	     */
	    ID: string;
	    /**
	     * The generated className for this component.<br/>
	     * For example, SearchButton -> static ID : SearchButton -> className : CoveoSearchButton
	     */
	    className?: string;
	    /**
	     * Constructor for each component
	     * @param element The HTMLElement on which the component will instantiate
	     * @param options The available options for the component
	     * @param bindings The bindings (or environment) for the component.For exemple, the {@link QueryController} or {@link SearchInterface}. Optional, if not provided, the component will resolve those automatically. This has a cost on performance, though, since it has to traverses it's parents to find the correct elements.
	     * @param args Optional arguments, depending on the component type. For example, ResultComponent will receive the result there.
	     */
	    new (element: HTMLElement, options: any, bindings: IComponentBindings, ...args: any[]): Component;
	    /**
	     * The available options for the component
	     */
	    options?: any;
	    /**
	     * The optional parent of the component, which will be a component itself.
	     */
	    parent?: IComponentDefinition;
	    /**
	     * The optional index fields that the component possess or display
	     */
	    fields?: string[];
	}
	/**
	 * The base class for every Component in the framework
	 */
	export class Component extends BaseComponent {
	    element: HTMLElement;
	    type: string;
	    /**
	     * Allows the component to bind events and execute them only when it is enabled.
	     * @type {Coveo.ComponentEvents}
	     */
	    bind: ComponentEvents;
	    /**
	     * A reference to the root HTMLElement (the {@link SearchInterface})
	     */
	    root: HTMLElement;
	    /**
	     * Contains the state of the query. Allows to get/set values. Trigger query state event when modified. Each component can listen to those events.
	     */
	    queryStateModel: QueryStateModel;
	    /**
	     * Contains the state of different component (enabled vs disabled). Allows to get/set values. Trigger component state event when modified. Each component can listen to those events.
	     */
	    componentStateModel: ComponentStateModel;
	    /**
	     * Contains the singleton that allows to trigger queries.
	     */
	    queryController: QueryController;
	    /**
	     * A reference to the root of every component, the {@link SearchInterface}
	     */
	    searchInterface: SearchInterface;
	    /**
	     * A reference to the {@link Analytics.client}.
	     */
	    usageAnalytics: IAnalyticsClient;
	    /**
	     * Contains the state of options for differents component. Mainly used by {@link ResultLink}
	     */
	    componentOptionsModel: ComponentOptionsModel;
	    ensureDom: Function;
	    /**
	     * Create a new Component. Resolve all {@link IComponentBindings} if not provided.<br/>
	     * Create a new Logger for this component.
	     * Attach the component to the {@link SearchInterface}<br/>
	     * @param element The HTMLElement on which to create the component. Used to bind data on the element.
	     * @param type The unique identifier for this component. See : {@link IComponentDefinition.ID}. Used to generate the unique Coveo CSS class associated with every component
	     * @param bindings The environment for every component. Optional, but omitting to provide one will impact performance.
	     */
	    constructor(element: HTMLElement, type: string, bindings?: IComponentBindings);
	    /**
	     * Return the bindings, or environment, for the current component
	     * @returns {IComponentBindings}
	     */
	    getBindings(): IComponentBindings;
	    createDom(): void;
	    resolveSearchInterface(): SearchInterface;
	    resolveRoot(): HTMLElement;
	    resolveQueryController(): QueryController;
	    resolveComponentStateModel(): ComponentStateModel;
	    resolveQueryStateModel(): QueryStateModel;
	    resolveComponentOptionsModel(): ComponentOptionsModel;
	    resolveUA(): IAnalyticsClient;
	    resolveResult(): IQueryResult;
	    /**
	     * Get the bound component to the given HTMLElement. Throws an assert if the HTMLElement has no component bound, unless using the noThrow argument<br/>
	     * If there is multiple component bound to the current HTMLElement, you must specify the component class
	     * @param element HTMLElement for which to get the bound component
	     * @param componentClass Optional component class. If the HTMLElement has multiple components bound, you must specify which one you are targeting
	     * @param noThrow Boolean option to tell the method to not throw on error
	     * @returns {Component}
	     */
	    static get(element: HTMLElement, componentClass?: any, noThrow?: boolean): BaseComponent;
	    static getResult(element: HTMLElement, noThrow?: boolean): IQueryResult;
	    static bindResultToElement(element: HTMLElement, result: IQueryResult): void;
	    static resolveBinding(element: HTMLElement, componentClass: any): BaseComponent;
	    static pointElementsToDummyForm(element: HTMLElement): void;
	}
	/**
	 * Used by the various Coveo Component to trigger and bind event.<br/>
	 * It adds a small logic to execute handler or triggers only when the component is "enabled".<br/>
	 * A component is disabled by calling {Component.disable}<br/>
	 * Typically, a Component is disabled when it is not active in the current {Tab}.<br/>
	 * It can also be disabled by external code.<br/>
	 * The class serves as a way to not execute handler on component that are invisible and inactive in the query.
	 */
	export class ComponentEvents {
	    owner: Component;
	    /**
	     * Create a new ComponentEvents for the given {@link Component}
	     * @param owner The {@link Component} which owns those events handler and trigger
	     */
	    constructor(owner: Component);
	    /**
	     * Execute the handler for the given event on the given target element.<br/>
	     * Execute only if the component is "enabled" : See {@link Component.enable}
	     * @param el The target on which the event will originate
	     * @param event The event for which to register an handler
	     * @param handler The function to execute when the event is triggered
	     */
	    on(el: HTMLElement, event: string, handler: Function): any;
	    on(el: Dom, event: string, handler: Function): any;
	    /**
	     * Execute the handler for the given event on the given target element.<br/>
	     * Execute only if the component is "enabled" : See {@link Component.enable}<br/>
	     * Execute the handler only ONE time
	     * @param el The target on which the event will originate
	     * @param event The event for which to register an handler
	     * @param handler The function to execute when the event is triggered
	     */
	    one(el: HTMLElement, event: string, handler: Function): any;
	    one(el: Dom, event: string, handler: Function): any;
	    /**
	     * Bind on the "root" of the Component. The root is typically the {@link SearchInterface}<br/>
	     * Bind an event using native javascript code.
	     * @param event The event for which to register an handler
	     * @param handler The function to execute when the event is triggered
	     */
	    onRootElement<T>(event: string, handler: (args: T) => any): void;
	    /**
	     * Bind on the "root" of the Component. The root is typically the {@link SearchInterface}<br/>
	     * Bind an event using native javascript code.
	     * The handler will execute only ONE time.
	     * @param event The event for which to register an handler
	     * @param handler The function to execute when the event is triggered
	     */
	    oneRootElement<T>(event: string, handler: (args: T) => any): void;
	    /**
	     * Bind an event related specially to the query state model.<br/>
	     * This will build the correct string event and execute the handler only if the component is activated.
	     * @param eventType The event type for which to register an event
	     * @param attribute The attribute for which to register an event
	     * @param handler The handler to execute when the query state event is triggered
	     */
	    onQueryState<T>(eventType: string, attribute?: string, handler?: (args: T) => any): void;
	    /**
	     * Bind an event related specially to the query state model.<br/>
	     * This will build the correct string event and execute the handler only if the component is activated.<br/>
	     * Will execute only once.
	     * @param eventType The event type for which to register an event
	     * @param attribute The attribute for which to register an event
	     * @param handler The handler to execute when the query state event is triggered
	     */
	    oneQueryState<T>(eventType: string, attribute?: string, handler?: (args: T) => any): void;
	    /**
	     * Trigger an event on the target element, with optional arguments
	     * @param el The target HTMLElement on which to trigger the event
	     * @param event The event to trigger
	     * @param args The optional argument to pass to the handlers
	     */
	    trigger(el: HTMLElement, event: string, args?: Object): any;
	    trigger(el: Dom, event: string, args?: Object): any;
	    /**
	     * Execute the function only if the component is enabled
	     * @param func The function to execute if the component is enabled
	     * @returns {function(...[any]): *}
	     */
	    private wrapToCallIfEnabled(func);
	    private getQueryStateEventName(eventType, attribute?);
	}

}
declare module Coveo {
	
	
	
	
	
	
	/**
	 * Argument sent to all handlers bound on {@link QueryEvents.newQuery}
	 */
	export interface INewQueryEventArgs {
	    /**
	     * Determine if the query is a "search as you type"
	     */
	    searchAsYouType: boolean;
	    /**
	     * If this property is set to true by any handlers, the query will not be executed.
	     */
	    cancel: boolean;
	    origin?: Component;
	}
	/**
	 * Argument sent to all handlers bound on {@link QueryEvents.buildingQuery}
	 */
	export interface IBuildingQueryEventArgs {
	    /**
	     * Allow handlers to modify the query by using the {@link QueryBuilder}
	     */
	    queryBuilder: QueryBuilder;
	    /**
	     * Determine if the query is a "search as you type"
	     */
	    searchAsYouType: boolean;
	    /**
	     * If this property is set to true by any handlers, the query will not be executed.
	     */
	    cancel: boolean;
	}
	/**
	 * Argument sent to all handlers bound on {@link QueryEvents.doneBuildingQuery}
	 */
	export interface IDoneBuildingQueryEventArgs {
	    /**
	     * Allow handlers to modify the query by using the {@link QueryBuilder}
	     */
	    queryBuilder: QueryBuilder;
	    /**
	     * Determine if the query is a "search as you type"
	     */
	    searchAsYouType: boolean;
	    /**
	     * If this property is set to true by any handlers, the query will not be executed.
	     */
	    cancel: boolean;
	}
	/**
	 * Argument sent to all handlers bound on {@link QueryEvents.duringQuery}
	 */
	export interface IDuringQueryEventArgs {
	    /**
	     * The {@link QueryBuilder} that was used for the current query
	     */
	    queryBuilder: QueryBuilder;
	    /**
	     * The query that was just executed
	     */
	    query: IQuery;
	    /**
	     * A promises for the results that will be returned by the search API
	     */
	    promise: Promise<IQueryResults>;
	    /**
	     * Determine if the query is a "search as you type"
	     */
	    searchAsYouType: boolean;
	}
	/**
	 * Argument sent to all handlers bound on {@link QueryEvents.querySuccess}
	 */
	export interface IQuerySuccessEventArgs {
	    /**
	     * The query that was just executed
	     */
	    query: IQuery;
	    /**
	     * The results returned by the query that was executed
	     */
	    results: IQueryResults;
	    /**
	     * The {@link QueryBuilder} that was used for the current query
	     */
	    queryBuilder: QueryBuilder;
	    /**
	     * Determine if the query is a "search as you type"
	     */
	    searchAsYouType: boolean;
	}
	/**
	 * Argument sent to all handlers bound on {@link QueryEvents.fetchMoreSuccess}
	 */
	export interface IFetchMoreSuccessEventArgs {
	    /**
	     * The query that was just executed
	     */
	    query: IQuery;
	    /**
	     * The results returned by the query that was executed
	     */
	    results: IQueryResults;
	    /**
	     * The {@link QueryBuilder} that was used for the current query
	     */
	    queryBuilder: QueryBuilder;
	    /**
	     * Determine if the query is a "search as you type"
	     */
	    searchAsYouType: boolean;
	}
	/**
	 * Argument sent to all handlers bound on {@link QueryEvents.queryError}
	 */
	export interface IQueryErrorEventArgs {
	    /**
	     * The {@link QueryBuilder} that was used for the current query
	     */
	    queryBuilder: QueryBuilder;
	    /**
	     * The endpoint on which the error happened.
	     */
	    endpoint: ISearchEndpoint;
	    /**
	     * The query that was just executed
	     */
	    query: IQuery;
	    /**
	     * The error info / message itself.
	     */
	    error: IEndpointError;
	    /**
	     * Determine if the query is a "search as you type"
	     */
	    searchAsYouType: boolean;
	}
	/**
	 * Argument sent to all handlers bound on {@link QueryEvents.preprocessResults}
	 */
	export interface IPreprocessResultsEventArgs {
	    /**
	     * The {@link QueryBuilder} that was used for the current query
	     */
	    queryBuilder: QueryBuilder;
	    /**
	     * The query that was just executed
	     */
	    query: IQuery;
	    /**
	     * The results returned by the query that was executed
	     */
	    results: IQueryResults;
	    /**
	     * Determine if the query is a "search as you type"
	     */
	    searchAsYouType: boolean;
	}
	/**
	 * Argument sent to all handlers bound on {@link QueryEvents.preprocessMoreResults}
	 */
	export interface IPreprocessMoreResultsEventArgs {
	    /**
	     * The results returned by the query that was executed
	     */
	    results: IQueryResults;
	}
	/**
	 * Argument sent to all handlers bound on {@link QueryEvents.noResults}
	 */
	export interface INoResultsEventArgs {
	    /**
	     * The {@link QueryBuilder} that was used for the current query
	     */
	    queryBuilder: QueryBuilder;
	    /**
	     * The query that was just executed
	     */
	    query: IQuery;
	    /**
	     * The results returned by the query that was executed
	     */
	    results: IQueryResults;
	    /**
	     * Determine if the query is a "search as you type"
	     */
	    searchAsYouType: boolean;
	    /**
	     * If set to true by any handler, the last query will automatically be re-executed again.
	     */
	    retryTheQuery: boolean;
	}
	export interface IBuildingCallOptionsEventArgs {
	    options: IEndpointCallOptions;
	}
	/**
	 * This static class is there to contains the different string definition for all the events related to query.
	 *
	 * Note that these events will only be triggered when the {@link QueryController.executeQuery} method is used, either directly or by using {@link executeQuery}
	 */
	export class QueryEvents {
	    /**
	     * Triggered when a new query is launched.
	     *
	     * All handlers bound will receive {@link INewQueryEventArgs} as an argument
	     * @type {string}
	     */
	    static newQuery: string;
	    /**
	     * Triggered when the query is being built.
	     *
	     * This is typically where all components will contribute their part to the {@link IQuery} using the {@link QueryBuilder}
	     *
	     * All handlers bound will receive {@link IBuildingQueryEventArgs} as an argument
	     * @type {string}
	     */
	    static buildingQuery: string;
	    /**
	     * Triggered when the query is done being built.
	     *
	     * This is typically where the facet will add their {@link IGroupByRequest} to the {@link IQuery}.
	     *
	     * All handlers bound will receive {@link IDoneBuildingQueryEventArgs} as an argument
	     * @type {string}
	     */
	    static doneBuildingQuery: string;
	    /**
	     * Triggered when the query is being executed on the search API.
	     *
	     * All handlers bound will receive {@link IDuringQueryEventArgs} as an argument
	     * @type {string}
	     */
	    static duringQuery: string;
	    /**
	     * Triggered when more results is being fetched on the search API (think : Infinite scrolling, or pager).
	     *
	     * All handlers bound will receive {@link IDuringQueryEventArgs} as an argument
	     * @type {string}
	     */
	    static duringFetchMoreQuery: string;
	    /**
	     * Triggered when a query successfully return from the search API.
	     *
	     * All handlers bound will receive {@link IQuerySuccessEventArgs} as an argument
	     * @type {string}
	     */
	    static querySuccess: string;
	    /**
	     * Triggered when a more results were successfully returned from the search API. (think : Infinite scrolling, or page).
	     *
	     * All handlers bound will receive {@link IFetchMoreSuccessEventArgs} as an argument
	     * @type {string}
	     */
	    static fetchMoreSuccess: string;
	    /**
	     * Triggered after the main query success event has finished executing.
	     *
	     * This is typically where facet will process the {@link IGroupByResult} and render themselves.
	     *
	     * All handlers bound will receive {@link IQuerySuccessEventArgs} as an argument
	     * @type {string}
	     */
	    static deferredQuerySuccess: string;
	    /**
	     * Triggered when there was an error executing a query on the search API.
	     *
	     * All handlers bound will receive {@link IQueryErrorEventArgs} as an argument
	     * @type {string}
	     */
	    static queryError: string;
	    /**
	     * Triggered before the {@link QueryEvents.querySuccess} event.
	     *
	     * This allow external code to modify the results before rendering them.
	     *
	     * For example, the {@link Folding} component might use this event to construct a coherent parent child relationship between query results.
	     *
	     * All handlers bound will receive {@link IPreprocessResultsEventArgs} as an argument
	     * @type {string}
	     */
	    static preprocessResults: string;
	    /**
	     * Triggered before the {@link QueryEvents.fetchMoreSuccess} event.
	     *
	     * This allow external code to modify the results before rendering them.
	     *
	     * For example, the {@link Folding} component might use this event to construct a coherent parent child relationship between query results.
	     *
	     * All handlers bound will receive {@link IPreprocessResultsEventArgs} as an argument
	     * @type {string}
	     */
	    static preprocessMoreResults: string;
	    /**
	     * Triggered when there is no results for a particular query.
	     *
	     * All handlers bound will receive {@link INoResultsEventArgs} as an argument
	     * @type {string}
	     */
	    static noResults: string;
	    static buildingCallOptions: string;
	}

}
declare module Coveo {
	/**
	 * The IPopulateOmniboxObject is an interface that is used by components to interact with the Omnibox and provides a framework for type-ahead suggestions.
	 */
	export interface IPopulateOmniboxObject {
	    /**
	     * A {@link IPopulateOmniboxQueryExpression} object used to describe the complete content of the Querybox Component.
	     */
	    completeQueryExpression: IPopulateOmniboxQueryExpression;
	    /**
	     * A {@link IPopulateOmniboxQueryExpression} object used to describe the current active content (the current position of the cursor/caret) of the omnibox Component.
	     */
	    currentQueryExpression: IPopulateOmniboxQueryExpression;
	    /**
	     * An array {@link IPopulateOmniboxQueryExpression} used to describe each part of the content of the omnibox Component.
	     */
	    allQueryExpressions: IPopulateOmniboxQueryExpression[];
	    /**
	     * The number representing the current position of the cursor/caret inside the {@link Omnibox} Component.
	     */
	    cursorPosition: number;
	    /**
	     * Clears the content of the {@link Omnibox} Component.
	     */
	    clear(): void;
	    /**
	     * Clears the current expression (current cursor position in the omnibox)
	     */
	    clearCurrentExpression(): void;
	    /**
	     * Replaces the specified searchValue by the newValue in the omnibox.
	     * @param searchValue
	     * @param newValue
	     */
	    replace(searchValue: string, newValue: string): void;
	    /**
	     * Replaces the current expression in the QueryBox (the current cursor position in the omnibox) by the newValue.
	     * @param newValue
	     */
	    replaceCurrentExpression(newValue: string): void;
	    /**
	     * Inserts new content in the omnibox at the specified position.
	     * @param at
	     * @param toInsert
	     */
	    insertAt(at: number, toInsert: string): void;
	    /**
	     * Closes the Omnibox.
	     */
	    closeOmnibox(): void;
	}
	/**
	 * This object is a simple interface that describes the content of an omnibox query expression
	 */
	export interface IPopulateOmniboxQueryExpression {
	    /**
	     * This is a simple string with the plain content of the {@link Omnibox}.
	     */
	    word: string;
	    /**
	     * This is a regex of the content of the {@link Omnibox} with some special character escaped.
	     */
	    regex: RegExp;
	}
	export interface IOmniboxData extends IPopulateOmniboxObject {
	    rows: IOmniboxDataRow[];
	}
	/**
	 * The content that external code that wants to populate the omnibox need to populate
	 */
	export interface IOmniboxDataRow {
	    /**
	     * This is an optional property. It is used by each component to influence their rendering order in the Omnibox. It works like a normal CSS zIndex: higher value will render at the top most level. Providing no zIndex will make your item render with a low priority.
	     */
	    zIndex?: number;
	    /**
	     * This an HTMLElement that you want the Omnibox to render.
	     *
	     * It can be any valid HTML element (div, span, image, table, etc.). You can bind any event you want to this element and also add logic to handle the Omnibox (eg. should the Omnibox close itself when clicking on your suggestion, should the Omnibox clear itself ?).
	     *
	     * This element you provide can be as complex as you want it to be (see Providing Suggestions for the Omnibox).
	     */
	    element?: HTMLElement;
	    /**
	     * This is a Promise object. It is used when you want to make an asynchronous call (most likely an Ajax request) to a service in order to retrieve the data that you will use to build your HTML content.
	     */
	    deferred?: Promise<IOmniboxDataRow>;
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	
	
	export class ValueElementRenderer {
	    facet: Facet;
	    facetValue: FacetValue;
	    listElement: HTMLElement;
	    label: HTMLElement;
	    checkbox: HTMLElement;
	    stylishCheckbox: HTMLElement;
	    valueCaption: HTMLElement;
	    valueCount: HTMLElement;
	    icon: HTMLElement;
	    excludeIcon: HTMLElement;
	    computedField: HTMLElement;
	    constructor(facet: Facet, facetValue: FacetValue);
	    withNo(element: HTMLElement[]): ValueElementRenderer;
	    withNo(element: HTMLElement): ValueElementRenderer;
	    build(): ValueElementRenderer;
	    setCssClassOnListValueElement(): void;
	    protected buildExcludeIcon(): HTMLElement;
	    protected buildValueComputedField(): HTMLElement;
	    protected buildValueCheckbox(): HTMLElement;
	    protected buildValueStylishCheckbox(): HTMLElement;
	    protected buildValueIcon(): HTMLElement;
	    protected getValueIcon(): string;
	    protected buildValueIconFromSprite(): HTMLElement;
	    protected buildValueCaption(): HTMLElement;
	    protected buildValueCount(): HTMLElement;
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	
	
	
	
	
	export interface IValueElementKlass {
	    new (facet: Facet, facetValue: FacetValue): ValueElement;
	}
	export interface IValueElementEventsBinding {
	    displayNextTime: boolean;
	    pinFacet: boolean;
	    omniboxObject?: IPopulateOmniboxObject;
	}
	export class ValueElement {
	    facet: Facet;
	    facetValue: FacetValue;
	    onSelect: (elem: ValueElement, cause: IAnalyticsActionCause) => void;
	    onExclude: (elem: ValueElement, cause: IAnalyticsActionCause) => void;
	    renderer: ValueElementRenderer;
	    private isOmnibox;
	    constructor(facet: Facet, facetValue: FacetValue, onSelect?: (elem: ValueElement, cause: IAnalyticsActionCause) => void, onExclude?: (elem: ValueElement, cause: IAnalyticsActionCause) => void);
	    build(): ValueElement;
	    bindEvent(eventBindings: IValueElementEventsBinding): void;
	    select(): void;
	    unselect(): void;
	    exclude(): void;
	    unexclude(): void;
	    protected handleSelectValue(eventBindings: IValueElementEventsBinding): void;
	    protected handleExcludeClick(eventBindings: IValueElementEventsBinding): void;
	    protected handleEventForExcludedValueElement(eventBindings: IValueElementEventsBinding): void;
	    protected handleEventForValueElement(eventBindings: IValueElementEventsBinding): void;
	    protected handleEventForCheckboxChange(eventBindings: IValueElementEventsBinding): void;
	    protected omniboxCloseEvent(eventArg: IPopulateOmniboxObject): void;
	    private getAnalyticsFacetMeta();
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	
	
	
	export interface IFacetValueElementKlass {
	    new (facet: Facet, facetValue: FacetValue, displayNextTime?: boolean): FacetValueElement;
	}
	export class FacetValueElement extends ValueElement {
	    facet: Facet;
	    facetValue: FacetValue;
	    keepDisplayedValueNextTime: boolean;
	    private firstQuery;
	    constructor(facet: Facet, facetValue: FacetValue, keepDisplayedValueNextTime: boolean);
	    bindEvent(): void;
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	
	export class FacetUtils {
	    static getRegexToUseForFacetSearch(value: string, ignoreAccent: boolean): RegExp;
	    static getValuesToUseForSearchInFacet(original: string, facet: Facet): string[];
	    static buildFacetSearchPattern(values: string[]): string;
	    static needAnotherFacetSearch(currentSearchLength: number, newSearchLength: number, oldSearchLength: number, desiredSearchLength: number): boolean;
	    static addNoStateCssClassToFacetValues(facet: Facet, container: HTMLElement): void;
	    static tryToGetTranslatedCaption(field: string, value: string): string;
	    static clipCaptionsToAvoidOverflowingTheirContainer(facet: Facet, forceClip?: boolean): void;
	}

}
declare module Coveo {
	/// <reference path="../ui/FacetSlider/FacetSlider.d.ts" />
	
	
	
	export class FacetSliderQueryController {
	    facet: FacetSlider;
	    graphGroupByQueriesIndex: number;
	    private rangeValuesForGraphToUse;
	    lastGroupByRequestIndex: number;
	    constructor(facet: FacetSlider);
	    prepareForNewQuery(): void;
	    putGroupByIntoQueryBuilder(queryBuilder: QueryBuilder): void;
	    createBasicGroupByRequest(allowedValues?: string[], addComputedField?: boolean): IGroupByRequest;
	    computeOurFilterExpression(boundary?: number[]): string;
	    private handleQuerySuccess(args);
	    private addFilterExpressionWithOuterBoundsIncluded(start, end, builder);
	    private addFilterExpressionWithOuterBoundsExcluded(start, end, builder);
	    private buildGroupByQueryForSlider(groupByQuery);
	    private buildGroupByQueryForAutomaticRanges(groupByQuery);
	    private putGroupByForGraphIntoQueryBuilder(queryBuilder);
	    private putGroupByForSliderIntoQueryBuilder(queryBuilder);
	    private createRangeValuesForGraph(basicRangeRequest);
	    private usePrebuiltRange(basicRangeRequest);
	    private buildRange(basicRangeRequest);
	    private getISOFormat(value);
	    private getFilterDateFormat(rawValue);
	    private getBrowserCompatibleFormat(value);
	}

}
declare module Coveo {
	export interface IGraphValueSelectedArgs {
	    start: any;
	    end: any;
	    value: any;
	}
	export class SliderEvents {
	    static startSlide: string;
	    static duringSlide: string;
	    static endSlide: string;
	    static graphValueSelected: string;
	}

}
declare module Coveo {
	/// <reference path="../../../../lib/d3.d.ts" />
	export interface IStartSlideEventArgs {
	    slider: Slider;
	    button: SliderButton;
	}
	export interface IDuringSlideEventArgs {
	    slider: Slider;
	    button: SliderButton;
	}
	export interface IEndSlideEventArgs {
	    slider: Slider;
	    button: SliderButton;
	}
	export interface ISliderGraphData {
	    start: any;
	    y: number;
	    end: any;
	    isDate?: boolean;
	}
	export interface ISliderOptions {
	    start?: any;
	    end?: any;
	    excludeOuterBounds?: boolean;
	    steps?: number;
	    getSteps?: (start: number, end: number) => number[];
	    rangeSlider?: boolean;
	    displayAsValue?: {
	        enable?: boolean;
	        unitSign?: string;
	        separator?: string;
	    };
	    displayAsPercent?: {
	        enable?: boolean;
	        separator?: string;
	    };
	    valueCaption?: (values: number[]) => string;
	    percentCaption?: (percent: number[]) => string;
	    dateFormat?: string;
	    document?: Document;
	    graph?: {
	        steps?: number;
	        animationDuration?: number;
	        margin?: {
	            top?: number;
	            bottom?: number;
	            left?: number;
	            right?: number;
	        };
	    };
	    dateField?: boolean;
	    rounded?: number;
	}
	export class Slider {
	    element: HTMLElement;
	    options: ISliderOptions;
	    root: HTMLElement;
	    steps: number[];
	    currentValues: number[];
	    private sliderButton;
	    private sliderRange;
	    private sliderLine;
	    private sliderCaption;
	    private sliderGraph;
	    constructor(element: HTMLElement, options: ISliderOptions, root: HTMLElement);
	    onMoving(): void;
	    initializeState(values?: number[]): void;
	    getPosition(): number[];
	    getPercentPosition(): number[];
	    getValues(): any[];
	    getCaptionFromValue(values: number[]): string;
	    getCaption(): string;
	    setValues(values: number[]): void;
	    drawGraph(data?: ISliderGraphData[]): void;
	    private setButtonBoundary();
	    private displayCaption();
	    private buildSteps();
	}
	export class SliderButton {
	    slider: Slider;
	    private which;
	    leftBoundary: number;
	    rightBoundary: number;
	    element: HTMLElement;
	    private currentPos;
	    private startPositionX;
	    private isMouseDown;
	    private lastElementLeft;
	    private origUserSelect;
	    private origCursor;
	    private origZIndex;
	    private eventMouseDown;
	    private eventMouseMove;
	    private eventMouseUp;
	    constructor(slider: Slider, which: number);
	    build(): HTMLElement;
	    toBeginning(): void;
	    toEnd(): void;
	    setValue(value: number): void;
	    getPosition(): number;
	    getPercent(position?: number): number;
	    getValue(): any;
	    fromValueToPercent(value: number): number;
	    fromPositionToValue(position: number): any;
	    fromValueToPosition(value: number): number;
	    private bindEvents();
	    private getUserSelect();
	    private handleStartSlide(e);
	    private handleMoving(e);
	    private handleEndSlide();
	    private handleButtonNearEnd();
	    private getMousePosition(e);
	    private updatePosition(e);
	    private snapToStep(spanX);
	}

}
declare module Coveo {
	export interface IPosition {
	    vertical: VerticalAlignment;
	    horizontal: HorizontalAlignment;
	    verticalOffset?: number;
	    horizontalOffset?: number;
	    horizontalClip?: boolean;
	}
	export enum VerticalAlignment {
	    TOP = 0,
	    MIDDLE = 1,
	    BOTTOM = 2,
	    INNERTOP = 3,
	    INNERBOTTOM = 4,
	}
	export enum HorizontalAlignment {
	    LEFT = 0,
	    CENTER = 1,
	    RIGHT = 2,
	    INNERLEFT = 3,
	    INNERRIGHT = 4,
	}
	export class PopupUtils {
	    static positionPopup(popUp: HTMLElement, nextTo: HTMLElement, boundary: HTMLElement, desiredPosition: IPosition, appendTo?: HTMLElement, checkForBoundary?: number): void;
	    private static finalAdjustement(popUpOffSet, popUpPosition, popUp, desiredPosition);
	    private static basicVerticalAlignment(popUpPosition, popUp, nextTo, desiredPosition);
	    private static basicHorizontalAlignment(popUpPosition, popUp, nextTo, desiredPosition);
	    private static alignInsideBoundary(oldPosition, checkBoundary);
	    private static offSetToAlignCenter(popUp, nextTo);
	    private static getBoundary(element);
	    private static checkForOutOfBoundary(popUpBoundary, boundary);
	}

}
declare module Coveo {
	export class EventsUtils {
	    private static prefixes;
	    static addPrefixedEvent(element: HTMLElement, pascalCaseEventName: string, callback: any): void;
	    static removePrefixedEvent(element: HTMLElement, pascalCaseEventName: string, callback: any): void;
	}

}
declare module Coveo {
	
	export class ResponsiveComponentsUtils {
	    private static smallTabsClassName;
	    private static smallFacetClassName;
	    static MEDIUM_MOBILE_WIDTH: number;
	    static isSmallTabsActivated(root: Dom): boolean;
	    static isSmallFacetActivated(root: Dom): boolean;
	    static activateSmallTabs(root: Dom): void;
	    static deactivateSmallTabs(root: Dom): void;
	    static activateSmallFacet(root: Dom): void;
	    static deactivateSmallFacet(root: Dom): void;
	}

}
declare module Coveo {
	
	
	
	export class ResponsiveTabs implements IResponsiveComponent {
	    ID: string;
	    private static logger;
	    private dropdownHeader;
	    private dropdownContent;
	    private tabSection;
	    private previousSibling;
	    private parent;
	    private searchBoxElement;
	    private coveoRoot;
	    private documentClickListener;
	    private searchInterface;
	    constructor(root: Dom, ID: string);
	    static init(root: HTMLElement, component: Component, options: IResponsiveComponentOptions): void;
	    handleResizeEvent(): void;
	    needSmallMode(): boolean;
	    changeToSmallMode(): void;
	    changeToLargeMode(): void;
	    private shouldAddTabsToDropdown();
	    private addTabsToDropdown(tabs);
	    private shouldRemoveTabsFromDropdown();
	    private removeTabsFromDropdown(tabs);
	    private emptyDropdown();
	    private isLargeFormatOverflowing();
	    private isOverflowing(el);
	    private buildDropdownHeader();
	    private bindDropdownHeaderEvents();
	    private buildDropdownContent();
	    private bindDropdownContentEvents();
	    private closeDropdown();
	    private addToDropdown(el);
	    private removeFromDropdown(el);
	    private cleanUpDropdown();
	    private isDropdownEmpty();
	    private manageTabSwapping();
	    private getSearchBoxElement();
	    private saveTabsPosition();
	    private bindNukeEvents();
	    private positionPopup();
	    private getTabsInTabSection();
	    private fromDropdownToTabSection(tab, lastTabInTabSection);
	}

}
declare module Coveo {
	
	
	
	
	export interface ITabOptions {
	    expression?: string;
	    constant?: boolean;
	    id?: string;
	    icon?: string;
	    caption?: string;
	    sort?: string;
	    endpoint?: SearchEndpoint;
	    enableDuplicateFiltering?: boolean;
	    pipeline?: string;
	    maximumAge?: number;
	    enableResponsiveMode?: boolean;
	}
	/**
	 * This component is a bar allowing users to select a search interface.
	 *
	 * The component attaches itself to an div element and is in charge of adding an advanced expression to the query and thus, modify the outgoing query in order to refine the results in relation to the selected tab.
	 *
	 * It also allows to hide and show different parts of the UI. In order to do so, each component of the UI can specify whether or not it wishes to be included or excluded from a specific tab.
	 *
	 * # Including and excluding other HTML components
	 *
	 * You can hide/show specific HTML components, based on the currently selected search tab by adding the following attributes:
	 *
	 * * `<div data-tab="foobar">` -> Include this element only in the tab with the id 'foobar'.
	 *
	 * * `<div data-tab-not="foobar">` -> DO NOT include this element in the tab id 'foobar'.
	 *
	 * * `<div data-tab="foobar,somethingelse">` -> Include this element only in the tab with the id 'foobar' or 'somethingelse'.
	 *
	 * # Setting a new endpoint for a tab
	 * A tab can use a custom endpoint when performing a query. First, you need to make sure that the endpoint exists in the array of Coveo.SearchEndpoint.endpoints.
	 *
	 * ```
	 * Coveo.SearchEndpoint.endpoints["specialEndpoint"] = new Coveo.SearchEndpoint({
	 *     restUri : 'https://somewhere.com/rest/search'
	 * })
	 *
	 * [...]
	 *
	 * <div class='CoveoTab' data-endpoint='specialEndpoint'></div>
	 *
	 * ```
	 */
	export class Tab extends Component {
	    element: HTMLElement;
	    options: ITabOptions;
	    static ID: string;
	    /**
	     * The options for a Tab
	     * @componentOptions
	     */
	    static options: ITabOptions;
	    private isFirstQuery;
	    /**
	     * Create a new Tab. Bind on buildingQuery event as well as on click of the element
	     * @param element The HTMLElement on which to create a new tab. Normally a div
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: ITabOptions, bindings?: IComponentBindings);
	    /**
	     * Select the current tab.<br/>
	     * Trigger a query and log an analytics event.
	     */
	    select(): void;
	    /**
	     * Check if the given HTMLElement is included or not in this tab
	     * @param element The element to verify
	     * @returns {boolean}
	     */
	    isElementIncludedInTab(element: HTMLElement): boolean;
	    private handleClick();
	    private render();
	    protected handleBuildingQuery(data: IBuildingQueryEventArgs): void;
	    private handleQueryStateChanged(data);
	    protected isSelected(): boolean;
	    private showAndHideAppropriateElements();
	    private splitListOfTabs(value);
	    private toggleAllComponentsUnder(element, enable);
	    enable(): void;
	    disable(): void;
	}

}
declare module Coveo {
	
	
	export interface IResponsiveComponentOptions {
	    enableResponsiveMode?: boolean;
	    responsiveBreakpoint?: number;
	}
	export interface IResponsiveComponentConstructor {
	    new (root: Dom, ID: string, options: IResponsiveComponentOptions): IResponsiveComponent;
	}
	export interface IResponsiveComponent {
	    ID: string;
	    handleResizeEvent(): void;
	    needTabSection?(): boolean;
	}
	export class ResponsiveComponentsManager {
	    private static componentManagers;
	    private static remainingComponentInitializations;
	    private disabledComponents;
	    private coveoRoot;
	    private resizeListener;
	    private responsiveComponents;
	    private tabSection;
	    private searchBoxElement;
	    private createdTabSection;
	    private responsiveFacets;
	    private tabSectionPreviousSibling;
	    private tabSectionParent;
	    static register(responsiveComponentConstructor: IResponsiveComponentConstructor, root: Dom, ID: string, component: Component, options: IResponsiveComponentOptions): void;
	    private static shouldEnableResponsiveMode(root);
	    private static resizeAllComponentsManager();
	    constructor(root: Dom);
	    register(responsiveComponentConstructor: IResponsiveComponentConstructor, root: Dom, ID: string, component: Component, options: IResponsiveComponentOptions): void;
	    disableComponent(ID: string): void;
	    private isDisabled(ID);
	    private shouldRegisterComponent(ID, options);
	    private shouldSwitchToSmallMode();
	    private shouldExitSmallMode();
	    private needTabSection();
	    private ensureTabSectionInDom();
	    private restoreTabSectionPosition();
	    private saveTabSectionPosition();
	    private isFacet(ID);
	    private isTabs(ID);
	    private isActivated(ID);
	    private getSearchBoxElement();
	    private bindNukeEvents();
	}

}
declare module Coveo {
	
	
	
	export class ResponsiveFacets implements IResponsiveComponent {
	    root: Dom;
	    private static ACTIVE_FACET_HEADER_Z_INDEX;
	    private static FACET_DROPDOWN_MIN_WIDTH;
	    private static FACET_DROPDOWN_WIDTH_RATIO;
	    private static TRANSPARENT_BACKGROUND_OPACITY;
	    private static DEBOUNCE_SCROLL_WAIT;
	    private static ROOT_MIN_WIDTH;
	    private static logger;
	    ID: string;
	    coveoRoot: Dom;
	    private dropdownContent;
	    private previousSibling;
	    private parent;
	    private dropdownHeader;
	    private popupBackground;
	    private popupBackgroundClickListener;
	    private facets;
	    private facetSliders;
	    private searchInterface;
	    private breakpoint;
	    static init(root: HTMLElement, component: any, options: IResponsiveComponentOptions): void;
	    constructor(root: Dom, ID: string, options: IResponsiveComponentOptions);
	    needSmallMode(): boolean;
	    changeToSmallMode(): void;
	    changeToLargeMode(): void;
	    registerComponent(component: Component): void;
	    needTabSection(): boolean;
	    handleResizeEvent(): void;
	    private triggerFacetSliderDraw();
	    private buildDropdownContent();
	    private buildDropdownHeader();
	    private bindDropdownHeaderEvents();
	    private bindDropdownContentEvents();
	    private buildPopupBackground();
	    private saveFacetsPosition();
	    private restoreFacetsPosition();
	    private openDropdown();
	    private positionPopup();
	    private closeDropdown();
	    private dismissFacetSearches();
	    private cleanUpDropdown();
	    private enableFacetPreservePosition();
	    private disableFacetPreservePosition();
	    private bindNukeEvents();
	    private drawFacetSliderGraphs();
	    private isFacetSearchScrolledIntoView(facetSearchElement);
	}

}
declare module Coveo {
	export class FeatureDetectionUtils {
	    static supportSVG(): boolean;
	}

}
declare module Coveo {
	/**
	 * Represent an item to insert in the breadcrumb
	 */
	export interface IBreadcrumbItem {
	    /**
	     * The HTMLElement to insert in the breadcrumb
	     */
	    element: HTMLElement;
	}
	/**
	 * Event triggered when populating the breadcrumb
	 */
	export interface IPopulateBreadcrumbEventArgs {
	    breadcrumbs: IBreadcrumbItem[];
	}
	export interface IClearBreadcrumbEventArgs {
	}
	/**
	 * This static class is there to contains the different string definition for all the events related to {@link Breadcrumb}.
	 */
	export class BreadcrumbEvents {
	    /**
	     * Triggered when the breadcrumb needs to update its content. External code can use this event to provide bits of HTML that should be included in the breadcrumb.
	     *
	     * All handlers bound to this event will receive a {@link IPopulateBreadcrumbEventArgs} as an argument.
	     */
	    static populateBreadcrumb: string;
	    /**
	     * Triggered when the user clicks the Clear All button in the breadcrumb. When this event is raised, every filter that is included in the breadcrumb should be removed.
	     *
	     * This event does not provide custom event data.
	     */
	    static clearBreadcrumb: string;
	    static redrawBreadcrumb: string;
	}

}
declare module Coveo {
	/// <reference path="../Facet/FacetHeader.d.ts" />
	/// <reference path="../../controllers/FacetSliderQueryController.d.ts" />
	
	
	
	
	
	export interface IFacetSliderOptions extends ISliderOptions {
	    dateField?: boolean;
	    queryOverride?: string;
	    id?: string;
	    field?: string;
	    title?: string;
	    enableResponsiveMode?: boolean;
	    responsiveBreakpoint?: number;
	}
	/**
	 * The FacetSlider component allows to create a facet that renders a slider widget to filter on a range of numerical values
	 * rather than the classic multi-select facet with a label and a count for each values.<br/>
	 * Note that this component does *NOT* inherit from a standard {@link Facet}, and thus does not offer all the same options.
	 * Also note that many options for the slider component cannot be set as an HTML attribute on the component, and must be configured in javascript
	 *
	 * ## A generic example on how to initialize a complex slider
	 * ```
	 * // Using a JSON object inside the init call. Note that the JSON object follows the options described in this page.
	 * Coveo.init(document.querySelector('#search'), {
	 *    FacetSlider: {
	 *      field: "@size",
	 *      start: 1000,
	 *      end: 5000,
	 *      rangeSlider: true,
	 *      graph: {
	 *        steps: 10
	 *      }
	 *    }
	 * })
	 *
	 * // OR using the jquery extension
	 *
	 * $('#search').coveo('init', {
	 *    FacetSlider: {
	 *      field: "@size",
	 *      start: 1000,
	 *      end: 5000,
	 *      rangeSlider: true,
	 *      graph: {
	 *        steps: 10
	 *      }
	 *    }
	 * })
	 *
	 * // Same config, but using attribute directly on the element instead
	 * <div class='CoveoFacetSlider' data-field='@syssize' data-start='1000' data-end='5000' data-range-slider='true' data-graph-steps='10'></div>
	 * ```
	 */
	export class FacetSlider extends Component {
	    element: HTMLElement;
	    options: IFacetSliderOptions;
	    /**
	     * The component options
	     * @componentOptions
	     */
	    static options: IFacetSliderOptions;
	    static ID: string;
	    startOfSlider: number;
	    endOfSlider: number;
	    initialStartOfSlider: number;
	    initialEndOfSlider: number;
	    facetQueryController: FacetSliderQueryController;
	    facetHeader: FacetHeader;
	    private slider;
	    private rangeQueryStateAttribute;
	    private isEmpty;
	    private rangeFromUrlState;
	    private delayedGraphData;
	    private onResize;
	    constructor(element: HTMLElement, options: IFacetSliderOptions, bindings?: IComponentBindings);
	    createDom(): void;
	    /**
	     * Reset the facet. This means set the range value as inactive.
	     */
	    reset(): void;
	    /**
	     * Return the current selection in the facet, as an array of number (eg : [start, end] ).<br/>
	     * If it's not available, return [undefined, undefined]
	     * @returns {any}
	     */
	    getSelectedValues(): number[];
	    /**
	     * Set the selected values in the slider.
	     * @param values [start, end]
	     */
	    setSelectedValues(values: number[]): void;
	    /**
	     * Return true if the slider is "active" (will output an expression in the query when a search is performed)
	     * @returns {boolean}
	     */
	    isActive(): boolean;
	    getSliderBoundaryForQuery(): number[];
	    drawDelayedGraphData(): void;
	    private handleNoresults();
	    private handleNewQuery();
	    private handleRangeQueryStateChanged(args);
	    private handlePopulateBreadcrumb(args);
	    private buildBreadcrumbFacetSlider();
	    private initSlider();
	    private initQueryStateEvents();
	    private setRangeStateSliderStillNotCreated(args);
	    private buildSlider();
	    private handleBuildingQuery(data);
	    private handleDoneBuildingQuery(data);
	    private handleDeferredQuerySuccess(data);
	    private handleEndSlide(args);
	    private handleDuringSlide(args);
	    private handleGraphValueSelected(args);
	    private updateQueryState(values?, silent?);
	    private copyValues(values);
	    private renderToSliderGraph(data);
	    private isFacetDropdownHidden();
	    private generateBoundary();
	    private generateBoundaryFromSlider();
	    private generateBoundaryFromState();
	    private setupSliderIfNeeded(data);
	    private verifySetup();
	    private setupSliderStateVariables();
	    private alreadySetBoundary();
	    private trySetSliderBoundaryFromOptions();
	    private trySetSliderBoundaryFromState();
	    private trySetSliderBoundaryFromQueryResult(data);
	    private setupInitialSliderStateStart(value);
	    private setupInitialSliderStateEnd(value);
	    private hasAGraph();
	    private updateAppearanceDependingOnState(sliding?);
	    private handleNuke();
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	/// <reference path="FacetSettings.d.ts" />
	
	
	
	
	export interface IFacetHeaderOptions {
	    facetElement: HTMLElement;
	    title: string;
	    field: string;
	    enableClearElement: boolean;
	    enableCollapseElement: boolean;
	    icon?: string;
	    facet?: Facet;
	    facetSlider?: FacetSlider;
	    settingsKlass?: IFacetSettingsKlass;
	    sortKlass?: IFacetSortKlass;
	    availableSorts?: string[];
	    isNewDesign: boolean;
	}
	export class FacetHeader {
	    options: IFacetHeaderOptions;
	    element: HTMLElement;
	    iconElement: HTMLElement;
	    waitElement: HTMLElement;
	    collapseElement: HTMLElement;
	    expandElement: HTMLElement;
	    operatorElement: HTMLElement;
	    eraserElement: HTMLElement;
	    settings: FacetSettings;
	    sort: FacetSort;
	    constructor(options: IFacetHeaderOptions);
	    build(): HTMLElement;
	    switchToAnd(): void;
	    switchToOr(): void;
	    collapseFacet(): void;
	    expandFacet(): void;
	    updateOperatorQueryStateModel(): void;
	    private rebuildOperatorToggle();
	    private buildIcon();
	    private buildWaitAnimation();
	    private buildCollapse();
	    private buildExpand();
	    private buildOperatorToggle();
	    private handleOperatorClick();
	    private buildTitle();
	    buildEraser(): HTMLElement;
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	/// <reference path="FacetSort.d.ts" />
	/// <reference path="FacetHeader.d.ts" />
	
	
	export interface IFacetSettingsKlass {
	    new (sorts: string[], facet: Facet): FacetSettings;
	}
	export interface IFacetState {
	    included: string[];
	    excluded: string[];
	    operator: string;
	}
	/**
	 * Handle the rendering of the {@link Facet} settings menu (typically the ... in the facet header)
	 */
	export class FacetSettings extends FacetSort {
	    sorts: string[];
	    facet: Facet;
	    loadedFromSettings: {
	        [attribute: string]: any;
	    };
	    private facetStateLocalStorage;
	    private includedStateAttribute;
	    private excludedStateAttribute;
	    private operatorStateAttribute;
	    private settingsPopup;
	    private settingsIcon;
	    private settingsButton;
	    private directionSection;
	    private saveStateSection;
	    private clearStateSection;
	    private hideSection;
	    private showSection;
	    private sortSection;
	    private customSortDirectionChange;
	    private enabledSortsIgnoreRenderBecauseOfPairs;
	    constructor(sorts: string[], facet: Facet);
	    /**
	     * Build the menu, hook click events
	     * @returns {HTMLElement}
	     */
	    build(): HTMLElement;
	    /**
	     * Restore the facet state from local storage, and apply it in the query state model
	     */
	    loadSavedState(): void;
	    /**
	     * Take the current state of the facet and save it in the local storage
	     */
	    saveState(): void;
	    /**
	     * Close the settings menu
	     */
	    close(): void;
	    /**
	     * Open the settings menu
	     */
	    open(): void;
	    private buildSortSection();
	    private buildSortSectionItems();
	    private closePopupAndUpdateSort();
	    private enabledSortsAllowDirection();
	    private buildDirectionSection();
	    private buildSaveStateSection();
	    private buildClearStateSection();
	    private buildHideSection();
	    private buildShowSection();
	    private buildIcon();
	    private buildAscendingOrDescending(direction);
	    private buildAscendingOrDescendingSection(direction);
	    private buildItem(label, title?);
	    private buildItems();
	    private buildSection(className);
	    private handleClickSettingsButtons(event, sortSection?);
	    private handleClickSortButton(e, enabledSort);
	    private handleDirectionClick(e, direction);
	    private handleSaveStateClick();
	    private handleClearStateClick();
	    private handleMouseEventOnButton(sortSection);
	    getCurrentDirectionItem(directionSection?: HTMLElement[]): HTMLElement;
	    private activateDirectionSection();
	    private disableDirectionSection();
	    private getItems(section);
	    private unselectSection(section);
	    private selectItem(item);
	    private unselectItem(item);
	    private getPopupAlignment();
	    private filterDuplicateForRendering();
	    private appendIfNotUndefined(toAppend);
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	/// <reference path="FacetSettings.d.ts" />
	
	export interface IFacetSortKlass {
	    new (sorts: string[], facet: Facet): FacetSort;
	}
	export interface IFacetSortDescription {
	    label: string;
	    directionToggle: boolean;
	    description: string;
	    name: string;
	    relatedSort?: string;
	}
	export class FacetSort {
	    facet: Facet;
	    static availableSorts: {
	        [name: string]: IFacetSortDescription;
	    };
	    enabledSorts: IFacetSortDescription[];
	    activeSort: IFacetSortDescription;
	    customSortDirection: string;
	    constructor(sorts: string[], facet: Facet);
	    private removeEnabledSortsBasedOnFacetType();
	}

}
declare module Coveo {
	
	
	
	
	export class FacetValuesOrder {
	    facet: Facet;
	    facetSort: FacetSort;
	    constructor(facet: Facet, facetSort: FacetSort);
	    reorderValues(facetValues: IIndexFieldValue[]): IIndexFieldValue[];
	    reorderValues(facetValues: FacetValue[]): FacetValue[];
	    private reorderValuesWithCustomOrder(facetValues);
	    private reorderValuesWithCustomCaption(facetValues);
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	
	
	
	
	export class FacetValuesList {
	    facet: Facet;
	    facetValueElementKlass: IFacetValueElementKlass;
	    private valueList;
	    valueContainer: HTMLElement;
	    private currentlyDisplayed;
	    constructor(facet: Facet, facetValueElementKlass: IFacetValueElementKlass);
	    build(): HTMLElement;
	    getAllCurrentlyDisplayed(): ValueElement[];
	    getAll(): ValueElement[];
	    getAllFacetValue(): FacetValue[];
	    get(value: FacetValue): ValueElement;
	    get(value: string): ValueElement;
	    select(value: FacetValue): ValueElement;
	    select(value: string): ValueElement;
	    unselect(value: FacetValue): ValueElement;
	    unselect(value: string): ValueElement;
	    exclude(value: FacetValue): ValueElement;
	    exclude(value: string): ValueElement;
	    unExclude(value: FacetValue): ValueElement;
	    unExclude(value: string): ValueElement;
	    toggleSelect(value: FacetValue): ValueElement;
	    toggleSelect(value: string): ValueElement;
	    toggleExclude(value: FacetValue): ValueElement;
	    toggleExclude(value: string): ValueElement;
	    rebuild(numberOfValues: number): void;
	    protected getValuesToBuildWith(): FacetValue[];
	    private facetValueShouldBeRemoved(facetValue);
	    private ensureFacetValueIsInList(value);
	}

}
declare module Coveo {
	/// <reference path="HierarchicalFacet.d.ts" />
	
	
	
	
	export class HierarchicalFacetValuesList extends FacetValuesList {
	    facet: HierarchicalFacet;
	    facetValueElementKlass: IFacetValueElementKlass;
	    hierarchyFacetValues: FacetValue[];
	    constructor(facet: HierarchicalFacet, facetValueElementKlass: IFacetValueElementKlass);
	    protected getValuesToBuildWith(): FacetValue[];
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	
	
	
	export class FacetSearchParameters {
	    facet: Facet;
	    searchEvenIfEmpty: boolean;
	    nbResults: number;
	    ignoreAccents: boolean;
	    valueToSearch: string;
	    alwaysInclude: string[];
	    alwaysExclude: string[];
	    sortCriteria: string;
	    fetchMore: boolean;
	    constructor(facet: Facet);
	    setValueToSearch(value: string): this;
	    excludeCurrentlyDisplayedValuesInSearch(searchResults: HTMLElement): void;
	    getGroupByRequest(): IGroupByRequest;
	    getQuery(): IQuery;
	    private getCurrentlyShowedValueInSearch(searchResults);
	    private lowerCaseAll();
	}

}
declare module Coveo {
	export enum KEYBOARD {
	    BACKSPACE = 8,
	    TAB = 9,
	    ENTER = 13,
	    SHIFT = 16,
	    CTRL = 17,
	    ALT = 18,
	    ESCAPE = 27,
	    SPACEBAR = 32,
	    PAGE_UP = 33,
	    PAGE_DOWN = 34,
	    HOME = 36,
	    LEFT_ARROW = 37,
	    UP_ARROW = 38,
	    RIGHT_ARROW = 39,
	    DOWN_ARROW = 40,
	    INSERT = 45,
	    DELETE = 46,
	}
	export class KeyboardUtils {
	    static keysEqual(key: any, code: any): boolean;
	    static isAllowedKeyForOmnibox(e: KeyboardEvent): boolean;
	    static isAllowedKeyForSearchAsYouType(e: KeyboardEvent): boolean;
	    static isDeleteOrBackspace(e: KeyboardEvent): boolean;
	    static isArrowKeyPushed(keycode: number): boolean;
	    static isNumberKeyPushed(keycode: number): boolean;
	    static isLetterKeyPushed(keycode: number): boolean;
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	
	
	
	export interface IFacetSearchValuesListKlass {
	    new (facet: Facet, facetValueElementKlass: IFacetValueElementKlass): FacetSearchValuesList;
	}
	export class FacetSearchValuesList {
	    facet: Facet;
	    facetValueElementKlass: IFacetValueElementKlass;
	    constructor(facet: Facet, facetValueElementKlass: IFacetValueElementKlass);
	    build(facetValues: FacetValue[]): HTMLElement[];
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	
	
	
	/**
	 * Used by the {@link Facet} component to render and handle the facet search part of each facet.
	 */
	export class FacetSearch {
	    facet: Facet;
	    facetSearchValuesListKlass: IFacetSearchValuesListKlass;
	    private root;
	    currentlyDisplayedResults: string[];
	    searchResults: HTMLElement;
	    search: HTMLElement;
	    private magnifier;
	    private wait;
	    private clearIcon;
	    private clear;
	    private middle;
	    private input;
	    private facetSearchTimeout;
	    private showingFacetSearchWaitAnimation;
	    private facetSearchPromise;
	    private moreValuesToFetch;
	    private onResize;
	    private onDocumentClick;
	    private searchBarIsAnimating;
	    constructor(facet: Facet, facetSearchValuesListKlass: IFacetSearchValuesListKlass, root: HTMLElement);
	    isMobileDevice(): boolean;
	    /**
	     * Build the search component and return an HTMLElement which can be appended to the {@link Facet}
	     * @returns {HTMLElement}
	     */
	    build(): HTMLElement;
	    /**
	     * Position the search results at the footer of the facet.
	     */
	    positionSearchResults(nextTo?: HTMLElement): void;
	    completelyDismissSearch(): void;
	    /**
	     * Trigger a new facet search, and display the results
	     * @param params
	     */
	    triggerNewFacetSearch(params: FacetSearchParameters): void;
	    /**
	     * Trigger the event associated with the focus of the search input
	     */
	    focus(): void;
	    private shouldPositionSearchResults();
	    private buildBaseSearch();
	    private buildSearchMobile();
	    private handleFacetSearchKeyUp(event);
	    private handleNuke();
	    private handleFacetSearchFocus();
	    private handleClickElsewhere(event);
	    private handleFacetSearchClear();
	    private showOrHideClearElement(isEmpty);
	    private handleKeyboardNavigation(event, isEmpty);
	    private keyboardNavigationEnterPressed(event, isEmpty);
	    private keyboardNavigationDeletePressed(event);
	    private startNewSearchTimeout(params);
	    private cancelAnyPendingSearchOperation();
	    private processNewFacetSearchResults(fieldValues, facetSearchParameters);
	    private rebuildSearchResults(fieldValues, facetSearchParameters);
	    private setupFacetSearchResultsEvents(elem);
	    private handleFacetSearchResultsScroll();
	    private buildParamsForNormalSearch();
	    private buildParamsForFetchingMore();
	    protected buildParamsForExcludingCurrentlyDisplayedValues(): FacetSearchParameters;
	    private showSearchResultsElement();
	    private hideSearchResultsElement();
	    private highlightCurrentQueryWithinSearchResults();
	    private makeFirstSearchResultTheCurrentOne();
	    private makeCurrentResult(result);
	    private moveCurrentResultDown();
	    private moveCurrentResultUp();
	    private getSelectables(target?);
	    private performSelectActionOnCurrentSearchResult();
	    private performExcludeActionOnCurrentSearchResult();
	    protected getValueInInputForFacetSearch(): string;
	    protected selectAllValuesMatchingSearch(): void;
	    private showFacetSearchWaitingAnimation();
	    private hideFacetSearchWaitingAnimation();
	    private detectSearchBarAnimation();
	}

}
declare module Coveo {
	/// <reference path="HierarchicalFacet.d.ts" />
	
	
	
	
	export class HierarchicalFacetSearch extends FacetSearch {
	    facet: HierarchicalFacet;
	    facetSearchValuesListKlass: IFacetSearchValuesListKlass;
	    constructor(facet: HierarchicalFacet, facetSearchValuesListKlass: IFacetSearchValuesListKlass, root: HTMLElement);
	    protected buildParamsForExcludingCurrentlyDisplayedValues(): FacetSearchParameters;
	    protected selectAllValuesMatchingSearch(): void;
	    private getFacetValues(fieldValues);
	    private createFacetValuesFromHierarchy(hierarchy);
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	
	
	
	export interface IBreadcrumbValueElementKlass {
	    new (facet: Facet, facetValue: FacetValue): BreadcrumbValueElement;
	}
	export class BreadcrumbValueElement {
	    facet: Facet;
	    facetValue: FacetValue;
	    constructor(facet: Facet, facetValue: FacetValue);
	    build(tooltip?: boolean): Dom;
	    getBreadcrumbTooltip(): string;
	}

}
declare module Coveo {
	
	
	
	export class BreadcrumbValueList {
	    facet: Facet;
	    facetValues: FacetValue[];
	    breadcrumbValueElementKlass: IBreadcrumbValueElementKlass;
	    private expanded;
	    private collapsed;
	    private elem;
	    private valueContainer;
	    constructor(facet: Facet, facetValues: FacetValue[], breadcrumbValueElementKlass: IBreadcrumbValueElementKlass);
	    build(): HTMLElement;
	    private buildExpanded();
	    private buildCollapsed();
	    private setExpandedAndCollapsed();
	}

}
declare module Coveo {
	
	
	
	
	export class HierarchicalBreadcrumbValueElement extends BreadcrumbValueElement {
	    facet: HierarchicalFacet;
	    facetValue: FacetValue;
	    constructor(facet: HierarchicalFacet, facetValue: FacetValue);
	    build(): Dom;
	}

}
declare module Coveo {
	/// <reference path="HierarchicalFacet.d.ts" />
	
	
	
	export class HierarchicalBreadcrumbValuesList extends BreadcrumbValueList {
	    facet: HierarchicalFacet;
	    facetValues: FacetValue[];
	    valueHierarchy: {
	        [facetValue: string]: IValueHierarchy;
	    };
	    constructor(facet: HierarchicalFacet, facetValues: FacetValue[], valueHierarchy: {
	        [facetValue: string]: IValueHierarchy;
	    });
	}

}
declare module Coveo {
	/// <reference path="HierarchicalFacet.d.ts" />
	
	
	
	export class HierarchicalFacetValueElement extends FacetValueElement {
	    facet: HierarchicalFacet;
	    facetValue: FacetValue;
	    keepDisplayedValueNextTime: boolean;
	    constructor(facet: HierarchicalFacet, facetValue: FacetValue, keepDisplayedValueNextTime: boolean);
	}

}
declare module Coveo {
	
	
	
	
	export class HierarchicalFacetSearchValueElement extends FacetValueElement {
	    facet: HierarchicalFacet;
	    facetValue: FacetValue;
	    keepDisplayedValueNextTime: boolean;
	    constructor(facet: HierarchicalFacet, facetValue: FacetValue, keepDisplayedValueNextTime: boolean);
	    _handleSelectValue(eventBindings: IValueElementEventsBinding): void;
	    _handleExcludeClick(eventBindings: IValueElementEventsBinding): void;
	}

}
declare module Coveo {
	/// <reference path="../Facet/Facet.d.ts" />
	
	
	export class HierarchicalFacetSearchValuesList extends FacetSearchValuesList {
	    facet: Facet;
	    constructor(facet: Facet);
	}

}
declare module Coveo {
	
	export interface IPopulateOmniboxEventArgs extends IOmniboxData {
	}
	export interface IPopulateOmniboxEventRow extends IOmniboxDataRow {
	}
	export interface IOmniboxPreprocessResultForQueryEventArgs {
	    result: Coveo.MagicBox.Result;
	}
	export interface ICloseOmniboxEventArgs {
	}
	export class OmniboxEvents {
	    static populateOmnibox: string;
	    static openOmnibox: string;
	    static closeOmnibox: string;
	    static populateOmniboxSuggestions: string;
	    static omniboxPreprocessResultForQuery: string;
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	
	
	
	
	
	export interface IOmniboxValueElementKlass {
	    new (facet: Facet, facetValue: FacetValue, eventArg: IPopulateOmniboxObject, onSelect?: (elem: ValueElement, cause: IAnalyticsActionCause) => void, onExclude?: (elem: ValueElement, cause: IAnalyticsActionCause) => void): OmniboxValueElement;
	}
	export class OmniboxValueElement extends ValueElement {
	    facet: Facet;
	    facetValue: FacetValue;
	    eventArg: IPopulateOmniboxObject;
	    constructor(facet: Facet, facetValue: FacetValue, eventArg: IPopulateOmniboxObject, onSelect?: (elem: ValueElement, cause: IAnalyticsActionCause) => void, onExclude?: (elem: ValueElement, cause: IAnalyticsActionCause) => void);
	    bindEvent(): void;
	}

}
declare module Coveo {
	/// <reference path="Facet.d.ts" />
	
	
	
	
	export class OmniboxValuesList {
	    facet: Facet;
	    facetValues: FacetValue[];
	    omniboxObject: IPopulateOmniboxObject;
	    omniboxValueElementKlass: IOmniboxValueElementKlass;
	    constructor(facet: Facet, facetValues: FacetValue[], omniboxObject: IPopulateOmniboxObject, omniboxValueElementKlass: IOmniboxValueElementKlass);
	    build(): HTMLElement;
	    private buildOmniboxForOneRow(facetValue, omniboxObject);
	    private buildFinalOmniboxElement(rows);
	    private buildOmniboxHeader();
	    private highlightOmniboxMatch(orignalStr, regex, valueToSearch);
	    private logAnalyticsEvent(elem, cause);
	}

}
declare module Coveo {
	/// <reference path="HierarchicalFacet.d.ts" />
	
	
	
	
	
	export class OmniboxHierarchicalValueElement extends OmniboxValueElement {
	    facet: HierarchicalFacet;
	    facetValue: FacetValue;
	    eventArg: IPopulateOmniboxObject;
	    constructor(facet: HierarchicalFacet, facetValue: FacetValue, eventArg: IPopulateOmniboxObject);
	    _handleSelectValue(eventBindings: IValueElementEventsBinding): void;
	    _handleExcludeClick(eventBindings: IValueElementEventsBinding): void;
	}

}
declare module Coveo {
	/// <reference path="HierarchicalFacet.d.ts" />
	
	
	
	
	export class OmniboxHierarchicalValuesList extends OmniboxValuesList {
	    facet: HierarchicalFacet;
	    facetValues: FacetValue[];
	    omniboxObject: IPopulateOmniboxObject;
	    constructor(facet: HierarchicalFacet, facetValues: FacetValue[], omniboxObject: IPopulateOmniboxObject);
	}

}
declare module Coveo {
	/// <reference path="../../controllers/HierarchicalFacetQueryController.d.ts" />
	/// <reference path="HierarchicalFacetValuesList.d.ts" />
	/// <reference path="HierarchicalFacetSearch.d.ts" />
	/// <reference path="HierarchicalBreadcrumbValuesList.d.ts" />
	/// <reference path="HierarchicalFacetValueElement.d.ts" />
	
	
	
	
	
	
	
	
	
	
	export interface IHierarchicalFacetOptions extends IFacetOptions {
	    delimitingCharacter?: string;
	    levelStart?: number;
	    levelEnd?: number;
	    marginByLevel?: number;
	}
	export interface IValueHierarchy {
	    childs?: IValueHierarchy[];
	    parent?: IValueHierarchy;
	    originalPosition?: number;
	    facetValue: FacetValue;
	    level: number;
	    keepOpened: boolean;
	    hasChildSelected: boolean;
	}
	/**
	 * This component inherits all of its options and behavior from the normal {@link Facet} component, but is meant to be used for hierarchical values.<br/>
	 * The HierarchicalFacet component could be used to display files in a file system, or categories for documents in a hierarchy.<br/>
	 * This facet require a group by field with a special format in order to work correctly.<br/>
	 * Let's say we have the following files indexed on a filesystem:
	 * ```
	 * C:\
	 *    folder1\
	 *        text1.txt
	 *    folder2\
	 *      folder3\
	 *        text2.txt
	 * ```
	 * The document `text1.txt` would need to have a field with the following format:<br/>
	 * `@field : c; c|folder1;`<br/>
	 * The document `text2.txt` would have a field with the following format:<br/>
	 * `@field: c; c|folder2; c|folder2|folder3;`<br/>
	 * The | character allows the facet to build its hierarchy (`folder3` inside `folder2` inside `c`)<br/>
	 * Since both documents contain the `c` value, selecting that value in the facet would return both documents.<br/>
	 * Selecting the `folder3` value in the facet would only return the `text2.txt` document.
	 */
	export class HierarchicalFacet extends Facet {
	    element: HTMLElement;
	    bindings: IComponentBindings;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IHierarchicalFacetOptions;
	    static parent: typeof Facet;
	    options: IHierarchicalFacetOptions;
	    facetValuesList: HierarchicalFacetValuesList;
	    numberOfValuesToShow: number;
	    facetQueryController: HierarchicalFacetQueryController;
	    private valueHierarchy;
	    private firstPlacement;
	    private originalNumberOfValuesToShow;
	    private topLevelHierarchy;
	    private correctLevels;
	    /**
	     * Create a new instance of the Hierarchical component
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options: IHierarchicalFacetOptions, bindings: IComponentBindings);
	    /**
	     * Select a single value
	     * @param value The value to select
	     * @param selectChilds Determine if the child values (if any) should also be selected. By default, this is the opposite value of the {@link Facet.options.useAnd} value
	     */
	    selectValue(value: FacetValue, selectChilds?: boolean): void;
	    selectValue(value: string, selectChilds?: boolean): void;
	    /**
	     * Select multiple values
	     * @param values The array of values to select
	     * @param selectChilds Determine if the child values (if any) should also be selected. By default, this is the opposite value of the {@link Facet.options.useAnd} value
	     */
	    selectMultipleValues(values: FacetValue[], selectChilds?: boolean): void;
	    selectMultipleValues(values: string[], selectChilds?: boolean): void;
	    /**
	     * Deselect a single value
	     * @param value The value to deselect
	     * @param deselectChilds Determine if the child values (if any) should also be de-selected. By default, this is true
	     */
	    deselectValue(value: FacetValue, deselectChilds?: boolean): void;
	    deselectValue(value: string, deselectChilds?: boolean): void;
	    /**
	     * Exclude a single value
	     * @param value The value to exclude
	     * @param excludeChilds Determine if the child values (if any) should also be excluded. By default, this is the opposite value of the {@link Facet.options.useAnd} value
	     */
	    excludeValue(value: FacetValue, excludeChilds?: boolean): void;
	    excludeValue(value: string, excludeChilds?: boolean): void;
	    /**
	     * Unexclude a single value
	     * @param value The value to unexclude
	     * @param unexludeChilds Determine if the child values (if any) should also be un-excluded. By default, this is the opposite value of the {@link Facet.options.useAnd} value
	     */
	    unexcludeValue(value: FacetValue, unexludeChilds?: boolean): void;
	    unexcludeValue(value: string, unexludeChilds?: boolean): void;
	    /**
	     * Deselect multiple values
	     * @param values The array of values to deselect
	     * @param deselectChilds Determine if the child values (if any) should also be deselected. By default, this is the opposite value of the {@link Facet.options.useAnd} value
	     */
	    deselectMultipleValues(values: FacetValue[], deselectChilds?: boolean): void;
	    deselectMultipleValues(values: string[], deselectChilds?: boolean): void;
	    /**
	     * Toggle the selection on a single value (select / deselect).
	     * @param value
	     */
	    toggleSelectValue(value: FacetValue): void;
	    toggleSelectValue(value: string): void;
	    /**
	     * Toggle the exclusion on a single value (exclude / unexclude)
	     * @param value
	     */
	    toggleExcludeValue(value: FacetValue): void;
	    toggleExcludeValue(value: string): void;
	    /**
	     * Get the caption for a single value.
	     * @param facetValue
	     */
	    getValueCaption(facetValue: IIndexFieldValue): string;
	    getValueCaption(facetValue: FacetValue): string;
	    /**
	     * Get the currently displayed values in the facet
	     * @returns {any[]}
	     */
	    getDisplayedValues(): string[];
	    /**
	     * Update the sort criteria for the facet
	     * @param criteria
	     */
	    updateSort(criteria: string): void;
	    /**
	     * Open a single value and show all it's child
	     * @param value
	     */
	    open(value: FacetValue): any;
	    open(value: IValueHierarchy): any;
	    open(value: String): any;
	    /**
	     * Close a single value and hide all it's child
	     * @param value
	     */
	    close(value: FacetValue): any;
	    close(value: IValueHierarchy): any;
	    close(value: String): any;
	    /**
	     * Reset the facet state
	     */
	    reset(): void;
	    processFacetSearchAllResultsSelected(facetValues: FacetValue[]): void;
	    protected updateSearchInNewDesign(moreValuesAvailable?: boolean): void;
	    protected facetValueHasChanged(): void;
	    protected initFacetQueryController(): void;
	    protected initFacetSearch(): void;
	    protected handleDeferredQuerySuccess(data: IQuerySuccessEventArgs): void;
	    protected handlePopulateBreadcrumb(args: IPopulateBreadcrumbEventArgs): void;
	    protected handleOmniboxWithStaticValue(eventArg: IPopulateOmniboxEventArgs): void;
	    protected rebuildValueElements(): void;
	    protected initFacetValuesList(): void;
	    protected updateMoreLess(): void;
	    protected handleClickMore(): void;
	    protected handleClickLess(): void;
	    protected updateNumberOfValues(): void;
	    private ensureValueHierarchyExists(facetValues);
	    private crop();
	    private placeChildsUnderTheirParent(hierarchy, hierarchyElement);
	    private addCssClassToParentAndChilds(hierarchy, hierarchyElement);
	    private buildParentChildRelationship();
	    private setValueListContent();
	    private createHierarchy(valuesToBuildWith);
	    private processHierarchy(facetValues?);
	    private setInHierarchy(flatHierarchy);
	    private getParent(value);
	    private getSelf(value);
	    private showFacetValue(value);
	    private hideFacetValue(value);
	    private hideChilds(children);
	    private showChilds(children);
	    private selectChilds(parent, children);
	    private deselectChilds(parent, children);
	    private excludeChilds(children);
	    private unexcludeChilds(children);
	    private selectParent(parent);
	    private deselectParent(parent);
	    private flagParentForSelection(valueHierarchy);
	    private unflagParentForSelection(valueHierarchy);
	    getValueFromHierarchy(value: any): IValueHierarchy;
	    private getFacetValueFromHierarchy(value);
	    private getLookupOrValue(value);
	    private getElementFromFacetValueList(value);
	    private getFromFacetValueList(value);
	    private getLevel(value);
	    private getAllValueHierarchy();
	    private deleteValueHierarchy(key);
	    private getValueHierarchy(key);
	    private setValueHierarchy(key, value);
	    private checkForOrphans();
	}

}
declare module Coveo {
	/// <reference path="../ui/HierarchicalFacet/HierarchicalFacet.d.ts" />
	/// <reference path="FacetQueryController.d.ts" />
	
	
	
	export class HierarchicalFacetQueryController extends FacetQueryController {
	    facet: HierarchicalFacet;
	    lastGroupByForCountOf: IGroupByResult;
	    constructor(facet: HierarchicalFacet);
	}

}
declare module Coveo {
	/// <reference path="../../controllers/HierarchicalFacetQueryController.d.ts" />
	/// <reference path="../../controllers/FacetQueryController.d.ts" />
	/// <reference path="FacetSearch.d.ts" />
	/// <reference path="FacetSettings.d.ts" />
	/// <reference path="FacetSort.d.ts" />
	/// <reference path="FacetHeader.d.ts" />
	/// <reference path="BreadcrumbValueElement.d.ts" />
	/// <reference path="ValueElementRenderer.d.ts" />
	/// <reference path="FacetSearchParameters.d.ts" />
	/// <reference path="../HierarchicalFacet/HierarchicalFacet.d.ts" />
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	export interface IFacetOptions {
	    title?: string;
	    field?: string;
	    isMultiValueField?: boolean;
	    numberOfValues?: number;
	    pageSize?: number;
	    sortCriteria?: string;
	    availableSorts?: string[];
	    injectionDepth?: number;
	    showIcon?: boolean;
	    useAnd?: boolean;
	    enableCollapse?: boolean;
	    enableTogglingOperator?: boolean;
	    enableMoreLess?: boolean;
	    valueCaption?: any;
	    lookupField?: string;
	    enableFacetSearch?: boolean;
	    facetSearchDelay?: number;
	    facetSearchIgnoreAccents?: boolean;
	    numberOfValuesInFacetSearch?: number;
	    includeInBreadcrumb?: boolean;
	    includeInOmnibox?: boolean;
	    numberOfValuesInOmnibox?: number;
	    numberOfValuesInBreadcrumb?: number;
	    id?: string;
	    computedField?: string;
	    computedFieldOperation?: string;
	    computedFieldFormat?: string;
	    computedFieldCaption?: string;
	    preservePosition?: boolean;
	    scrollContainer?: HTMLElement;
	    paddingContainer?: HTMLElement;
	    customSort?: string[];
	    enableSettings?: boolean;
	    enableSettingsFacetState?: boolean;
	    allowedValues?: string[];
	    headerIcon?: string;
	    valueIcon?: (facetValue: FacetValue) => string;
	    additionalFilter?: string;
	    dependsOn?: string;
	    enableResponsiveMode?: boolean;
	    responsiveBreakpoint?: number;
	}
	/**
	 * This component displays a facet of the results for the current query. A facet consists of a list of values for a given field occurring in the results, ordered using a configurable criteria.<br/>
	 * The list of values is obtained using a {@link IGroupByRequest} operation performed at the same time as the main query.<br/>
	 * The Facet component allows the user to drill down inside results by restricting to certain field values. It also allows filtering out values, and can provide a search box to look for specific values inside larger sets.<br/>
	 * It is probably the most complex component in the Coveo UI, and as such allows many different options.
	 */
	export class Facet extends Component {
	    element: HTMLElement;
	    options: IFacetOptions;
	    static ID: string;
	    static omniboxIndex: number;
	    /**
	     * The possible options for a facet
	     * @componentOptions
	     */
	    static options: IFacetOptions;
	    facetQueryController: FacetQueryController;
	    keepDisplayedValuesNextTime: boolean;
	    values: FacetValues;
	    currentPage: number;
	    numberOfValues: number;
	    firstQuery: boolean;
	    operatorAttributeId: string;
	    /**
	     * Render and handle the facet search part of the component
	     */
	    facetSearch: FacetSearch;
	    /**
	     * Render and handle the facet settings part of the component
	     */
	    facetSettings: FacetSettings;
	    facetSort: FacetSort;
	    facetValuesList: FacetValuesList;
	    facetHeader: FacetHeader;
	    protected omniboxZIndex: any;
	    protected moreElement: HTMLElement;
	    protected lessElement: HTMLElement;
	    private headerElement;
	    private footerElement;
	    private canFetchMore;
	    private nbAvailableValues;
	    private showingWaitAnimation;
	    private pinnedViewportPosition;
	    private unpinnedViewportPosition;
	    private pinnedTopSpace;
	    private pinnedBottomSpace;
	    private componentStateId;
	    private includedAttributeId;
	    private excludedAttributeId;
	    private lookupValueAttributeId;
	    private listenToQueryStateChange;
	    private resize;
	    /**
	     * Create a new Facet component, bind multiple query events as well
	     * @param element
	     * @param options
	     * @param bindings
	     * @param facetClassId The id to use for this facet (as Facet inherited from by other component (eg : {@link FacetRange}). Default is "Facet"
	     */
	    constructor(element: HTMLElement, options: IFacetOptions, bindings?: IComponentBindings, facetClassId?: string);
	    createDom(): void;
	    /**
	     * Select a single value.<br/>
	     * Does not trigger a query automatically.
	     * @param value Can be a {@link FacetValue} or a string -> eg: selectValue('foobar') or selectValue(new FacetValue('foobar'));
	     */
	    selectValue(value: FacetValue): void;
	    selectValue(value: string): void;
	    /**
	     * Select multiple values.<br/>
	     * Does not trigger a query automatically.
	     * @param values Can be an array of {@link FacetValue} or array of string
	     */
	    selectMultipleValues(values: FacetValue[]): void;
	    selectMultipleValues(values: string[]): void;
	    /**
	     * Deselect a single value.<br/>
	     * Does not trigger a query automatically.
	     * @param value Can be a {@link FacetValue} or a string
	     */
	    deselectValue(value: FacetValue): void;
	    deselectValue(value: string): void;
	    /**
	     * Deselect multiple value.<br/>
	     * Does not trigger a query automatically.
	     * @param values Can be an array of {@link FacetValue} or array of string
	     */
	    deselectMultipleValues(values: FacetValue[]): void;
	    deselectMultipleValues(values: string[]): void;
	    /**
	     * Exclude a single value.<br/>
	     * Does not trigger a query automatically.
	     * @param value Can be a {@link FacetValue} or a string
	     */
	    excludeValue(value: FacetValue): void;
	    excludeValue(value: string): void;
	    /**
	     * Exclude multiple values.<br/>
	     * Does not trigger a query automatically.
	     * @param values Can be an array of {@link FacetValue} or array of string
	     */
	    excludeMultipleValues(values: FacetValue[]): void;
	    excludeMultipleValues(values: string[]): void;
	    /**
	     * Unexclude a single value.<br/>
	     * Does not trigger a query automatically.
	     * @param value Can be a {@link FacetValue} or a string
	     */
	    unexcludeValue(value: FacetValue): void;
	    unexcludeValue(value: string): void;
	    /**
	     * Unexclude multiple values.<br/>
	     * Does not trigger a query automatically.
	     * @param values Can be an array of {@link FacetValue} or array of string
	     */
	    unexcludeMultipleValues(values: FacetValue[]): void;
	    unexcludeMultipleValues(values: string[]): void;
	    /**
	     * Toggle the selection state of a single value (select if not already selected, unselect if already selected).<br/>
	     * Does not trigger a query automatically.
	     * @param value Can be a {@link FacetValue} or a string
	     */
	    toggleSelectValue(value: FacetValue): void;
	    toggleSelectValue(value: string): void;
	    /**
	     * Toggle the exclusion state of a single value (exclude if not already excluded, unexclude if already excluded).<br/>
	     * Does not trigger a query automatically.
	     * @param value Can be a {@link FacetValue} or a string
	     */
	    toggleExcludeValue(value: FacetValue): void;
	    toggleExcludeValue(value: string): void;
	    /**
	     * Return the currently displayed values, as an array of string
	     * @returns {any[]}
	     */
	    getDisplayedValues(): string[];
	    /**
	     * Return the currently displayed values, as an array of {@link FacetValue}
	     * @returns {T[]}
	     */
	    getDisplayedFacetValues(): FacetValue[];
	    /**
	     * Return the currently selected values, as an array of string
	     * @returns {TResult[]}
	     */
	    getSelectedValues(): string[];
	    /**
	     * Return the currently excluded values, as an array of string
	     * @returns {TResult[]}
	     */
	    getExcludedValues(): string[];
	    /**
	     * Reset the facet. This means unselect all values, unexclude all values, and redraw.
	     */
	    reset(): void;
	    /**
	     * Switch the facet to AND mode : {@link Facet.options.useAnd}
	     */
	    switchToAnd(): void;
	    /**
	     * Switch the facet to OR mode : {@link Facet.options.useAnd}
	     */
	    switchToOr(): void;
	    /**
	     * Return the endpoint for the facet
	     * @returns {SearchEndpointInterface|ISearchEndpoint}
	     */
	    getEndpoint(): ISearchEndpoint;
	    /**
	     * Change the sort parameter for the facet.<br/>
	     * See : {@link Facet.options.availableSorts} the list of possible value.<br/>
	     * Trigger a new query
	     * @param criteria
	     */
	    updateSort(criteria: string): void;
	    unfadeInactiveValuesInMainList(): void;
	    fadeInactiveValuesInMainList(delay: number): void;
	    /**
	     * Show a waiting animation in the facet header (a spinner)
	     */
	    showWaitingAnimation(): void;
	    /**
	     * Hide the waiting animation in the facet header (a spinner)
	     */
	    hideWaitingAnimation(): void;
	    processFacetSearchAllResultsSelected(facetValues: FacetValue[]): void;
	    pinFacetPosition(): void;
	    /**
	     * Return the configured caption for the given {@link FacetValue} or {
	     * @param facetValue
	     */
	    getValueCaption(facetValue: IIndexFieldValue): string;
	    getValueCaption(facetValue: FacetValue): string;
	    /**
	     * Show the next page of results in the facet.<br/>
	     * Trigger a query if needed, or display the already available values
	     */
	    showMore(): void;
	    /**
	     * Show less element in the facet (up to the original number of values)
	     */
	    showLess(): void;
	    triggerNewQuery(beforeExecuteQuery?: () => void): void;
	    protected handleDeferredQuerySuccess(data: IQuerySuccessEventArgs): void;
	    protected handlePopulateBreadcrumb(args: IPopulateBreadcrumbEventArgs): void;
	    protected initFacetQueryController(): void;
	    protected initFacetValuesList(): void;
	    protected initFacetSearch(): void;
	    protected facetValueHasChanged(): void;
	    protected updateAppearanceDependingOnState(): void;
	    protected initQueryEvents(): void;
	    protected initQueryStateEvents(): void;
	    protected initComponentStateEvents(): void;
	    protected initOmniboxEvents(): void;
	    protected initBreadCrumbEvents(): void;
	    protected handleOmniboxWithStaticValue(eventArg: IPopulateOmniboxEventArgs): void;
	    protected processNewGroupByResults(groupByResult: IGroupByResult): void;
	    protected updateQueryStateModel(): void;
	    protected rebuildValueElements(): void;
	    protected updateSearchInNewDesign(moreValuesAvailable?: boolean): void;
	    protected updateMoreLess(lessElementIsShown?: boolean, moreValuesAvailable?: boolean): void;
	    protected handleClickMore(): void;
	    protected handleClickLess(): void;
	    private handleNuke();
	    private checkForComputedFieldAndSort();
	    private checkForValueCaptionType();
	    private checkForCustomSort();
	    private initBottomAndTopSpacer();
	    private updateIncludedQueryStateModel();
	    private updateExcludedQueryStateModel();
	    private updateLookupValueQueryStateModel();
	    private handleQueryStateChangedOperator(operator);
	    private handleQueryStateChangedIncluded(includedChanged);
	    private handleQueryStateChangedExcluded(excludedChanged);
	    private handleLookupvalueChanged(lookupFieldChanged);
	    private handleQueryStateChanged(data);
	    private handlePopulateOmnibox(data);
	    private handleOmniboxWithSearchInFacet(eventArg);
	    private handleDuringQuery();
	    private handleBuildingQuery(data);
	    private handleDoneBuildingQuery(data);
	    private handleClearBreadcrumb();
	    private updateValues(facetValues);
	    private ensureFacetValueIsInList(facetValue);
	    private isAnyValueCurrentlyDisplayed();
	    private buildFacetContent();
	    private buildHeader();
	    private unpinFacetPosition();
	    private isFacetPinned();
	    private shouldFacetUnpin();
	    private ensurePinnedFacetHasntMoved();
	    private buildFooter();
	    private buildMore();
	    private buildLess();
	    private triggerMoreQuery();
	    private triggerUpdateDeltaQuery(facetValues);
	    protected updateNumberOfValues(): void;
	    private getMinimumNumberOfValuesToDisplay();
	    private updateVisibilityBasedOnDependsOn();
	    private doesParentFacetHasSelectedValue();
	    private shouldRenderFacetSearch();
	    private shouldRenderMoreLess();
	    debugInfo(): any;
	}

}
declare module Coveo {
	/// <reference path="../ui/Facet/Facet.d.ts" />
	
	
	
	
	
	
	
	
	export class FacetQueryController {
	    facet: Facet;
	    expressionToUseForFacetSearch: string;
	    constantExpressionToUseForFacetSearch: string;
	    lastGroupByRequestIndex: number;
	    lastGroupByRequest: IGroupByRequest;
	    lastGroupByResult: IGroupByResult;
	    constructor(facet: Facet);
	    /**
	     * Reset the expression for the facet search, used when a new query is triggered
	     */
	    prepareForNewQuery(): void;
	    /**
	     * Compute the filter expression that the facet need to output for the query
	     * @returns {string}
	     */
	    computeOurFilterExpression(): string;
	    /**
	     * Build the group by request for the facet, and insert it in the query builder
	     * @param queryBuilder
	     */
	    putGroupByIntoQueryBuilder(queryBuilder: QueryBuilder): void;
	    /**
	     * Search inside the facet, using a group by request
	     * @param params
	     * @param oldLength Optional params, used by the search method to call itself recursively to fetch all required values
	     * @returns {Promise|Promise<T>}
	     */
	    search(params: FacetSearchParameters, oldLength?: number): Promise<IIndexFieldValue[]>;
	    fetchMore(numberOfValuesToFetch: number): Promise<IQueryResults>;
	    searchInFacetToUpdateDelta(facetValues: FacetValue[]): Promise<IQueryResults>;
	    protected createGroupByAllowedValues(): string[];
	    private getAllowedValuesFromSelected();
	    private createGroupByQueryOverride(queryBuilder);
	    protected createBasicGroupByRequest(allowedValues?: string[], addComputedField?: boolean): IGroupByRequest;
	    private checkForFacetSearchValuesToRemove(fieldValues, valueToCheckAgainst);
	}

}
declare module Coveo {
	/// <reference path="../Facet/Facet.d.ts" />
	
	
	
	
	export interface IFacetRangeOptions extends IFacetOptions {
	    ranges?: IRangeValue[];
	    dateField?: boolean;
	}
	/**
	 * This component displays a facet with values expressed as ranges. These ranges are computed from the results of the current query. This component inherits from the Facet component.
	 */
	export class FacetRange extends Facet {
	    element: HTMLElement;
	    static ID: string;
	    static parent: typeof Facet;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IFacetRangeOptions;
	    options: IFacetRangeOptions;
	    constructor(element: HTMLElement, options: IFacetRangeOptions, bindings?: IComponentBindings);
	    getValueCaption(facetValue: any): string;
	    protected initFacetQueryController(): void;
	    protected processNewGroupByResults(groupByResult: IGroupByResult): void;
	}

}
declare module Coveo {
	/// <reference path="../ui/FacetRange/FacetRange.d.ts" />
	
	
	
	export class FacetRangeQueryController extends FacetQueryController {
	    facet: FacetRange;
	    graphGroupByQueriesIndex: number;
	    constructor(facet: FacetRange);
	    protected createBasicGroupByRequest(allowedValues?: string[], addComputedField?: boolean): IGroupByRequest;
	    protected createGroupByAllowedValues(): string[];
	    private buildGroupByQueryForAutomaticRanges(groupByQuery);
	    private buildGroupByQueryForPredefinedRanges(groupByQuery);
	}

}
declare module Coveo {
	export function defaultLanguage(): void;
	export function setLanguageAfterPageLoaded(): void;

}
declare module Coveo {
	export function shim(): void;

}
declare module Coveo {
	export function customEventPolyfill(): void;

}
declare module Coveo {
	export class Cache<Type> {
	    onEmpty: () => Type;
	    constructor(onEmpty?: () => Type);
	    private cache;
	    get(): Type;
	    push(value: Type): void;
	}

}
declare module Coveo {
	export interface ICompletedImageResultsLayoutEventArgs {
	}
	export class ImageResultListEvents {
	    static imageResultsLayoutComplete: string;
	}

}
declare module Coveo {
	export interface ISavePreferencesEventArgs {
	}
	export class PreferencesPanelEvents {
	    static savePreferences: string;
	    static exitPreferencesWithoutSave: string;
	}

}
declare module Coveo {
	
	export interface ISearchAlertsEventArgs {
	    subscription: ISubscription;
	    dom?: HTMLElement;
	}
	export interface ISearchAlertsFailEventArgs {
	    dom?: HTMLElement;
	}
	export class SearchAlertsEvents {
	    static searchAlertsCreated: string;
	    static searchAlertsDeleted: string;
	    static searchAlertsFail: string;
	}

}
declare module Coveo {
	export class SettingsEvents {
	    static settingsPopulateMenu: string;
	}

}
declare module Coveo {
	export class ColorUtils {
	    static hsvToRgb(h: any, s: any, v: any): number[];
	    static rgbToHsv(r: any, g: any, b: any): any[];
	}

}
declare module Coveo {
	export interface ICurrencyToStringOptions {
	    decimals?: number;
	    symbol?: string;
	}
	export class CurrencyUtils {
	    static currencyToString(value: number, options?: ICurrencyToStringOptions): string;
	}

}
declare module Coveo {
	
	export interface IMailToOptions {
	    currentUserEmail?: string;
	    originalFrom?: string;
	    to?: string;
	    subject?: string;
	    cc?: string;
	    bcc?: string;
	    body?: string;
	    bodyIsHTML?: boolean;
	}
	export class EmailActionsUtils {
	    static buildMailToString(options: IMailToOptions): string;
	    static buildMailToParametersString(subject: string, cc: string, bcc: string, body: string, mailTo: string): string;
	    static getShortenBody(body: string, mailTo: string): string;
	    static buildMailToParameter(name: string, param: string): string;
	    static shortenString(str: string, maxLength: number, encodeShortenBodyIndication?: boolean): string;
	    static appendShortenBodyToMailToString(mailTo: string, body: string): string;
	    static removeCurrentUserEmailFromString(currentUserEmail: string, str: string): string;
	    static buildReplyMailToFromResult(result: IQueryResult, currentUserEmail: string): MailTo;
	    static buildReplyAllMailToFromResult(result: IQueryResult, currentUserEmail: string): MailTo;
	    static buildForwardMailToFromResult(result: IQueryResult, currentUserEmail: string): MailTo;
	    static encodeMailToBody(body: string): string;
	}
	export class DefaultMailToOptions implements IMailToOptions {
	    currentUserEmail: string;
	    originalFrom: string;
	    to: string;
	    subject: string;
	    cc: string;
	    bcc: string;
	    body: string;
	}
	export class MailTo {
	    options: IMailToOptions;
	    private value;
	    private body;
	    private bodyHeader;
	    static enter: string;
	    static shortenBodyIndicator: string;
	    static maxLength: number;
	    constructor(options?: IMailToOptions);
	    private removeCurrentUserFromParameters();
	    open(): void;
	    private ensureValueIsSet();
	    private setValue();
	    private setValueBody();
	    setMailToBodyFromText(text?: string): void;
	    private valueBodyIsSet();
	    bodyIsSet(): boolean;
	}

}
declare module Coveo {
	export class EmailUtils {
	    static splitSemicolonSeparatedListOfEmailAddresses(addresses: string): string[];
	    static emailAddressesToHyperlinks(addresses: string[], companyDomain?: string, me?: string, lengthLimit?: number, truncateName?: boolean): string;
	    static buildEmailAddressesAndOthers(excessHyperLinks: string[]): string;
	    static parseEmail(email: string): string[];
	}

}
declare module Coveo {
	
	export interface IStringHole {
	    begin: number;
	    size: number;
	    replacementSize: number;
	}
	export class StringAndHoles {
	    value: string;
	    holes: IStringHole[];
	    static SHORTEN_END: string;
	    static WORD_SHORTER: number;
	    static replace(str: string, find: string, replace: string): StringAndHoles;
	    /**
	     * Shorten the passed path intelligently (path-aware).
	     * Works with *local paths* and *network paths*
	     * @param uriOrig The path to shorten
	     * @param length The length to which the path will be shortened.
	     */
	    static shortenPath(uriOrig: string, length: number): StringAndHoles;
	    /**
	     * Shorten the passed string.
	     * @param toShortenOrig The string to shorten
	     * @param length The length to which the string will be shortened.
	     * @param toAppend The string to append at the end (usually, it is set to '...')
	     */
	    static shortenString(toShortenOrig: string, length?: number, toAppend?: string): StringAndHoles;
	    /**
	     * Shorten the passed URI intelligently (path-aware).
	     * @param toShortenOrig The URI to shorten
	     * @param length The length to which the URI will be shortened.
	     */
	    static shortenUri(uri: string, length: number): StringAndHoles;
	}
	export class HighlightUtils {
	    /**
	     * Highlight the passed string using specified highlights and holes.
	     * @param content The string to highlight items in.
	     * @param highlights The highlighted positions to highlight in the string.
	     * @param holes Possible holes which are used to skip highlighting.
	     * @param cssClass The css class to use on the highlighting `span`.
	     */
	    static highlightString(content: string, highlights: IHighlight[], holes: IStringHole[], cssClass: string): string;
	}
	export function highlightString(value: string, search: string): string;

}
declare module Coveo {
	
	
	/**
	 * Options for building an `<a>` tag.
	 */
	export interface IAnchorUtilsOptions {
	    /**
	     * The tag's text content.
	     */
	    text?: string;
	    /**
	     * The target (`href` attribute).
	     */
	    target?: string;
	    /**
	     * The CSS class(es) of the tag.
	     */
	    class?: string;
	}
	/**
	 * Options for building an `<img>` tag.
	 */
	export interface IImageUtilsOptions {
	    /**
	     * The alternative text for the image (`alt` attribute).
	     */
	    alt?: string;
	    /**
	     * The height of the image
	     */
	    height?: string;
	    /**
	     * The width of the image
	     */
	    width?: string;
	}
	export class HTMLUtils {
	    static buildAttributeString(options: any): string;
	}
	export class AnchorUtils {
	    static buildAnchor(href: string, options?: IAnchorUtilsOptions): string;
	}
	export class ImageUtils {
	    static buildImage(src?: string, options?: IImageUtilsOptions): string;
	    static selectImageFromResult(result: IQueryResult): HTMLElement;
	    static buildImageWithDirectSrcAttribute(endpoint: SearchEndpoint, result: IQueryResult): void;
	    static buildImageWithBase64SrcAttribute(endpoint: SearchEndpoint, result: IQueryResult): void;
	    static buildImageFromResult(result: IQueryResult, endpoint: SearchEndpoint, options?: IImageUtilsOptions): string;
	}

}
declare module Coveo {
	export enum OS_NAME {
	    WINDOWS = 0,
	    MACOSX = 1,
	    UNIX = 2,
	    LINUX = 3,
	    UNKNOWN = 4,
	}
	export class OSUtils {
	    static get(nav?: Navigator): any;
	}

}
declare module Coveo {
	export interface IStreamHighlightOptions {
	    cssClass?: string;
	    regexFlags?: string;
	}
	export class StreamHighlightUtils {
	    static highlightStreamHTML(stream: string, termsToHighlight: {
	        [originalTerm: string]: string[];
	    }, phrasesToHighlight: {
	        [phrase: string]: {
	            [originalTerm: string]: string[];
	        };
	    }, options?: IStreamHighlightOptions): string;
	    static highlightStreamText(stream: string, termsToHighlight: {
	        [originalTerm: string]: string[];
	    }, phrasesToHighlight: {
	        [phrase: string]: {
	            [originalTerm: string]: string[];
	        };
	    }, options?: IStreamHighlightOptions): string;
	}

}
declare module Coveo {
	
	
	
	
	
	export class PendingSearchAsYouTypeSearchEvent extends PendingSearchEvent {
	    root: HTMLElement;
	    endpoint: AnalyticsEndpoint;
	    templateSearchEvent: ISearchEvent;
	    sendToCloud: any;
	    delayBeforeSending: number;
	    beforeResolve: Promise<PendingSearchAsYouTypeSearchEvent>;
	    private beforeUnloadHandler;
	    private armBatchDelay;
	    private toSendRightNow;
	    constructor(root: HTMLElement, endpoint: AnalyticsEndpoint, templateSearchEvent: ISearchEvent, sendToCloud: any);
	    protected handleDuringQuery(e: Event, args: IDuringQueryEventArgs): void;
	    sendRightNow(): void;
	    modifyCustomData(key: string, newData: any): void;
	    modifyEventCause(newCause: IAnalyticsActionCause): void;
	    stopRecording(): void;
	    private handleNuke();
	    private onWindowUnload();
	    private isCancelledOrFinished();
	}

}
declare module Coveo {
	
	
	
	
	
	
	export class LiveAnalyticsClient implements IAnalyticsClient {
	    endpoint: AnalyticsEndpoint;
	    rootElement: HTMLElement;
	    userId: string;
	    userDisplayName: string;
	    anonymous: boolean;
	    splitTestRunName: string;
	    splitTestRunVersion: string;
	    originLevel1: string;
	    sendToCloud: boolean;
	    isContextual: boolean;
	    private language;
	    private device;
	    private mobile;
	    private pendingSearchEvent;
	    private pendingSearchAsYouTypeSearchEvent;
	    private logger;
	    constructor(endpoint: AnalyticsEndpoint, rootElement: HTMLElement, userId: string, userDisplayName: string, anonymous: boolean, splitTestRunName: string, splitTestRunVersion: string, originLevel1: string, sendToCloud: boolean);
	    isActivated(): boolean;
	    getCurrentVisitId(): string;
	    getCurrentVisitIdPromise(): Promise<string>;
	    getCurrentEventCause(): string;
	    getCurrentEventMeta(): {
	        [key: string]: any;
	    };
	    logSearchEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta): void;
	    logSearchAsYouType<TMeta>(actionCause: IAnalyticsActionCause, meta?: TMeta): void;
	    logClickEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta, result: IQueryResult, element: HTMLElement): void;
	    logCustomEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta, element: HTMLElement): void;
	    getTopQueries(params: ITopQueries): Promise<string[]>;
	    sendAllPendingEvents(): void;
	    cancelAllPendingEvents(): void;
	    getPendingSearchEvent(): PendingSearchEvent;
	    warnAboutSearchEvent(): void;
	    private pushCustomEvent(actionCause, metaObject, element?);
	    private pushSearchEvent(actionCause, metaObject);
	    private checkToSendAnyPendingSearchAsYouType(actionCause);
	    private pushSearchAsYouTypeEvent(actionCause, metaObject);
	    private pushClickEvent(actionCause, metaObject, result, element);
	    private buildAnalyticsEvent(actionCause, metaObject);
	    private buildSearchEvent(actionCause, metaObject);
	    private buildClickEvent(actionCause, metaObject, result, element);
	    private buildCustomEvent(actionCause, metaObject, element);
	    protected getOriginLevel2(element: HTMLElement): string;
	    private buildMetaObject<TMeta>(meta);
	    private cancelAnyPendingSearchAsYouTypeEvent();
	    private resolveActiveTabFromElement(element);
	    private resolveQueryStateModel(rootElement);
	    private eventIsNotRelatedToSearchbox(event);
	    private triggerChangeAnalyticsCustomData(type, metaObject, event, data?);
	    private merge<T>(first, second);
	}

}
declare module Coveo {
	
	
	
	
	
	export class MultiAnalyticsClient implements IAnalyticsClient {
	    private analyticsClients;
	    isContextual: boolean;
	    constructor(analyticsClients?: IAnalyticsClient[]);
	    isActivated(): boolean;
	    getCurrentEventCause(): string;
	    getCurrentEventMeta(): {
	        [key: string]: any;
	    };
	    logSearchEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta): void;
	    logSearchAsYouType<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta): void;
	    logClickEvent(actionCause: IAnalyticsActionCause, meta?: IAnalyticsDocumentViewMeta, result?: IQueryResult, element?: HTMLElement): void;
	    logCustomEvent<TMeta>(actionCause: IAnalyticsActionCause, meta?: TMeta, element?: HTMLElement): void;
	    getTopQueries(params: ITopQueries): Promise<string[]>;
	    getCurrentVisitIdPromise(): Promise<string>;
	    getCurrentVisitId(): string;
	    sendAllPendingEvents(): void;
	    warnAboutSearchEvent(): void;
	    cancelAllPendingEvents(): void;
	    getPendingSearchEvent(): PendingSearchEvent;
	    private mergeTopQueries(values, pageSize?);
	}

}
declare module Coveo {
	export interface IQuickviewLoadedEventArgs {
	    duration: number;
	}
	export class QuickviewEvents {
	    static quickviewLoaded: string;
	    static openQuickview: string;
	}

}
declare module Coveo {
	
	export interface IRecommendationOptions extends ISearchInterfaceOptions {
	    mainSearchInterface?: HTMLElement;
	    userContext?: string;
	    id?: string;
	    optionsToUse?: string[];
	    sendActionsHistory?: boolean;
	    hideIfNoResults?: boolean;
	}
	/**
	 * This component is a {@link SearchInterface} that will display recommendations based on the user history.
	 * To get recommendations, the page view script must also be included in the page. View: https://github.com/coveo/coveo.analytics.js
	 * This component listens when the main search interface generates a query and it generates another to get the recommendations at the same time.
	 *
	 * This component can be included in another SearchInterface, but you need to initialize the recommendation component with Coveo('initRecommendation'), before
	 * the parent SearchInterface.
	 */
	export class Recommendation extends SearchInterface {
	    element: HTMLElement;
	    options: IRecommendationOptions;
	    analyticsOptions: {};
	    static ID: string;
	    private static NEXT_ID;
	    /**
	     * The options for the recommendation component
	     * @componentOptions
	     */
	    static options: IRecommendationOptions;
	    private mainInterfaceQuery;
	    mainQuerySearchUID: string;
	    private displayStyle;
	    constructor(element: HTMLElement, options?: IRecommendationOptions, analyticsOptions?: {}, _window?: Window);
	    getId(): string;
	    hide(): void;
	    show(): void;
	    private bindToMainSearchInterface();
	    private handleRecommendationBuildingQuery(data);
	    private handleRecommendationQuerySuccess(data);
	    private modifyQueryForRecommendation(data);
	    private addRecommendationInfoInQuery(data);
	    private getHistory();
	    private preventEventPropagation();
	    private preventEventPropagationOn(eventType, eventName?);
	    private getAllModelEvents();
	    private generateDefaultId();
	}

}
declare module Coveo {
	
	
	
	
	
	export class RecommendationAnalyticsClient extends LiveAnalyticsClient {
	    endpoint: AnalyticsEndpoint;
	    rootElement: HTMLElement;
	    userId: string;
	    userDisplayName: string;
	    anonymous: boolean;
	    splitTestRunName: string;
	    splitTestRunVersion: string;
	    originLevel1: string;
	    sendToCloud: boolean;
	    bindings: IComponentBindings;
	    private recommendation;
	    constructor(endpoint: AnalyticsEndpoint, rootElement: HTMLElement, userId: string, userDisplayName: string, anonymous: boolean, splitTestRunName: string, splitTestRunVersion: string, originLevel1: string, sendToCloud: boolean, bindings: IComponentBindings);
	    logSearchEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta): void;
	    logClickEvent<TMeta>(actionCause: IAnalyticsActionCause, meta: TMeta, result: IQueryResult, element: HTMLElement): void;
	    protected getOriginLevel2(element: HTMLElement): string;
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	export interface IAnalyticsOptions {
	    user?: string;
	    userDisplayName?: string;
	    token?: string;
	    endpoint?: string;
	    anonymous?: boolean;
	    searchHub?: string;
	    splitTestRunName?: string;
	    splitTestRunVersion?: string;
	    sendToCloud?: boolean;
	    organization?: string;
	}
	/**
	 * This component logs all user actions performed in the search interface and sends them to a REST web service exposed through the Coveo Cloud platform.<br/>
	 * You can use this data to evaluate how users are interacting with the search interface, improve relevance and produce analytics dashboards in the Coveo platform.
	 *
	 * # Sending Custom Events
	 * In some scenarios, you want to send custom data to the Coveo Cloud analytics (see Coveo Cloud Usage Analytics). The Coveo JavaScript Search Framework offers helpers to communicate with the Coveo Analytics REST API, so you do not have to write code to call the API directly.
	 *
	 * 1. First, you need to craft your custom event cause and meta.
	 * ```
	 *   var customEventCause = {name: 'customEventName', type:'customEventType'};
	 *   var metadata = {key1: "value1", key2:"value2"};
	 * ```
	 *
	 * 2. Sending a custom event.
	 * ```
	 *   Coveo.logCustomEvent(document.querySelector('#search'), customEventCause, metadata);
	 *      // OR (using the jquery extension)
	 *   $('#search').coveo('logCustomEvent', customEventCause, metadata);
	 * ```
	 *
	 * 3. Sending a custom search event<br/>(**NB : If you want to log a searchEvent, be sure to always call the helper before you call executeQuery.**)
	 * ```
	 * function myCustomButtonWasClicked() {
	 *      Coveo.logSearchEvent(document.querySelector('#search'), customEventCause, metadata);
	 *      Coveo.executeQuery(document.querySelector('#search'));
	 *      // OR (using the jquery extension)
	 *      $('#search').coveo('logSearchEvent', customEventCause, metadata);
	 *      $('#search').coveo('executeQuery');
	 * }
	 * ```
	 *
	 * 4. Sending a custom searchAsYouType event<br/>(NB : **If you want to log a searchAsYouTypeEvent, be sure to always call the helper before you call executeQuery.**)
	 * ```
	 * function myCustomButtonWasClicked() {
	 *      Coveo.logSearchAsYouTypeEvent(document.querySelector('#search'), customEventCause, metadata);
	 *      Coveo.executeQuery(document.querySelector('#search'));
	 *      // OR (using the jquery extension)
	 *      $('#search').coveo('logSearchAsYouTypeEvent', customEventCause, metadata);
	 *      $('#search').coveo('executeQuery');
	 * }
	 * ```
	 *
	 * 5. Sending a custom click event
	 * ```
	 * Coveo.logClickEvent(document.querySelector('#search'), customEventCause, metadata, result);
	 * // OR (using the jquery extension)
	 * $('#search').coveo('logClickEvent', customEventCause, metadata, result);
	 * ```
	 */
	export class Analytics extends Component {
	    element: HTMLElement;
	    options: IAnalyticsOptions;
	    bindings: IComponentBindings;
	    static ID: string;
	    /**
	     * Options for the component
	     * @componentOptions
	     */
	    static options: IAnalyticsOptions;
	    /**
	     * A reference to the analyticsClient, which will perform the heavy duty part of logging the actual events on the service.
	     */
	    client: IAnalyticsClient;
	    /**
	     * Create a new Analytics component. Create the {@link IAnalyticsClient}
	     * @param element The HTMLElement on which the component will be instantiated.
	     * @param options The options for the Analytics.
	     * @param bindings The bindings that the component requires to function normally. If not set, will automatically resolve them (With slower execution time)
	     */
	    constructor(element: HTMLElement, options?: IAnalyticsOptions, bindings?: IComponentBindings);
	    /**
	     * Log a search event on the service, using a cause and a meta object.<br/>
	     * Note that the event will be sent on the service when a query successfully return, not immediately after calling this method.<br/>
	     * Normally, this should be called using the following "format" : <br/>
	     * usageAnalytics.logSearchEvent<SomeMeta>({name : 'foo', type : 'bar'}, <SomeMeta>{'key':'value'});<br/>
	     * this.queryController.executeQuery();<br/>
	     * This will queue up an analytics search event. Then the query is executed. The search event will be sent to the service when the query successfully complete.<br/>
	     * @param actionCause
	     * @param meta Can be an empty object ( {} )
	     */
	    logSearchEvent<T>(actionCause: IAnalyticsActionCause, meta: T): void;
	    /**
	     * Log a search as you type event on the service, using a cause and a meta object.<br/>
	     * This is extremely similar to a search event, except that search as you type, by definition, will be frequently called.<br/>
	     * The {@link PendingSearchAsYouTypeEvent} will take care of logging only the "relevant" last event : After 5 seconds of no event logged, or after another search event is triggered somewhere else in the interface.<br/>
	     * This is to ensure that we do not needlessly log every single partial query, which would make the reporting very confusing.
	     * @param actionCause
	     * @param meta Can be an empty object ( {} )
	     */
	    logSearchAsYouType<T>(actionCause: IAnalyticsActionCause, meta: T): void;
	    /**
	     * Log a custom event on the service. A custom event can be used to create customized report, or to track events which are not queries or document view.
	     * @param actionCause
	     * @param meta
	     * @param element The HTMLElement that was interacted with for this custom event.
	     */
	    logCustomEvent<T>(actionCause: IAnalyticsActionCause, meta: T, element?: HTMLElement): void;
	    /**
	     * Log a click event. A click event can be understood as a document view.<br/>
	     * eg : Clicking on a result link of opening a quickview.<br/>
	     * This event will be logged immediately on the service.
	     * @param actionCause
	     * @param meta Can be an empty object ( {} )
	     * @param result The result that was clicked
	     * @param element The HTMLElement that was clicked in the interface
	     */
	    logClickEvent(actionCause: IAnalyticsActionCause, meta: IAnalyticsDocumentViewMeta, result: IQueryResult, element?: HTMLElement): void;
	    protected initializeAnalyticsEndpoint(): AnalyticsEndpoint;
	    private initializeAnalyticsClient();
	    private instantiateAnalyticsClient(endpoint, elementToInitializeClient, isRecommendation);
	    private retrieveInfoFromDefaultSearchEndpoint();
	    private handleBuildingQuery(data);
	    private handleSearchHubChanged(data);
	    private handleQueryError(data);
	    static create(element: HTMLElement, options: IAnalyticsOptions, bindings: IComponentBindings): NoopAnalyticsClient;
	    private static ignoreElementsInsideRecommendationInterface(found);
	    private static getClient(element, options, bindings);
	}

}
declare module Coveo {
	
	
	
	
	
	/**
	 * Initialize the framework with a basic search interface. Calls {@link Initialization.initSearchInterface}.<br/>
	 * If using the jQuery extension, this is called using <code>$('#root').coveo('init');</code>
	 * @param element The root of the interface to initialize
	 * @param options JSON options for the framework eg : <code>{Searchbox : {enableSearchAsYouType: true}}</code>
	 */
	export function init(element: HTMLElement, options?: any): void;
	/**
	 * Initialize the framework with a standalone search box. Calls {@link Initialize.initStandaloneSearchInterface}.<br/>
	 * If using the jQuery extension, this is called using <code>$('#root').coveo('initSearchbox');</code>
	 * @param element The root of the interface to initialize
	 * @param searchPageUri The search page on which to redirect when there is a query
	 * @param options JSON options for the framework eg : <code>{Searchbox : {enableSearchAsYouType: true}}</code>
	 */
	export function initSearchbox(element: HTMLElement, searchPageUri: string, options?: any): void;
	/**
	 * Initialize the framework with a recommendation interface. Calls {@link Initialization.initRecommendationInterface}.<br/>
	 * If using the jQuery extension, this is called using <code>$('#root').coveo('initRecommendation');</code>
	 * @param element The root of the interface to initialize
	 * @param mainSearchInterface The search interface to link with the recommendation interface. View {@link Recommendation}
	 * @param userContext The user context to pass with the query generated in the recommendation interface. View {@link Recommendation}
	 * @param options JSON options for the framework eg : <code>{Searchbox : {enableSearchAsYouType: true}}</code>
	 */
	export function initRecommendation(element: HTMLElement, mainSearchInterface?: HTMLElement, userContext?: {
	    [name: string]: any;
	}, options?: any): void;
	/**
	 * Execute a standard query. Active component in the interface will react to events/ push data in the query / handle the query success or failure as needed.<br/>
	 * It triggers a standard query flow for which the standard component will perform their expected behavior.<br/>
	 * If you wish to only perform a query on the index to retrieve result (without the component reacting), look into {@link SearchInterface.search} instead.<br/>
	 * Calling this method is the same as calling {@link QueryController.executeQuery}
	 * @param element The root of the interface to initialize
	 */
	export function executeQuery(element: HTMLElement): Promise<IQueryResults>;
	/**
	 * Perform operation on the state ({@link QueryStateModel} of the interface.<br/>
	 * Get the complete {@link QueryStateModel} object : <code>Coveo.state(element)</code><br/>
	 * Get an attribute from the {@link QueryStateModel} : <code>Coveo.state(element, 'q')</code> Can be any attribute.<br/>
	 * Set an attribute on the {@link QueryStateModel} : <code>Coveo.state(element, 'q', 'foobar')</code> Can be any attribute.<br/>
	 * Set multiple attribute on the {@link QueryStateModel} : <code>Coveo.state(element, {'q' : 'foobar' , sort : 'relevancy'})</code> Can be any attribute.<br/>
	 * If using the jQuery extension, this is called using <code>$('#root').coveo('state');</code>
	 * @param element The root of the interface for which to access the {@link QueryStateModel}
	 * @param args
	 * @returns {any}
	 */
	export function state(element: HTMLElement, ...args: any[]): any;
	/**
	 * Get the component bound on the given HTMLElement
	 * @param element The HTMLElement for which to get the component instance
	 * @param componentClass If multiple component are bound to a single HTMLElement, you need to specify which component you wish to get
	 * @param noThrow By default, the get method will throw if there is no component bound, or if there are multiple component and no componentClass is specified. This suppress the error if set to true.
	 * @returns {Component}
	 */
	export function get(element: HTMLElement, componentClass?: any, noThrow?: boolean): BaseComponent;
	/**
	 * Log a custom event on the Coveo Usage Analytics service.
	 * @param element The root of the interface for which to log analytics event
	 * @param customEventCause The cause of the event
	 * @param metadata The metadata associated with the event (JSON key value)
	 */
	export function logCustomEvent(element: HTMLElement, customEventCause: IAnalyticsActionCause, metadata: IStringMap<string>): void;
	/**
	 * Log a search event on the Coveo Usage Analytics service
	 * @param element The root of the interface for which to log analytics event
	 * @param searchEventCause The cause of the event
	 * @param metadata The metadata associated with the event (JSON key value)
	 */
	export function logSearchEvent(element: HTMLElement, searchEventCause: IAnalyticsActionCause, metadata: IStringMap<string>): void;
	/**
	 * Log a search as you type event on the Coveo Usage Analytics service.<br/>
	 * It is a bit different from a standard search event, as it will wait 5 second before sending the final search as you type event.
	 * @param element The root of the interface for which to log analytics event
	 * @param searchAsYouTypeEventCause The cause of the event
	 * @param metadata The metadata associated with the event (JSON key value)
	 */
	export function logSearchAsYouTypeEvent(element: HTMLElement, searchAsYouTypeEventCause: IAnalyticsActionCause, metadata: IStringMap<string>): void;
	/**
	 * Log a click event on the Coveo Usage Analytics service.
	 * @param element The root of the interface for which to log analytics event
	 * @param clickEventCause The cause of the event
	 * @param metadata The metadata associated with the event (JSON key value)
	 * @param result The result that was clicked
	 */
	export function logClickEvent(element: HTMLElement, clickEventCause: IAnalyticsActionCause, metadata: IStringMap<any>, result: IQueryResult): void;
	/**
	 * Pass options to the framework, before it is initialized ({@link init}).<br/>
	 * All the options passed with this calls will be merged together on initialization
	 * @param element The root of the interface for which you wish to set options
	 * @param optionsToSet JSON options for the framework eg : <code>{Searchbox : {enableSearchAsYouType: true}}</code>
	 */
	export function options(element: HTMLElement, optionsToSet?: any): void;
	/**
	 * Patch the given methodName on an instance of a component bound to an HTMLElement with a new handler
	 * @param element
	 * @param methodName
	 * @param handler
	 */
	export function patch(element: HTMLElement, methodName: string, handler: (...args: any[]) => any): void;
	export function initBox(element: HTMLElement, ...args: any[]): void;
	export function nuke(element: HTMLElement): void;

}
declare module Coveo {
	
	
	export class DefaultQuickviewTemplate extends Template {
	    constructor();
	    instantiateToString(queryResult?: IQueryResult): string;
	}

}
declare module Coveo {
	
	
	
	export interface IQuickviewDocumentOptions {
	    maximumDocumentSize?: number;
	}
	/**
	 * The QuickviewDocument component is meant to exist within Result Templates, more specifically inside a {@link Quickview} Component.
	 * The sole purpose of this component is to include an iframe which will load the correct HTML version of the current document.
	 * By default, this component is included in the default template for a {@link Quickview} Component.
	 */
	export class QuickviewDocument extends Component {
	    element: HTMLElement;
	    options: IQuickviewDocumentOptions;
	    result: IQueryResult;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IQuickviewDocumentOptions;
	    private iframe;
	    private header;
	    private termsToHighlightWereModified;
	    private keywordsState;
	    /**
	     * Create a new instance of the component
	     * @param element
	     * @param options
	     * @param bindings
	     * @param result
	     */
	    constructor(element: HTMLElement, options?: IQuickviewDocumentOptions, bindings?: IComponentBindings, result?: IQueryResult);
	    createDom(): void;
	    open(): void;
	    protected renderHTMLDocument(iframe: HTMLIFrameElement, html: HTMLDocument): void;
	    private renderErrorReport(iframe, errorStatus);
	    private writeToIFrame(iframe, content);
	    private writeToIFrame(iframe, content);
	    private wrapPreElementsInIframe(iframe);
	    private triggerQuickviewLoaded(beforeLoad);
	    computeHighlights(window: Window): string[];
	    private getHighlightIdParts(element);
	    private getHighlightInnerText(element);
	    private getHightlightEmbeddedWordIdParts(element);
	    private resolveOriginalTermFromHighlight(highlight);
	    private buildWordButton(wordState, window);
	    private navigate(state, backward, window);
	    private buildHeader();
	    private buildIFrame();
	    private getScrollingElement(iframeWindow);
	    private isNewQuickviewDocument(iframeWindow);
	    private handleTermsToHighlight(termsToHighlight, queryObject);
	    private checkIfTermsToHighlightWereModified(termsToHighlight);
	    private getSaturatedColor(color);
	    private animateScroll(scroll, scrollLeftValue, scrollTopValue, duration?);
	}

}
declare module Coveo {
	
	
	
	
	export interface IQuickviewOptions {
	    title?: string;
	    showDate?: boolean;
	    contentTemplate?: Template;
	    enableLoadingAnimation?: boolean;
	    loadingAnimation?: HTMLElement;
	    alwaysShow?: boolean;
	    size?: string;
	}
	/**
	 * This component is meant to exist within a result template.
	 * It allows to create a button/link inside the result list that opens a modal box for a given result.
	 *
	 * Most of the time, this component will reference a {@link QuickviewDocument} in it's content template.
	 *
	 * # Choosing what to display for the Quickview
	 * The Quick View uses any HTML structure you put inside its tag and uses that as the content of the dialog box. This content can thus be any element you decide, using your CSS and your structure.
	 *
	 * > Example
	 * > You can change the appearance of the Quick View link by adding HTML inside the body of the div.
	 * > You can change the content of the Quick View link by specifying a template id.
	 *
	 * ```html
	 * <!-- This would change the appearance of the quickview button itself in the result. -->
	 * <div class="CoveoQuickview" data-template-id="TemplateId">
	 *   <span>Click here for Quickview</span>
	 * </div>
	 *
	 * <!-- This would modify the content of the quickview when it is opened in the modal box -->
	 * <script class='result-template' type='text/underscore' id='TemplateId' >
	 *   <div>
	 *     <span>This is the content that will be displayed when you open the Quick View. You can also include any other Coveo components.</span>
	 *     <table class="CoveoFieldTable">
	 *       <tr data-field="@liboardshorttitle" data-caption="Board" />
	 *       <tr data-field="@licategoryshorttitle" data-caption="Category" />
	 *       <tr data-field="@sysauthor" data-caption="Author" />
	 *     </table>
	 *   </div>
	 * </script>
	 *
	 * <!-- Note that this is all optional : Just including a <div class='CoveoQuickview'></div> will do the job most of the time, and will include a default template and default button appearance -->
	 * ```
	 */
	export class Quickview extends Component {
	    element: HTMLElement;
	    options: IQuickviewOptions;
	    bindings: IResultsComponentBindings;
	    result: IQueryResult;
	    static ID: string;
	    static fields: string[];
	    /**
	     * @componentOptions
	     */
	    static options: IQuickviewOptions;
	    private modalbox;
	    private bindedHandleEscapeEvent;
	    constructor(element: HTMLElement, options?: IQuickviewOptions, bindings?: IResultsComponentBindings, result?: IQueryResult);
	    /**
	     * Open the quickview
	     */
	    open(): void;
	    /**
	     * Close the quickview
	     */
	    close(): void;
	    getHashId(): string;
	    private bindClick(result);
	    private bindQuickviewEvents(openerObject);
	    private animateAndOpen();
	    private createModalBox(openerObject);
	    private prepareOpenQuickviewObject();
	    private prepareQuickviewContent(loadingAnimation);
	    private bindEscape();
	    private bindIFrameEscape();
	    private closeQuickview();
	    private setQuickviewSize();
	    private handleEscapeEvent(e);
	}

}
declare module Coveo {
	
	
	
	
	export interface IIconOptions {
	    value?: string;
	    small?: boolean;
	    withLabel?: boolean;
	    labelValue?: string;
	}
	/**
	 * An icon component is a Result template component which outputs the corresponding icon for a give filetype. It uses the
	 * available icons in the framework, and if no suitable one are found, it fallback on a generic icon.
	 */
	export class Icon extends Component {
	    element: HTMLElement;
	    options: IIconOptions;
	    result: IQueryResult;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IIconOptions;
	    static fields: string[];
	    /**
	     * Create a new Icon component
	     * @param element
	     * @param options
	     * @param bindings
	     * @param result
	     */
	    constructor(element: HTMLElement, options?: IIconOptions, bindings?: IComponentBindings, result?: IQueryResult);
	    static createIcon(result: IQueryResult, options?: IIconOptions, element?: HTMLElement, bindings?: IComponentBindings): HTMLElement;
	    static shouldDisplayLabel(options: IIconOptions, bindings: IComponentBindings): boolean;
	    static preprocessIconInfo(options: IIconOptions, info: IFileTypeInfo): IFileTypeInfo;
	}

}
declare module Coveo {
	
	
	export class DefaultRecommendationTemplate extends Template {
	    instantiateToString(object?: IQueryResult): string;
	    instantiateToElement(object?: IQueryResult): HTMLElement;
	}

}
declare module Coveo {
	
	
	
	
	
	export interface IResultListOptions {
	    resultContainer?: HTMLElement;
	    resultTemplate?: Template;
	    resultOptions?: {};
	    waitAnimationContainer?: HTMLElement;
	    enableInfiniteScroll?: boolean;
	    infiniteScrollPageSize?: number;
	    infiniteScrollContainer?: HTMLElement | Window;
	    waitAnimation?: string;
	    mobileScrollContainer?: HTMLElement;
	    enableInfiniteScrollWaitingAnimation?: boolean;
	    fieldsToInclude?: string[];
	    autoSelectFieldsToInclude?: boolean;
	}
	/**
	 * This component is responsible for displaying the results of the current query using one or more result templates.<br/>
	 * It supports many additional features such as infinite scrolling.
	 *
	 * # Examples / samples
	 * This contains some quick example. Refer to result templates on developers.coveo.com for more information.
	 *
	 * ```html
	 * <!-- A very simple result list with a single underscore template.
	 * The template has no condition : It will load for all results.
	 * Every results will show the same template. -->
	 *
	 * <div class="CoveoResultList">
	 *   <script class="result-template" type="text/underscore" id='MyDefaultTemplate'>
	 *     <div>
	 *       <a class='CoveoResultLink'>Hey, click on this ! <%- title %></a>
	 *     </div>
	 *   </script>
	 * </div>
	 *
	 * <!-- 2 different template in the same result list : The first template has a condition attribute, the second one does not.
	 *
	 * The first condition will be evaluated against each result. If a result match this condition (in this case if the result.raw.objecttype property in the JSON equals MyObjectType) then the template will be rendered and the next template won't be rendered or evaluated for this result. -->
	 *
	 * If the result does not match the first template, the next one will be evaluated. Since the second one has no condition, it is always considered "true" and will load as a fallback.
	 *
	 * This process will repeat for each result that was returned by the query to the index. -->
	 *
	 * <div class="CoveoResultList">
	 *   <script class="result-template" type="text/underscore" data-condition='raw.objecttype==MyObjectType' id='MyObjectTypeTemplate'>
	 *     <div>
	 *       <a class='CoveoResultLink'>Hey, click on this ! <%- title %></a>
	 *       <div class='CoveoExcerpt'></div>
	 *       <span>This is a result for the type : <%- raw.objecttype %></span>
	 *     </div>
	 *   </script>
	 *
	 *   <script class="result-template" type="text/underscore">
	 *     <div>
	 *       <a class='CoveoResultLink'>Hey, click on this ! <%- title %></a>
	 *     </div>
	 *   </script>
	 * </div>
	 *
	 * <!-- 2 different template in the same result list : Both have a data-condition attribute.
	 *
	 * Same as before : the condition will be evaluated against all results.
	 *
	 * Since there is no "default" template with no condition specified, the framework will fallback on the default templates included in the framework if no template match a given result. This is to ensure that all results get rendered -->
	 *
	 * <div class="CoveoResultList">
	 *   <script class="result-template" type="text/underscore" data-condition='raw.objecttype==MyObjectType' id='MyObjectTypeTemplate'>
	 *     <div>
	 *       <a class='CoveoResultLink'>Hey, click on this ! <%- title %></a>
	 *       <div class='CoveoExcerpt'></div>
	 *       <span>This is a result for the type : <%- raw.objecttype %></span>
	 *      </div>
	 *   </script>
	 *
	 *   <script class="result-template" type="text/underscore" data-condition='raw.objecttype==MySecondObjectType' id='MySecondObjectTypeTemplate'>
	 *     <div>
	 *       <span class='CoveoIcon'></span>
	 *       <a class='CoveoResultLink'></a>
	 *     </div>
	 *     <div class='CoveoExcerpt'></div>
	 *     <div class='CoveoPrintableUri'></div>
	 *   </script>
	 * </div>
	 * ```
	 */
	export class ResultList extends Component {
	    element: HTMLElement;
	    options: IResultListOptions;
	    bindings: IComponentBindings;
	    static ID: string;
	    /**
	     * The options for the ResultList
	     * @componentOptions
	     */
	    static options: IResultListOptions;
	    static resultCurrentlyBeingRendered: IQueryResult;
	    currentlyDisplayedResults: IQueryResult[];
	    private fetchingMoreResults;
	    private reachedTheEndOfResults;
	    /**
	     * Create a new ResultList.<br/>
	     * Bind various event related to queries (eg : on querySuccess -> renderResults)<br/>
	     * Bind scroll event if infinite scrolling is enabled.
	     * @param element The HTMLElement on which the element will be instantiated.
	     * @param options The options for the ResultList.
	     * @param bindings The bindings that the component requires to function normally. If not set, will automatically resolve them (With slower execution time)
	     * @param elementClassId The class that this component should instantiate. By default this will be CoveoResultList. This is used by component that extends the base ResultList
	     */
	    constructor(element: HTMLElement, options?: IResultListOptions, bindings?: IComponentBindings, elementClassId?: string);
	    /**
	     * Empty the current result list content and append the given array of HTMLElement.<br/>
	     * Can append to existing elements in the result list, or replace them.<br/>
	     * Triggers the newResultDiplayed and newResultsDisplayed event
	     * @param resultsElement
	     * @param append
	     */
	    renderResults(resultsElement: HTMLElement[], append?: boolean): void;
	    /**
	     * Build and return an array of HTMLElement with the given result set.
	     * @param results
	     */
	    buildResults(results: IQueryResults): HTMLElement[];
	    /**
	     * Build and return an HTMLElement for the given result.
	     * @param result
	     * @returns {HTMLElement}
	     */
	    buildResult(result: IQueryResult): HTMLElement;
	    /**
	     * Execute a query to fetch new results. After the query is done, render those new results.<br/>
	     * Assert that there is actually more results to display by checking that the last query returned as many results as requested.<br/>
	     * Assert that the result list is not currently fetching results
	     * @param count The number of results to fetch and display
	     */
	    displayMoreResults(count: number): void;
	    /**
	     * Get the list of currently displayed result
	     * @returns {IQueryResult[]}
	     */
	    getDisplayedResults(): IQueryResult[];
	    /**
	     * Get the list of currently displayed result HTMLElement
	     * @returns {HTMLElement[]}
	     */
	    getDisplayedResultsElements(): HTMLElement[];
	    protected autoCreateComponentsInsideResult(element: HTMLElement, result: IQueryResult): void;
	    protected triggerNewResultDisplayed(result: IQueryResult, resultElement: HTMLElement): void;
	    protected triggerNewResultsDisplayed(): void;
	    private handleDuringQuery();
	    private handleQueryError();
	    private handleQuerySuccess(data);
	    private handleScrollOfResultList();
	    private handlePageChanged();
	    private handleNewQuery();
	    private handleBuildingQuery(args);
	    private getAutoSelectedFieldsToInclude();
	    private isCurrentlyFetchingMoreResults();
	    private isScrollingOfResultListAlmostAtTheBottom();
	    private isScrollAtBottomForWindowElement();
	    private isScrollAtBottomForHtmlElement();
	    hasPotentiallyMoreResultsToDisplay(): boolean;
	    private cancelFetchingMoreResultsIfNeeded();
	    private showOrHideElementsDependingOnState(hasQuery, hasResults);
	    private showWaitingAnimation();
	    private hideWaitingAnimation();
	    private showWaitingAnimationForInfiniteScrolling();
	    private hideWaitingAnimationForInfiniteScrolling();
	    private static getDefaultTemplate(e);
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	/**
	 * The core template helpers provided by default.
	 *
	 * Example usage (using Underscore templating):
	 *
	 * ```
	 * <%= helperName(argument1, argument2) %>
	 * ```
	 */
	export interface ICoreHelpers {
	    /**
	     * Shortens a string so that its length does not exceed a specific number of
	     * characters. An ellipsis is appended to the string if it exceeds the
	     * maximum length.
	     *
	     * - `value`: The string to shorten.
	     * - `length`: The maximum length of the resulting string.
	     * - `highlights`: Optional. If provided, the string will be highlighted
	     *   using this highlight information.
	     * - `cssClass`: Optional. When highlighting, the name of the CSS class to use.
	     */
	    shorten: (content: string, length: number, highlights?: IHighlight[], cssClass?: string) => string;
	    /**
	     * Shortens a string using an algorithm suitable for file paths. The helper
	     * will insert an ellipsis in the string where text has been removed when
	     * the path exceeds the maximum length.
	     *
	     * - `value`: The path to shorten.
	     * - `length`: The maximum length of the resulting string.
	     * - `highlights`: Optional. If provided, the string will be highlighted using
	     *   this highlight information.
	     * - `cssClass`: Optional. When highlighting, the name of the CSS class to use.
	     */
	    shortenPath: (content: string, length: number, highlights?: IHighlight[], cssClass?: string) => string;
	    /**
	     * Shortens a string using an algorithm suitable for URIs. The helper will
	     * insert an ellipsis in the string where text has been removed when the URI
	     * exceeds the maximum length.
	     *
	     * - `value`: The URI to shorten.
	     * - `length`: The maximum length of the resulting string.
	     * - `highlights`: Optional. If provided, the string will be highlighted
	     *   using this highlight information.
	     * - `cssClass`: Optional. When highlighting, the name of the CSS class to use.
	     */
	    shortenUri: (content: string, length: number, highlights?: IHighlight[], cssClass?: string) => string;
	    /**
	     * Highlights a string using the provided highlight information.
	     *
	     * - `highlights`: The highlight information to use.
	     * - `cssClass`: Optional. The name of the CSS class to use for highlighting.
	     */
	    highlight: (content: string, highlights?: IHighlight[], cssClass?: string) => string;
	    /**
	     * This helper highlights the provided terms in a given string.<br/>
	     * By default, the terms to highlight are the current query and the
	     * associated stemming words from the index.
	     *
	     * - `content`: The string content to highlight
	     * - `termsToHighlight`: The terms to highlight (see {@link IHighlightTerm})
	     * - `phraseToHighlight`: The phrases to highlight (see {@link IHighlightPhrase})
	     * - `options`: Optional. The options defined below as {@link IStreamHighlightOptions}
	     */
	    highlightStreamText: (content: string, termsToHighlight: IHighlightTerm, phrasesToHighlight: IHighlightPhrase, options?: IStreamHighlightOptions) => string;
	    /**
	     * This helper operates exactly like the {@link highlightStreamText} helper, except
	     * that it should be used to highlight HTML content. The helper takes care
	     * of not highlighting the HTML markup.
	     *
	     * - `content`: The string content to highlight
	     * - `termsToHighlight`: The terms to highlight (see {@link IHighlightTerm})
	     * - `phraseToHighlight`: The phrases to highlight (see {@link IHighlightPhrase})
	     * - `options`: Optional. The options defined below as {@link IStreamHighlightOptions}
	     */
	    highlightStreamHTML: (content: string, termsToHighlight: IHighlightTerm, phrasesToHighlight: IHighlightPhrase, options?: IStreamHighlightOptions) => string;
	    /**
	     * Formats a numeric value using the format string.
	     *
	     * - `value`: The numeric value to format.
	     * - `format`: The format string to use. The options available are defined by
	     *   the [Globalize](https://github.com/klaaspieter/jquery-global#numbers) library.
	     */
	    number: (content: string, format: string) => string;
	    /**
	     * Formats a date value to a date-only string using the specified options.
	     *
	     * - `value`: The Date value to format.
	     * - `options`: The options to use (see IDateToStringOptions).
	     */
	    date: (content: any, options?: IDateToStringOptions) => string;
	    /**
	     * Formats a date value to a time-only string using the sepcified options.
	     *
	     * - `value`: The Date value to format.
	     * - `options`: The options to use (see IDateToStringOptions).
	     */
	    time: (content: any, options?: IDateToStringOptions) => string;
	    /**
	     * Formats a date value to a date and time string using the specified
	     * options.
	     *
	     * - `value`: The Date value to format.
	     * - `options`: The options to use (see IDateToStringOptions).
	     */
	    dateTime: (content: any, options?: IDateToStringOptions) => string;
	    /**
	     * Formats a currency value to a string using the specified options.
	     *
	     * - `value`: The number value to format.
	     * - `options`: The options to use (see ICurrencyToStringOptions).
	     */
	    currency: (content: any, options?: ICurrencyToStringOptions) => string;
	    /**
	     * Formats a date value to a date and time string using options suitable for
	     * email dates
	     *
	     * - `value`: The Date value to format.
	     * - `options`: The options to use (see IDateToStringOptions).
	     */
	    emailDateTime: (content: any, options?: IDateToStringOptions) => string;
	    /**
	     * Renders one or several email values in `mailto:` hyperlinks.
	     *
	     * - `value`: The string that contains a list of semicolon-separated email
	     *   values. When multiple values are passed, each value is displayed in a
	     *   separate hyperlink.
	     * - `companyDomain`: The string that contains your own domain (e.g.,
	     *   coveo.com). When specified, this parameter allows email addresses
	     *   coming from your own domain to be displayed in a shortened format
	     *   (e.g., Full Name), whereas email addresses coming from an external
	     *   domain will be displayed in an extended format (e.g., Full Name
	     *   (domain.com)). If this parameter is not specified, then the shortened
	     *   format will automatically be used.
	     * - `me`: The string that contains the current username. If it is
	     *   specified, then the email address containing the current username will
	     *   be replaced by the localized string 'Me'.
	     * - `lengthLimit`: The number of email addresses that you want to display
	     *   before an ellipse is added (e.g., 'From Joe, John and 5 others').<br/>
	     *   The default value is 2.
	     * - `truncateName`: When the username is available from the email address,
	     *   then you can specify if you want to truncate the full name. (e.g.,
	     *   'John S.' instead of 'John Smith').<br/>
	     *   The default value is `false`.
	     */
	    email: (value: string, companyDomain?: string, me?: string, lengthLimit?: number, truncateName?: boolean) => string;
	    /**
	     * Formats a clickable HTML link (`<a>`).
	     *
	     * - `href`: The link URI
	     * - `options`: The options to use (see {@link IAnchorUtilsOptions})
	     */
	    anchor: (href: string, options?: IAnchorUtilsOptions) => string;
	    /**
	     * Formats an HTML image tag (`<img>`).
	     *
	     * - `src`: The image source URI
	     * - `options`: The options to use (see {@link IImageUtilsOptions})
	     */
	    image: (src: string, options?: IImageUtilsOptions) => string;
	    /**
	     * Formats an HTML image tag (`<img>`), and automatically uses the result
	     * object to query the REST API to get the thumbnail for this result. For
	     * example, this can be used to great effect when designing a template
	     * showing users or preview of files.
	     * - `result`: The current result object inside your template. In
	     *   underscore, it is referenced as `obj`. Optional, by default the result
	     *   will be resolved automatically from your current template function (
	     *   Meaning the nearest result in the current call stack execution inside
	     *   your template)
	     * - `endpoint`: Optional. The name of the endpoint to use for your
	     *   thumbnail. Default is default.
	     * - `options`: The options to use (see {@link IImageUtilsOptions}).
	     */
	    thumbnail: (result?: IQueryResult, endpoint?: string, options?: IImageUtilsOptions) => string;
	    /**
	     * Generates an icon based on the file type of the current result. The icon
	     * will be contained inside a `<span>` element with the appropriate CSS
	     * class.
	     *
	     * - `result`: The current result object inside your template. In
	     *   underscore, it is referenced as `obj`. *Optional*, by default the result
	     *   will be resolved automatically from your current template function (
	     *   Meaning the nearest result in the current call stack execution inside
	     *   your template)
	     * - `options`: The options to use (see {@link IIconOptions}).
	     */
	    fromFileTypeToIcon: (result?: IQueryResult, options?: IIconOptions) => string;
	    /**
	     * Loads a partial template in the current template, by passing the ID of
	     * the template to load, the condition for which this template should be
	     * loaded, and the context object (the object that the loaded template will
	     * use as its data). By default, the context object will be the same as the
	     * template that called this helper function. So, for example, in a
	     * ResultList Component, the contextObject would, by default, be the Query
	     * Results.
	     *
	     * - `templateId`: the ID of the template to load.
	     * - `condition`: The boolean condition to determine if this template should
	     *   load for this result set. Most of the time this would be a condition of
	     *   the type if raw.somefield == 'something'.
	     * - `contextObject`: The object that should be used by the loaded template
	     *   as its contextObject.
	     */
	    loadTemplate: (templateId: string, condition?: boolean, contextObject?: any) => string;
	}
	export class CoreHelpers {
	    constructor();
	}

}
declare module Coveo {
	
	
	export interface IAggregateOptions {
	    field: string;
	    operation?: string;
	    format?: string;
	}
	/**
	 * This simple component allows to display the result on an aggregate operation on the index.<br/>
	 * It hook itself on the query to add a new group by request, then display the result.
	 */
	export class Aggregate extends Component {
	    element: HTMLElement;
	    options: IAggregateOptions;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IAggregateOptions;
	    private index;
	    /**
	     * Create a new Aggregate component
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: IAggregateOptions, bindings?: IComponentBindings);
	    private handleBuildingQuery(args);
	    private handleQuerySuccess(args);
	}

}
declare module Coveo {
	
	
	export class QueryboxQueryParameters {
	    private options;
	    constructor(options: IQueryboxOptions);
	    addParameters(queryBuilder: QueryBuilder, lastQuery: string): void;
	}

}
declare module Coveo {
	
	
	export interface IQueryboxOptions {
	    enableSearchAsYouType?: boolean;
	    searchAsYouTypeDelay?: number;
	    enableQuerySyntax?: boolean;
	    enableWildcards?: boolean;
	    enableQuestionMarks?: boolean;
	    enableLowercaseOperators?: boolean;
	    enablePartialMatch?: boolean;
	    partialMatchKeywords?: number;
	    partialMatchThreshold?: string;
	    autoFocus?: boolean;
	    placeholder?: string;
	    triggerQueryOnClear?: boolean;
	}
	/**
	 * A component that allows a user to enter a query inside an input.<br/>
	 * The component will trigger a query when submitted (the 'Enter' keypress) and log the proper analytics data.<br/>
	 * It must be instantiated on a div (and not directly on an input element) : This is for styling purpose (ghost type ahead, for example).
	 */
	export class Querybox extends Component {
	    element: HTMLElement;
	    options: IQueryboxOptions;
	    bindings: IComponentBindings;
	    static ID: string;
	    /**
	     * The options for the Querybox.
	     * @componentOptions
	     */
	    static options: IQueryboxOptions;
	    magicBox: Coveo.MagicBox.Instance;
	    private lastQuery;
	    private searchAsYouTypeTimeout;
	    /**
	     * Create a new Querybox.<br/>
	     * Create a new Coveo.Magicbox instance and wrap magic box method (on blur, on submit etc).<br/>
	     * Bind event on buildingQuery and on redirection (for standalone box).
	     * @param element The HTMLElement on which the element will be instantiated. This cannot be an HTMLInputElement for technical reason
	     * @param options The options for the querybox.
	     * @param bindings The bindings that the component requires to function normally. If not set, will automatically resolve them (With slower execution time)
	     */
	    constructor(element: HTMLElement, options?: IQueryboxOptions, bindings?: IComponentBindings);
	    /**
	     * Trigger a query. The current input content will be added to the query<br/>
	     * If the content of the input has not changed since the last submit, no new query will be triggered.
	     */
	    submit(): void;
	    /**
	     * Set the content of the input
	     * @param text The string to set in the input
	     */
	    setText(text: string): void;
	    /**
	     * Clear the content of the input
	     */
	    clear(): void;
	    /**
	     * Get the current content of the input
	     * @returns {string}
	     */
	    getText(): string;
	    getResult(): Coveo.MagicBox.Result;
	    getDisplayedResult(): Coveo.MagicBox.Result;
	    getCursor(): number;
	    resultAtCursor(match?: string | {
	        (result): boolean;
	    }): Coveo.MagicBox.Result[];
	    private handleBuildingQuery(args);
	    private triggerNewQuery(searchAsYouType);
	    private updateQueryState();
	    private handleQueryStateChanged(args);
	    private searchAsYouType();
	}

}
declare module Coveo {
	
	
	export interface ISearchButtonOptions {
	}
	/**
	 * A component that allows user to trigger a query by clicking on it.<br/>
	 * This component will instantiate on an element and add a search icon.<br/>
	 * It will also sends an analytics event to the coveo platform when clicked.
	 */
	export class SearchButton extends Component {
	    element: HTMLElement;
	    options: ISearchButtonOptions;
	    static ID: string;
	    static options: ISearchButtonOptions;
	    /**
	     * Create a new SearchButton on the given element with the given options
	     * Bind a click event on the element
	     * Adds a search icon on the element
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: ISearchButtonOptions, bindings?: IComponentBindings);
	    /**
	     * Trigger the click handler
	     */
	    click(): void;
	    private handleClick();
	}

}
declare module Coveo {
	/// <reference path="Omnibox.d.ts" />
	
	export class FieldAddon {
	    omnibox: Omnibox;
	    static INDEX: number;
	    cache: {
	        [hash: string]: Promise<string[]>;
	    };
	    constructor(omnibox: Omnibox);
	    getSuggestion(): Promise<IOmniboxSuggestion[]>;
	    private getHash();
	    private hashToString(hash);
	    private hashValueToSuggestion(hash, promise);
	    private fields;
	    private getFields();
	    private fieldNames(current);
	    private fieldValues(field, current);
	    private simpleFieldNames(current);
	}

}
declare module Coveo {
	/// <reference path="Omnibox.d.ts" />
	
	export class QueryExtensionAddon {
	    omnibox: Omnibox;
	    static INDEX: number;
	    cache: {
	        [hash: string]: Promise<string[]>;
	    };
	    constructor(omnibox: Omnibox);
	    getSuggestion(): Promise<IOmniboxSuggestion[]>;
	    private getHash(magicBox);
	    private hashToString(hash);
	    private hashValueToSuggestion(hash, promise);
	    private extensions;
	    private getExtensions();
	    private names(current);
	    private attributeNames(name, current, used);
	    hash(): void;
	}

}
declare module Coveo {
	/// <reference path="Omnibox.d.ts" />
	
	export class RevealQuerySuggestAddon {
	    omnibox: Omnibox;
	    static INDEX: number;
	    static suggestiontHtmlTemplate: (...data: any[]) => string;
	    private static suggestiontHtml(suggestion);
	    private static isPartialMatch(suggestion);
	    private cache;
	    constructor(omnibox: Omnibox);
	    getSuggestion(): Promise<IOmniboxSuggestion[]>;
	    private getRevealQuerySuggest(text);
	}

}
declare module Coveo {
	/// <reference path="Omnibox.d.ts" />
	
	export class OldOmniboxAddon {
	    omnibox: Omnibox;
	    constructor(omnibox: Omnibox);
	    private lastQuery;
	    private lastSuggestions;
	    getSuggestion(): Promise<IOmniboxSuggestion[]>[];
	    private getCurrentQueryExpression();
	    private getRegexToSearch(strValue?);
	    private getQueryExpressionBreakDown();
	    private replace(searchValue, newValue);
	    private clearCurrentExpression();
	    private insertAt(at, toInsert);
	    private replaceCurrentExpression(newValue);
	    private buildPopulateOmniboxEventArgs();
	    private rowsToSuggestions(rows);
	}

}
declare module Coveo {
	/// <reference path="FieldAddon.d.ts" />
	/// <reference path="QueryExtensionAddon.d.ts" />
	/// <reference path="RevealQuerySuggestAddon.d.ts" />
	/// <reference path="OldOmniboxAddon.d.ts" />
	
	
	
	export interface IPopulateOmniboxSuggestionsEventArgs {
	    omnibox: Omnibox;
	    suggestions: Array<Coveo.MagicBox.Suggestion[] | Promise<Coveo.MagicBox.Suggestion[]>>;
	}
	export interface IOmniboxSuggestion extends Coveo.MagicBox.Suggestion {
	}
	export interface IOmniboxOptions extends IQueryboxOptions {
	    inline?: boolean;
	    enableFieldAddon?: boolean;
	    enableSimpleFieldAddon?: boolean;
	    listOfFields?: string[];
	    fieldAlias?: {
	        [alias: string]: string;
	    };
	    enableRevealQuerySuggestAddon?: boolean;
	    enableQueryExtensionAddon?: boolean;
	    omniboxTimeout?: number;
	    placeholder?: string;
	    grammar?: (grammar: {
	        start: string;
	        expressions: {
	            [id: string]: Coveo.MagicBox.ExpressionDef;
	        };
	    }) => {
	        start: string;
	        expressions: {
	            [id: string]: Coveo.MagicBox.ExpressionDef;
	        };
	    };
	}
	/**
	 * This component is very similar to the simpler {@link Querybox} Component and support all the same options/behavior except for the search-as-you-type feature.<br/>
	 * In addition, it takes care of adding a type-ahead capability. The type-ahead and the suggestions it displays are customizable and extensible by any custom component.<br/>
	 * The type-ahead is configurable by activating addon which are provided OOTB (facets, analytics suggestions, reveal suggestions, and advanced coveo syntax suggestions).<br/>
	 * It is also possible for external code to provide suggestions.
	 */
	export class Omnibox extends Component {
	    element: HTMLElement;
	    options: IOmniboxOptions;
	    static ID: string;
	    /**
	     * The options for the omnibox
	     * @componentOptions
	     */
	    static options: IOmniboxOptions;
	    magicBox: Coveo.MagicBox.Instance;
	    private partialQueries;
	    private lastSuggestions;
	    private lastQuery;
	    private modifyEventTo;
	    private movedOnce;
	    private searchAsYouTypeTimeout;
	    /**
	     * Create a new omnibox with, enable required addons, and bind events on letious query events
	     */
	    constructor(element: HTMLElement, options?: IOmniboxOptions, bindings?: IComponentBindings);
	    /**
	     * Trigger a query. The current input content will be added to the query<br/>
	     * If the content of the input has not changed since the last submit, no new query will be triggered.
	     */
	    submit(): void;
	    /**
	     * Get the current content of the input
	     * @returns {string}
	     */
	    getText(): string;
	    /**
	     * Set the content of the input
	     * @param text The string to set in the input
	     */
	    setText(text: string): void;
	    /**
	     * Clear the content of the input
	     */
	    clear(): void;
	    /**
	     * Get the HTMLInputElement of the omnibox
	     */
	    getInput(): HTMLInputElement;
	    getResult(): Coveo.MagicBox.Result;
	    getDisplayedResult(): Coveo.MagicBox.Result;
	    getCursor(): number;
	    resultAtCursor(match?: string | {
	        (result: Coveo.MagicBox.Result): boolean;
	    }): Coveo.MagicBox.Result[];
	    private setupMagicBox();
	    private handleRevealAutoSuggestionWithKeyboard(index, suggestions);
	    private handleRevealAutoSuggestionsWithMouse(index, suggestions);
	    private modifyCustomDataOnPending(index, suggestions);
	    private buildCustomDataForPartialQueries(index, suggestions);
	    private cleanCustomData(toClean, rejectLength?);
	    private handleSuggestions();
	    private handleBeforeRedirect();
	    private handleBuildingQuery(data);
	    private triggerNewQuery(searchAsYouType, analyticsEvent);
	    private getQuery(searchAsYouType);
	    updateQueryState(): void;
	    private handleQueryStateChanged(args);
	    private handleQuerySuccess();
	    private handleDuringQuery(args);
	    private searchAsYouType();
	    private isRevealAutoSuggestion();
	}

}
declare module Coveo {
	
	
	
	
	
	
	export interface ISearchboxOptions extends IOmniboxOptions {
	    addSearchButton?: boolean;
	    enableOmnibox?: boolean;
	}
	/**
	 * This component is mostly used for simplicity purpose because it creates 2 component that are very frequently used together.<br/>
	 * This component attaches itself to a div and takes care of instantiating a {@link Querybox} Component or a {@link Omnibox} Component, depending on the options.<br/>
	 * Add a {@link SearchButton} Component if desired, and appends them to the same div.
	 */
	export class Searchbox extends Component {
	    element: HTMLElement;
	    options: ISearchboxOptions;
	    static ID: string;
	    static parent: typeof Omnibox;
	    /**
	     * Possible options for the {@link Searchbox}
	     * @componentOptions
	     */
	    static options: ISearchboxOptions;
	    /**
	     * Instance of the {@link SearchButton}
	     */
	    searchButton: SearchButton;
	    /**
	     * Instance of compomnent that allows user to input query.<br/>
	     * Can be a {@link Querybox} or {@link Omnibox}
	     */
	    searchbox: Querybox | Omnibox;
	    /**
	     * Create a new Searchbox<br/>
	     * Create a new Coveo.Magicbox instance and wrap magic box method (on blur, on submit etc)<br/>
	     * Bind event on buildingQuery and on redirection (for standalone box)
	     * @param element The HTMLElement on which the element will be instantiated. This cannot be an HTMLInputElement for technical reason
	     * @param options The options for the component. Will be merged with the options from the component set directly on the HTMLElement
	     * @param bindings The bindings that the component requires to function normally. If not set, will automatically resolve them (With slower execution time)
	     */
	    constructor(element: HTMLElement, options?: ISearchboxOptions, bindings?: IComponentBindings);
	}

}
declare module Coveo {
	
	
	
	export interface IBreadcrumbOptions {
	}
	/**
	 * This component displays a summary of the filters currently active in the query.
	 *
	 * For example, when the user selects a facet value, the value is displayed in the breadcrumbs.
	 *
	 * The active filters are obtained by the component by firing an event in the breadcrumb component.
	 *
	 * All other components having an active state can answer to this event by providing custom bits of HTML that will be displayed inside the breadcrumb.
	 *
	 * Thus, the breadcrumb can easily be extended by custom code to display information about custom state and filters.
	 *
	 * See {@link BreadcrumbEvents} for the list of events and parameters sent when a breadcrumb is populated.
	 */
	export class Breadcrumb extends Component {
	    element: HTMLElement;
	    options: IBreadcrumbOptions;
	    static ID: string;
	    static options: IBreadcrumbOptions;
	    private lastBreadcrumbs;
	    /**
	     * Create a new breadcrumb element, bind event on deferredQuerySuccess to draw the breadcrumb
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: IBreadcrumbOptions, bindings?: IComponentBindings);
	    /**
	     * Trigger the event to populate breadcrumb, which component such as {@link Facet} can populate.<br/>
	     * Will trigger an event with {@link IPopulateBreadcrumbEventArgs} object (an array) which other component or code can populate.
	     * @returns {IBreadcrumbItem[]}
	     */
	    getBreadcrumbs(): IBreadcrumbItem[];
	    /**
	     * Trigger the event to clear the current breadcrumbs, which component such as {@link Facet} can populate.<br/>
	     * Trigger a new query, and log a search event
	     */
	    clearBreadcrumbs(): void;
	    /**
	     * Draw the given breadcrumbs items
	     * @param breadcrumbs
	     */
	    drawBreadcrumb(breadcrumbs: IBreadcrumbItem[]): void;
	    private redrawBreadcrumb();
	    private handleDeferredQuerySuccess();
	    private handleAfterInitialization();
	}

}
declare module Coveo {
	
	
	
	export interface IPagerOptions {
	    numberOfPages?: number;
	    enableNavigationButton?: boolean;
	    maxNumberOfPages?: number;
	}
	/**
	 * This component attaches itself to a div and allows users to navigate through the different result pages.<br/>
	 * It takes care of triggering a query with the correct range whenever a user selects a page or uses the navigation buttons (Previous, Next).
	 */
	export class Pager extends Component {
	    element: HTMLElement;
	    options: IPagerOptions;
	    static ID: string;
	    /**
	     * The options for the Pager
	     * @componentOptions
	     */
	    static options: IPagerOptions;
	    /**
	     * The current page (1 based index)
	     */
	    currentPage: number;
	    private listenToQueryStateChange;
	    private ignoreNextQuerySuccess;
	    private needToReset;
	    private list;
	    /**
	     * Create a new Pager. Bind multiple query events (new query, building query, query success).<br/>
	     * Render itself on every query success.
	     * @param element HTMLElement on which to instantiate the page (Normally : a div)
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: IPagerOptions, bindings?: IComponentBindings);
	    /**
	     * Set the current page, and execute a query.<br/>
	     * Log the required analytics event (pagerNumber by default)
	     * @param pageNumber
	     * @param analyticCause
	     */
	    setPage(pageNumber: number, analyticCause?: IAnalyticsActionCause): void;
	    /**
	     * Go to the previous page, and execute a query.<br/>
	     * Log the required analytics event (pagerPrevious)
	     */
	    previousPage(): void;
	    /**
	     * Go to the next page, and execute a query.<br/>
	     * Log the required analytics event (pagerNext)
	     */
	    nextPage(): void;
	    private handleNewQuery(data);
	    private updateQueryStateModel(attrValue);
	    private handleQueryError();
	    private handleQuerySuccess(data);
	    private handleNoResults(data);
	    private reset();
	    private handleBuildingQuery(data);
	    private computePagerBoundary(firstResult, totalCount);
	    private renderNavigationButton(pagerBoundary, list);
	    private handleQueryStateModelChanged(data);
	    private handleClickPage(pageNumber);
	    private handleClickPrevious();
	    private handleClickNext();
	    private fromFirstResultsToPageNumber(firstResult);
	    private getFirstResultNumber(pageNumber?);
	    private getQueryEventArgs();
	}

}
declare module Coveo {
	
	
	
	export interface IResultsPerPageOptions {
	    choicesDisplayed?: number[];
	}
	/**
	 * This component attaches itself to a div and allows users to choose the number of results displayed per page.<br/>
	 */
	export class ResultsPerPage extends Component {
	    element: HTMLElement;
	    options: IResultsPerPageOptions;
	    static ID: string;
	    /**
	     * The options for the ResultsPerPage
	     * @componentOptions
	     */
	    static options: IResultsPerPageOptions;
	    private currentResultsPerPage;
	    private span;
	    private list;
	    /**
	     * Create a new ResultsPerPage<br/>
	     * Render itself on every query success.
	     * @param element HTMLElement on which to instantiate the page (Normally : a div)
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: IResultsPerPageOptions, bindings?: IComponentBindings);
	    /**
	     * Set the current number of results per page, and execute a query.<br/>
	     * Log the required analytics event (pagerResize by default)
	     * @param resultsPerPage
	     * @param analyticCause
	     */
	    setResultsPerPage(resultsPerPage: number, analyticCause?: IAnalyticsActionCause): void;
	    private initComponent(element);
	    private render();
	    private handleQueryError();
	    private handleNoResults();
	    private handleQuerySuccess(data);
	    private handleClickPage(resultsPerPage);
	    private reset();
	}

}
declare module Coveo {
	
	
	
	/**
	 * This component, located in a result template, is used to render the document's excerpt,
	 * as well as highlighting searched **keywords** using the appropriate template helpers.
	 */
	export class Excerpt extends Component {
	    element: HTMLElement;
	    options: any;
	    bindings: IComponentBindings;
	    result: IQueryResult;
	    static ID: string;
	    /**
	     * Create a new Excerpt component
	     * @param element
	     * @param options
	     * @param bindings
	     * @param result
	     */
	    constructor(element: HTMLElement, options?: any, bindings?: IComponentBindings, result?: IQueryResult);
	}

}
declare module Coveo {
	
	export interface IResultLinkOptions {
	    onClick?: (e: Event, result: IQueryResult) => any;
	    field?: string;
	    openInOutlook?: boolean;
	    openQuickview?: boolean;
	    alwaysOpenInNewWindow?: boolean;
	    hrefTemplate?: string;
	}

}
declare module Coveo {
	
	
	
	
	
	/**
	 * This component is intended to be placed inside a result template, which itself is used inside a {@link ResultList} component.
	 * The ResultLink component automatically transforms a search result title into a clickable link that points to the original document.
	 */
	export class ResultLink extends Component {
	    element: HTMLElement;
	    options: IResultLinkOptions;
	    bindings: IResultsComponentBindings;
	    result: IQueryResult;
	    os: OS_NAME;
	    static ID: string;
	    /**
	     * The options for the ResultLink
	     * @componentOptions
	     */
	    static options: IResultLinkOptions;
	    static fields: string[];
	    constructor(element: HTMLElement, options?: IResultLinkOptions, bindings?: IResultsComponentBindings, result?: IQueryResult, os?: OS_NAME);
	    protected bindEventToOpen(): boolean;
	    private bindOnClickIfNotUndefined();
	    private bindOpenQuickviewIfNotUndefined();
	    private openLinkThatIsNotAnAnchor();
	    /**
	     * Opens the result
	     */
	    openLink(): void;
	    /**
	     * Opens the result in a new window
	     */
	    openLinkInNewWindow(): void;
	    /**
	     * Opens the result in outlook if the result has an outlook field.
	     */
	    openLinkInOutlook(): void;
	    private setHrefIfNotAlready();
	    private logOpenDocument;
	    private getResultUri();
	    private elementIsAnAnchor();
	    private setField();
	    private hasOutlookField();
	    private isUriThatMustBeOpenedInQuickview();
	    private quickviewShouldBeOpened();
	    private parseHrefTemplate();
	    private readFromObject(object, key);
	}

}
declare module Coveo {
	
	
	
	
	export interface IThumbnailOptions {
	    noThumbnailClass?: string;
	    clickable?: boolean;
	}
	/**
	 * This component automatically fetches the thumbnail of the result object
	 * and formats an HTML image tag (<code>img</code>) with it.
	 */
	export class Thumbnail extends Component {
	    element: HTMLElement;
	    options: IThumbnailOptions;
	    bindings: IResultsComponentBindings;
	    result: IQueryResult;
	    static ID: string;
	    /**
	     * Options for the Thumbnail
	     * @componentOptions
	     */
	    static options: IThumbnailOptions;
	    static parent: typeof ResultLink;
	    static fields: string[];
	    /**
	     * Create a new Thumbnail component
	     * @param element
	     * @param options
	     * @param bindings
	     * @param result
	     */
	    constructor(element: HTMLElement, options?: IThumbnailOptions, bindings?: IResultsComponentBindings, result?: IQueryResult);
	    private buildThumbnailImage();
	    private buildImageWithDirectSrcAttribute(endpoint);
	    private buildImageWithBase64SrcAttribute(endpoint);
	    private setEmptyThumbnailClass();
	}

}
declare module Coveo {
	
	
	
	export interface IPrintableUriOptions {
	}
	/**
	 * This component is meant to be used inside a result template to display the URI or path to access a result.
	 */
	export class PrintableUri extends Component {
	    element: HTMLElement;
	    options: IPrintableUriOptions;
	    result: IQueryResult;
	    static ID: string;
	    static options: IPrintableUriOptions;
	    static fields: string[];
	    private uri;
	    /**
	     * Create a new PrintableUri
	     * @param element
	     * @param options
	     * @param bindings
	     * @param result
	     */
	    constructor(element: HTMLElement, options: IPrintableUriOptions, bindings?: IComponentBindings, result?: IQueryResult);
	    renderParentsXml(element: HTMLElement, parentsXml: string): void;
	    renderUri(element: HTMLElement, result?: IQueryResult): void;
	    buildSeperator(): HTMLSpanElement;
	    buildEllipsis(): HTMLSpanElement;
	    buildHtmlToken(name: string, uri: string): HTMLAnchorElement;
	    private bindLogOpenDocument(link);
	}

}
declare module Coveo {
	
	
	export interface IDidYouMeanOptions {
	    enableAutoCorrection?: boolean;
	}
	/**
	 * This component is responsible for displaying query corrections. If this component is in the page
	 * and the query returns no results, but finds a possible query correction, the component either
	 * suggests the correction or automatically triggers a new query with the suggested term.
	 */
	export class DidYouMean extends Component {
	    element: HTMLElement;
	    options: IDidYouMeanOptions;
	    bindings: IComponentBindings;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IDidYouMeanOptions;
	    correctedTerm: string;
	    private hideNext;
	    /**
	     * Create a new DidYouMean component
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: IDidYouMeanOptions, bindings?: IComponentBindings);
	    /**
	     * Execute a query with the corrected term <br/>
	     * Will throw an exception if the corrected term has not been initialized
	     */
	    doQueryWithCorrectedTerm(): void;
	    private handleNewQuery();
	    private handlePrepareQueryBuilder(data);
	    private handleNoResults(data);
	    private handleProcessNewQueryResults(data);
	    private buildCorrectedSentence(correction);
	}

}
declare module Coveo {
	
	
	export interface IErrorReportOptions {
	    showDetailedError: boolean;
	}
	/**
	 * This component takes care of handling fatal error when doing a query on the index / search API.<br/>
	 * For example, it will display a message when the service responds with something like a 401 or 503.<br/>
	 * It will also render a small text area with the JSON content of the error response, for debugging purpose.
	 */
	export class ErrorReport extends Component {
	    element: HTMLElement;
	    options: IErrorReportOptions;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IErrorReportOptions;
	    private message;
	    private closePopup;
	    /**
	     * Create a new ErrorReport component
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: IErrorReportOptions, bindings?: IComponentBindings);
	    /**
	     * Do the "back" action in the browser
	     */
	    back(): void;
	    /**
	     * Reset the current state of the query to 'empty', and trigger a new query
	     */
	    reset(): void;
	    /**
	     * Retry the same query, in case of a temporary service error
	     */
	    retry(): void;
	    private setErrorTitle();
	    private buildPrevious();
	    private buildReset();
	    private buildRetry();
	    private handleNewQuery();
	    private handleQueryError(data);
	    private buildErrorInfo(data);
	}

}
declare module Coveo {
	export interface IMenuItem {
	    text: string;
	    className: string;
	    tooltip?: string;
	    index?: number;
	    onOpen: () => void;
	    onClose?: () => void;
	}

}
declare module Coveo {
	
	
	
	export interface ISettingsPopulateMenuArgs {
	    settings: Settings;
	    menuData: IMenuItem[];
	}
	export interface ISettingsOptions {
	    menuDelay: number;
	}
	/**
	 * The Settings component is comprised of a settings button (usually located
	 * on the right of the search box) which allows for some contextual actions.<br/>
	 * This component references other components to show in its menu, for example
	 * the {@link ShareQuery} component.
	 */
	export class Settings extends Component {
	    element: HTMLElement;
	    options: ISettingsOptions;
	    static ID: string;
	    /**
	     * The options for Settings
	     * @componentOptions
	     */
	    static options: ISettingsOptions;
	    private menu;
	    private closeTimeout;
	    private isOpened;
	    /**
	     * Create a new Settings component
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options: ISettingsOptions, bindings?: IComponentBindings);
	    /**
	     * Open the settings popup
	     */
	    open(): void;
	    /**
	     * Close the settings popup
	     */
	    close(): void;
	    private init();
	    private buildMenu();
	    private mouseleave();
	    private mouseenter();
	    private getPopupPositioning();
	}

}
declare module Coveo {
	
	
	export interface IExportToExcelOptions {
	    numberOfResults?: number;
	}
	/**
	 * This component allows users to export the current search results in a Microsoft Excel (.xlsx) format.
	 * It populates the {@link Settings} component's menu.
	 */
	export class ExportToExcel extends Component {
	    element: HTMLElement;
	    options: IExportToExcelOptions;
	    bindings: IComponentBindings;
	    _window: Window;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IExportToExcelOptions;
	    /**
	     * Create a new ExportToExcel component
	     * @param element
	     * @param options
	     * @param bindings
	     * @param _window The global Window object (used to download the Excel link)
	     */
	    constructor(element: HTMLElement, options: IExportToExcelOptions, bindings?: IComponentBindings, _window?: Window);
	    /**
	     * Download the Excel representation of the current query
	     */
	    download(): void;
	    static create(element: HTMLElement, options?: IExportToExcelOptions, root?: HTMLElement): ExportToExcel;
	}

}
declare module Coveo {
	
	
	export class SortCriteria {
	    sort: string;
	    direction: string;
	    private static validSorts;
	    private static sortsNeedingDirection;
	    private static validDirections;
	    /**
	     * Create a new SortCriteria
	     * @param sort The sort criteria (e.g. relevancy, date)
	     * @param direction The direction by which to sort (e.g. ascending, descending)
	     */
	    constructor(sort: string, direction?: string);
	    /**
	     * Return a new SortCriteria from a string
	     * @param criteria The string from which to create the SortCriteria
	     */
	    static parse(criteria: string): SortCriteria;
	    /**
	     * Put the sort criteria in the passed queryBuilder
	     * @param queryBuilder The queryBuilder in which to put the sort criteria
	     */
	    putInQueryBuilder(queryBuilder: QueryBuilder): void;
	    /**
	     * Gets the value of the sort criteria from a single {@link IQueryResult}<br/>
	     * For example, if the sort criteria is 'relevancy', it will return the value of the 'relevancy' field from result
	     * @param result The {@link IQueryResult} from which to get the value.
	     */
	    getValueFromResult(result: IQueryResult): any;
	    /**
	     * Returns a string representation of the sort criteria (e.g. 'date ascending')
	     */
	    toString(): string;
	    /**
	     * Checks if the SortCriteria is equal to another
	     * @param criteria The SortCriteria to compare with
	     */
	    equals(criteria: SortCriteria): boolean;
	    private static sortIsField(criteria);
	    private static sortNeedsDirection(sort);
	}

}
declare module Coveo {
	
	
	
	
	export interface IFoldingOptions {
	    field?: string;
	    childField?: string;
	    parentField?: string;
	    range?: number;
	    rearrange?: SortCriteria;
	    enableExpand?: boolean;
	    expandExpression?: string;
	    maximumExpandedResults?: number;
	    /**
	     * Manage folding for each results individually
	     */
	    getResult?: (result: IQueryResult) => IQueryResult;
	    /**
	     * Manage folding of all more results
	     */
	    getMoreResults?: (results: IQueryResult[]) => IQueryResult[];
	}
	/**
	 * This component is used to display search results that share a common field hierarchically.
	 * It is typically used to display email conversations and message board threads.
	 * The different messages in a given conversation typically have a unique conversation ID.
	 * Given that this ID is indexed in a field, you can use it to fold search results
	 */
	export class Folding extends Component {
	    element: HTMLElement;
	    options: IFoldingOptions;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IFoldingOptions;
	    /**
	     * Create a new Folding component
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options: IFoldingOptions, bindings?: IComponentBindings);
	    static foldWithParent(queryResults: IQueryResult[]): IQueryResult[];
	    static defaultGetResult(result: IQueryResult): IQueryResult;
	    static defaultGetMoreResults(results: IQueryResult[]): IQueryResult[];
	    private static resultNodeToQueryResult(resultNode);
	    private static findUniqueId(resultNodes, uniqueId);
	    private handleBuildingQuery(data);
	    private handlepreprocessResults(data);
	    private addLoadMoreHandler(results, originalQuery);
	    private moreResults(result, originalQuery);
	    private handlePreprocessMoreResults(queryResults);
	}

}
declare module Coveo {
	
	
	export interface IHiddenQueryOptions {
	    maximumDescriptionLength: number;
	    title: string;
	}
	/**
	 * This component job is to handle an 'hidden' query parameter.<br/>
	 * Concretely, this means that a search interface loaded with #hq=foo&hd=bar will add 'foo' as an expression to the query ('hq'=> hidden query) and render 'bar' in the {@link Breadcrumb}<br/>
	 */
	export class HiddenQuery extends Component {
	    element: HTMLElement;
	    options: IHiddenQueryOptions;
	    static ID: string;
	    /**
	     * Possible options for the HiddenQuery component
	     * @componentOptions
	     */
	    static options: IHiddenQueryOptions;
	    /**
	     * Create a new HiddenQuery component, which bind multiple events (building query as well as {@link Breadcrumb} events
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: IHiddenQueryOptions, bindings?: IComponentBindings);
	    /**
	     * Clear any hd or hq set in the {@link QueryStateModel}, log an analytics event and trigger a new query.
	     */
	    clear(): void;
	    private setStateEmpty();
	    private handleBuildingQuery(data);
	    private handlePopulateBreadcrumb(args);
	    private getDescription();
	}

}
declare module Coveo {
	/**
	 * Represent a single cell of data in the {@link Matrix} component
	 */
	export class Cell {
	    private value;
	    private element;
	    private previewActive;
	    constructor(value?: any, el?: HTMLElement);
	    /**
	     * Return the value of the cell
	     * @returns {any}
	     */
	    getValue(): any;
	    /**
	     * Return the HTMLElement for the cell
	     * @returns {HTMLElement}
	     */
	    getHTML(): HTMLElement;
	    /**
	     * Set the value if the cell
	     * @param value
	     */
	    setValue(value: any): void;
	    /**
	     * Set the HTMLElement for the cell
	     * @param html
	     */
	    setHTML(html: HTMLElement): void;
	    /**
	     * Show the preview of the cell
	     * @param minWidth css minWidth property : eg 100px
	     * @param maxWidth css maxWidth property : eg 100px
	     */
	    addPreview(minWidth: string, maxWidth: string): void;
	    /**
	     * Remove the preview of the cell
	     */
	    removePreview(): void;
	    /**
	     * Update the preview with a new template
	     * @param template
	     */
	    updatePreview(template: string): void;
	}

}
declare module Coveo {
	
	
	export class DefaultMatrixResultPreviewTemplate extends Template {
	    private computedField;
	    private format;
	    constructor(computedField: string, format: string);
	    instantiateToString(object?: IQueryResult, checkCondition?: boolean): string;
	    instantiateToElement(object?: IQueryResult, checkCondition?: boolean): HTMLElement;
	}

}
declare module Coveo {
	
	
	
	
	export interface IMatrixOptions {
	    title?: string;
	    rowField: string;
	    sortCriteria?: string;
	    maximumNumberOfRows?: number;
	    enableRowTotals?: boolean;
	    columnField: string;
	    columnFieldValues?: string[];
	    columnLabels?: string[];
	    columnHeader?: string;
	    maximumNumberOfValuesInGroupBy?: number;
	    enableColumnTotals?: boolean;
	    computedField: string;
	    computedFieldOperation?: string;
	    computedFieldFormat?: string;
	    cellFontSize?: string;
	    enableHoverPreview?: boolean;
	    previewSortCriteria?: string;
	    previewSortField?: string;
	    previewMaxWidth?: string;
	    previewMinWidth?: string;
	    previewDelay?: number;
	    previewTemplate?: Template;
	}
	/**
	 * This component uses the values of two fields (row and column) to display the results of the specified computed field in a table.<br/>
	 * The values to use for the columns are specified by the user while those for the rows are obtained by a groupBy operation performed at the same time as the main query (see {@link IGroupByRequest}).<br/>
	 * Like a {@link Facet}, selecting a cell allows the user to drill down inside results by restricting the row field and the column field to match the values of the selected cell.
	 */
	export class Matrix extends Component {
	    element: HTMLElement;
	    options: IMatrixOptions;
	    static ID: string;
	    /**
	     * The possible options for the component
	     * @componentOptions
	     */
	    static options: IMatrixOptions;
	    /**
	     * Holds the data for the matrix
	     */
	    data: Cell[][];
	    groupByIndex: any[];
	    rowId: string;
	    columnId: string;
	    /**
	     * The currently selected row value, or undefined if nothing is selected
	     */
	    selectedRowValue: string;
	    /**
	     * The currently selected column value, or undefined if nothing is selected
	     */
	    selectedColumnValue: any;
	    private numberOfRows;
	    private numberOfColumns;
	    private previewTimeout;
	    /**
	     * Create a new matrix, check if the options are valid and makes sense. Bind query events.
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: IMatrixOptions, bindings?: IComponentBindings);
	    /**
	     * Select a cell by it's row and column number. Does not execute a query.
	     * @param rowNumber
	     * @param columnNumber
	     */
	    selectCell(rowNumber: number, columnNumber: number): void;
	    /**
	     * Return the currently selected column value
	     */
	    getSelectedColumnValue(): string;
	    /**
	     * Return the currently selected row value
	     */
	    getSelectedRowValue(): string;
	    /**
	     * Get the HTMLElement associated to the desired cell
	     * @param rowNumber
	     * @param columnNumber
	     * @returns {HTMLElement}
	     */
	    getCellElement(rowNumber: number, columnNumber: number): HTMLElement;
	    /**
	     * Get the string associated to the desired cell
	     * @param rowNumber
	     * @param columnNumber
	     * @returns {string}
	     */
	    getCellValue(rowNumber: number, columnNumber: number): string;
	    drawMatrix(): void;
	    private bindEvents();
	    private initQueryState();
	    private buildMatrix();
	    private buildTitle();
	    private buildBody();
	    private handleBuildingQuery(args);
	    private handleDoneBuildingQuery(args);
	    private handleDeferredQuerySuccess(args);
	    private addMainGroubByRequest(queryBuilder);
	    private addColumnsGroupByRequests(queryBuilder);
	    private buildExpression(queryBuilder);
	    private getComputedFields();
	    private getCellResult(results, rowNumber, columnNumber);
	    private addTotals();
	    private addRowTotals();
	    private addColumnTotals();
	    private computeRowTotal(rowNumber);
	    private computeColumnTotal(columnNumber);
	    private formatCells();
	    private addHeaderRow();
	    private addRow();
	    private addColumn();
	    private addCellToRow(rowNumber, columnNumber);
	    private setValue(value, rowNumber, columnNumber);
	    private handleClick(rowNumber, columnNumber);
	    private getRowValue(rowNumber);
	    private getColumnValue(columnNumber);
	    private isAColumnSelected();
	    private isColumnSelected(columnValue);
	    private isARowSelected();
	    private isRowSelected(rowValue);
	    private isCellSelected(rowValue, columnValue);
	    private areFacetsPresent();
	    private isRowFacetPresent();
	    private isColumnFacetPresent();
	    private reset();
	    private parseResults(results);
	    private drawRow(row, rowNumber);
	    private handleHoverIn(rowNumber, columnNumber);
	    private handleHoverOut(rowNumber, columnNumber);
	    private displayResultsPreview(rowNumber, columnNumber);
	    private instantiateTemplate(result);
	    private createPreviewQuery(rowNumber, columnNumber);
	    private isHoverWorkingOnRow(rowNumber);
	    private isHoverWorkingOnColumn(columnNumber);
	    private isDataAvailable(row, column);
	}

}
declare module Coveo {
	
	
	
	export interface IYouTubeThumbnailOptions {
	    width: string;
	    height: string;
	    embed: boolean;
	}
	export class YouTubeThumbnail extends Component {
	    element: HTMLElement;
	    options: IYouTubeThumbnailOptions;
	    bindings: IResultsComponentBindings;
	    result: IQueryResult;
	    static ID: string;
	    static options: IYouTubeThumbnailOptions;
	    static fields: string[];
	    private modalbox;
	    constructor(element: HTMLElement, options?: IYouTubeThumbnailOptions, bindings?: IResultsComponentBindings, result?: IQueryResult);
	    private handleOnClick();
	    private extractVideoId();
	}

}
declare module Coveo {
	
	
	export class DefaultResultAttachmentTemplate extends Template {
	    constructor();
	    instantiateToString(queryResult?: IQueryResult): string;
	}

}
declare module Coveo {
	
	
	
	
	export interface IResultAttachmentsOptions {
	    resultTemplate?: Template;
	    subResultTemplate?: Template;
	    maximumAttachmentLevel?: number;
	}
	/**
	 * This component is used to render attachments in a result set, for example when displaying emails.<br/>
	 * It is intended to be used inside a result template when there is an active {@link Folding} component
	 * inside the page.
	 */
	export class ResultAttachments extends Component {
	    element: HTMLElement;
	    options: IResultAttachmentsOptions;
	    bindings: IComponentBindings;
	    attachmentLevel: number;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IResultAttachmentsOptions;
	    private attachments;
	    /**
	     * Build a new ResultAttachments component
	     * @param element
	     * @param options
	     * @param bindings
	     * @param result
	     * @param attachmentLevel
	     */
	    constructor(element: HTMLElement, options?: IResultAttachmentsOptions, bindings?: IComponentBindings, result?: IQueryResult, attachmentLevel?: number);
	    private renderAttachments();
	    private attachmentHasSubAttachment(attachment);
	    private autoCreateComponentsInsideResult(element, result);
	}

}
declare module Coveo {
	
	
	export class DefaultFoldingTemplate extends Template {
	    constructor();
	    instantiateToString(queryResult?: IQueryResult): string;
	    getType(): string;
	}

}
declare module Coveo {
	
	
	
	
	export interface IResultFoldingOptions {
	    resultTemplate?: Template;
	    normalCaption?: string;
	    expandedCaption?: string;
	    moreCaption?: string;
	    lessCaption?: string;
	    oneResultCaption?: string;
	}
	/**
	 * This component is used to render folded result sets. It is intended to be used inside a
	 * <a href='https://developers.coveo.com/display/public/JsSearchV1/Result+Templates'>Result Template</a>
	 * when there is an active {@link Folding} component on the page. This component takes care of rendering
	 * the parent result and its child results in a coherent manner.
	 */
	export class ResultFolding extends Component {
	    element: HTMLElement;
	    options: IResultFoldingOptions;
	    result: IQueryResult;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IResultFoldingOptions;
	    private normalCaption;
	    private expandedCaption;
	    private oneResultCaption;
	    private results;
	    private showMore;
	    private showLess;
	    private waitAnimation;
	    private moreResultsPromise;
	    private showingMoreResults;
	    childResults: IQueryResult[];
	    constructor(element: HTMLElement, options?: IResultFoldingOptions, bindings?: IComponentBindings, result?: IQueryResult);
	    showMoreResults(): void;
	    showLessResults(): void;
	    private buildElements();
	    private buildHeader();
	    private buildResults();
	    private buildFooter();
	    private updateElementVisibility(subResultsLength?);
	    private scrollToResultElement();
	    private displayThoseResults(results);
	    private renderChildResult(childResult);
	    private autoCreateComponentsInsideResult(element, result);
	    private cancelAnyPendingShowMore();
	}

}
declare module Coveo {
	
	
	
	export interface IFieldValueOptions {
	    field?: string;
	    facet?: string;
	    htmlValue?: boolean;
	    helper?: string;
	    helperOptions?: {
	        [key: string]: any;
	    };
	    splitValues?: boolean;
	    separator?: string;
	    displaySeparator?: string;
	}
	export interface IAnalyticsFieldValueMeta {
	    facetId: string;
	    facetValue?: string;
	    facetTitle?: string;
	}
	/**
	 * This component can be used as part of a result template to display the value of a field
	 * associated with the current search result.<br/>
	 * This component is usually located inside a {@link FieldTable}.<br/>
	 * A common use of this component is to display a specific field value, when that field also
	 * happens to be a facet. When the field value is clicked on, the corresponding facet is activated.
	 */
	export class FieldValue extends Component {
	    element: HTMLElement;
	    options: IFieldValueOptions;
	    result: IQueryResult;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IFieldValueOptions;
	    static simpleOptions: any;
	    static helperOptions: any;
	    /**
	     * Build a new FieldValue
	     * @param element
	     * @param options
	     * @param bindings
	     * @param result
	     */
	    constructor(element: HTMLElement, options?: IFieldValueOptions, bindings?: IComponentBindings, result?: IQueryResult, fieldValueClassId?: string);
	    /**
	     * Get the current field value from the current result.<br/>
	     * Returns <code>null</code> if value is an <code>Object</code>.
	     */
	    getValue(): any;
	    /**
	     * Render the passed value string with all of the component's options.<br/>
	     * Returns an <code>HTMLElement</code> containing the rendered value.
	     */
	    renderOneValue(value: string): HTMLElement;
	    protected getValueContainer(): HTMLElement;
	    private getHelperOptions();
	    private getFullDate(date, helper);
	    private appendValuesToDom(values);
	    private bindEventOnValue(element, value);
	}

}
declare module Coveo {
	
	
	
	
	export interface IFieldTableOptions {
	    allowMinimization: boolean;
	    expandedTitle: string;
	    minimizedTitle: string;
	    minimizedByDefault: boolean;
	}
	/**
	 * This component is used to display a set of {@link FieldValue} components in a table which
	 * can be optionally expanded and minimized.<br/>
	 * Automatically, it will take care of not displaying empty field values.
	 *
	 * # Examples
	 *
	 * ```
	 * // This is the FieldTable component itself, which holds a list of table row.
	 * // Each row is a FieldValue component
	 * <table class='CoveoFieldTable'>
	 *    // Items
	 *    <tr data-field='@sysdate' data-caption='Date' data-helper='dateTime' />
	 *    <tr data-field='@sysauthor' data-caption='Author' />
	 *    <tr data-field='@clickuri' data-html-value='true' data-caption='URL' data-helper='anchor' data-helper-options='{text: \"<%= raw.syssource %>\" , target:\"_blank\"}'>
	 * </table>
	 * ```
	 */
	export class FieldTable extends Component {
	    element: HTMLElement;
	    options: IFieldTableOptions;
	    result: IQueryResult;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IFieldTableOptions;
	    isExpanded: boolean;
	    private toggleButton;
	    private toggleIcon;
	    private toggleCaption;
	    private toggleButtonInsideTable;
	    private toggleContainer;
	    private toggleContainerHeight;
	    /**
	     * Create a new FieldTable
	     * @param element
	     * @param options
	     * @param bindings
	     * @param result
	     */
	    constructor(element: HTMLElement, options?: IFieldTableOptions, bindings?: IComponentBindings, result?: IQueryResult);
	    /**
	     * Toggle between expanding and minimizing the FieldTable
	     * @param anim Specifies whether to show a sliding animation when toggling
	     */
	    toggle(anim?: boolean): void;
	    /**
	     * Expand (show) the FieldTable
	     * @param anim Specifies whether to show a sliding animation when opening
	     */
	    expand(anim?: boolean): void;
	    /**
	     * Minimize (collapse) the FieldTable
	     * @param anim Specifies whether to show a sliding animation when collapsing
	     */
	    minimize(anim?: boolean): void;
	    protected isTogglable(): boolean;
	    private buildToggle();
	    private slideToggle(visible?, anim?);
	    private updateToggleContainerHeight();
	}
	export interface IValueRowOptions extends IFieldValueOptions {
	    caption?: string;
	}

}
declare module Coveo {
	
	
	
	export interface IBadgeOptions extends IFieldValueOptions {
	    colors: IBadgeColors;
	}
	export interface IBadgeColors extends IBadgeColor {
	    values?: {
	        [value: string]: IBadgeColors;
	    };
	}
	export interface IBadgeColor {
	    icon?: string;
	    text?: string;
	}
	/**
	 * This component is used to easily output a field value with customizable colors and an icon preceding it.<br/>
	 * It extends {@link FieldValue}, so any options on that component can be used on Badge.<br/>
	 * It is possible to configure the default colors, but also to set colors specific to
	 * the current field value.
	 */
	export class Badge extends FieldValue {
	    options: IBadgeOptions;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IBadgeOptions;
	    static parent: typeof FieldValue;
	    /**
	     * Build a new Badge component
	     * @param element
	     * @param options
	     * @param bindings
	     * @param result
	     */
	    constructor(element: HTMLElement, options?: IBadgeOptions, bindings?: IComponentBindings, result?: IQueryResult);
	    private static colorRegex;
	    private static colorsRegex;
	    /**
	     * Parse the passed color string into a workable format.
	     * See {@link Badge.options.colors} for more info on defining colors.
	     * @param colorsOption The color string to parse
	     */
	    static parseColors(colorsOption: string): IBadgeColors;
	    /**
	     * Get the icon and text color for the passed field value.<br/>
	     * Returns an object with the `icon` and `text` keys,
	     * representing their respective colors.
	     * @param value The field value for which the colors are returned
	     */
	    getColor(value?: string): IBadgeColor;
	    /**
	     * Render one string value with the appropriate colors and icon.<br/>
	     * Returns an HTML `span` containing the rendered value
	     * @param value The field value to render
	     */
	    renderOneValue(value: string): HTMLElement;
	}

}
declare module Coveo {
	
	
	
	export enum RatingValues {
	    Undefined = 0,
	    Lowest = 1,
	    Low = 2,
	    Average = 3,
	    Good = 4,
	    Best = 5,
	}
	export interface IResultRatingOptions {
	}
	/**
	 * Component used to render document rating. Allows search users to rate a result with a 5-star representation.
	 * Interactive rating is possible if collaborative rating is enabled.
	 */
	export class ResultRating extends Component {
	    element: HTMLElement;
	    options: IResultRatingOptions;
	    bindings: IComponentBindings;
	    result: IQueryResult;
	    static ID: string;
	    constructor(element: HTMLElement, options?: IResultRatingOptions, bindings?: IComponentBindings, result?: IQueryResult);
	    private renderComponent(element, rating);
	    private renderStar(element, isChecked, value);
	    /**
	     * Rates a document with the specified rating value.
	     * @param rating The rating assigned to the document. Specified using the enum RatingValues.
	     * Possible values are: Undefined, Lowest, Low, Average, Good and Best.
	     */
	    rateDocument(rating: RatingValues): void;
	}

}
declare module Coveo {
	
	
	export interface IPreferencesPanelOptions {
	}
	/**
	 * A panel that is displayed inside the {@link Settings} component, and allows end user to select some customization for their interface, saved in local storage.
	 */
	export class PreferencesPanel extends Component {
	    element: HTMLElement;
	    options: IPreferencesPanelOptions;
	    static ID: string;
	    static options: IPreferencesPanelOptions;
	    /**
	     * Create a new PreferencesPanel
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options: IPreferencesPanelOptions, bindings?: IComponentBindings);
	    /**
	     * Open the PreferencesPanel
	     */
	    open(): void;
	    /**
	     * Close the PreferencesPanel without saving changes
	     */
	    close(): void;
	    /**
	     * Save the changes
	     */
	    save(): void;
	    private buildCloseButton();
	    private buildTitle();
	}

}
declare module Coveo {
	export interface IPreferencePanelInputToBuild {
	    label: string;
	    placeholder?: string;
	    tab?: string[];
	    expression?: string;
	    otherAttribute?: string;
	}
	export class PreferencesPanelBoxInput {
	    private boxInputToBuild;
	    private nameOfInput;
	    private type;
	    inputs: {
	        [label: string]: HTMLElement;
	    };
	    private inputTemplate;
	    constructor(boxInputToBuild: IPreferencePanelInputToBuild[], nameOfInput: string, type: string);
	    build(): HTMLElement;
	    select(toSelect: string): void;
	    unselect(toUnselect: string): void;
	    getSelected(): string;
	    getSelecteds(): string[];
	}
	export class PreferencesPanelRadioInput extends PreferencesPanelBoxInput {
	    private radioElementToBuild;
	    private name;
	    constructor(radioElementToBuild: IPreferencePanelInputToBuild[], name: string);
	}
	export class PreferencesPanelCheckboxInput extends PreferencesPanelBoxInput {
	    private checkboxElementToBuild;
	    name: string;
	    constructor(checkboxElementToBuild: IPreferencePanelInputToBuild[], name: string);
	    build(): HTMLElement;
	}
	export class PreferencesPanelTextInput {
	    textElementToBuild: IPreferencePanelInputToBuild[];
	    name: string;
	    inputs: {
	        [label: string]: HTMLElement;
	    };
	    inputTemplate: (...data: any[]) => string;
	    constructor(textElementToBuild: IPreferencePanelInputToBuild[], name: string);
	    build(): HTMLElement;
	    getValues(): string[];
	    setValue(input: string, value: string): void;
	    reset(): void;
	    private getInput(input);
	}
	export class PreferencesPanelTextAreaInput extends PreferencesPanelTextInput {
	    inputTemplate: (...data: any[]) => string;
	    build(): HTMLElement;
	}
	export class PreferencePanelMultiSelectInput {
	    private toBuild;
	    options: string[];
	    name: string;
	    private textInput;
	    private select;
	    constructor(toBuild: IPreferencePanelInputToBuild, options: string[], name: string);
	    build(): HTMLElement;
	    getValues(): string[];
	    setValues(values: string[]): void;
	    reset(): void;
	}

}
declare module Coveo {
	
	
	export interface IResultFilterPreference {
	    selected?: boolean;
	    custom?: boolean;
	    tab?: string[];
	    caption: string;
	    expression: string;
	}
	export interface IResultsFiltersPreferencesOptions {
	    filters?: {
	        [caption: string]: {
	            expression: string;
	            tab?: string[];
	        };
	    };
	    includeInBreadcrumb?: boolean;
	    showAdvancedFilters?: boolean;
	}
	/**
	 * This component allows end-users to create their own customized filters to apply to their search.<br/>
	 * It is a feature meant for advanced user that understand the Coveo Query syntax.<br/>
	 * These preferences are saved in the localStorage of each user.<br/>
	 * This component is normally accessible visually using the {@link Settings} menu.<br/>
	 * It is usually located, in the DOM, inside the {@link PreferencesPanel} component.
	 */
	export class ResultsFiltersPreferences extends Component {
	    element: HTMLElement;
	    options: IResultsFiltersPreferencesOptions;
	    bindings: IComponentBindings;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IResultsFiltersPreferencesOptions;
	    preferences: {
	        [caption: string]: IResultFilterPreference;
	    };
	    private preferencePanelLocalStorage;
	    private preferencePanel;
	    private preferenceContainer;
	    private preferencePanelCheckboxInput;
	    private advancedFilters;
	    private advancedFiltersBuilder;
	    private advancedFiltersTextInputCaption;
	    private advancedFiltersTextInputExpression;
	    private advancedFiltersTabSelect;
	    private advancedFilterFormValidate;
	    constructor(element: HTMLElement, options: IResultsFiltersPreferencesOptions, bindings: IComponentBindings);
	    createDom(): void;
	    save(): void;
	    exitWithoutSave(): void;
	    private bindPreferencePanelEvent();
	    private bindBreadcrumbEvent();
	    private bindQueryEvent();
	    private handleBuildingQuery(args);
	    private handlePopulateBreadcrumb(args);
	    private handleClearBreadcrumb();
	    private buildTitle();
	    private buildAdvancedFilters();
	    private buildAdvancedFilterInput();
	    private buildAdvancedFilterFormValidate();
	    private getAllTabs();
	    private getPreferencesBoxInputToBuild();
	    private buildCheckboxesInput();
	    private buildDeleteAdvancedFilter();
	    private buildEditAdvancedFilter();
	    private buildBreadcrumb(filter);
	    private confirmDelete(filter, filterElement);
	    private editElement(filter, filterElement);
	    private populateEditSection(toPopulate?);
	    private deleteFilterPreference(filter, filterElement);
	    private openAdvancedFilterSectionOrSaveFilters();
	    private validateAndSaveAdvancedFilter(e);
	    private fromPreferencesToCheckboxInput();
	    private fromCheckboxInputToPreferences();
	    private getDormantFilters();
	    private getActiveFilters();
	    private getInactiveFilters();
	    private getActiveTab();
	    private filterIsInActiveTab(filter, tab);
	    private getFilterElementByCaption(caption);
	    private fromResultsFilterOptionToResultsPreferenceInterface();
	    private mergeLocalPreferencesWithStaticPreferences();
	    private fromFilterToAnalyticsEvent(filter, type);
	}

}
declare module Coveo {
	
	
	export interface IQueryDurationOptions {
	}
	/**
	 * This component is used to display the time it took to execute the query.
	 * When a {@link QueryEvents.querySuccess} event is called, it shows itself and displays
	 * the global duration, the index duration, the proxy duration, and the client duration in a tooltip.<br/>
	 * If a {@link QueryEvents.queryError} event is called, it hides.
	 */
	export class QueryDuration extends Component {
	    element: HTMLElement;
	    options: IQueryDurationOptions;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IQueryDurationOptions;
	    private textContainer;
	    /**
	     * Create a new QueryDuration component.
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: IQueryDurationOptions, bindings?: IComponentBindings);
	    private handleQuerySuccess(data);
	    private formatQueryDuration(durationInMillis);
	}

}
declare module Coveo {
	
	
	export interface IQuerySummaryOptions {
	    enableSearchTips?: boolean;
	    onlyDisplaySearchTips?: boolean;
	}
	/**
	 * This component displays information about the current range of results being displayed (ex: 1-10 of 123).<br/>
	 * If the query matches no documents, it will display advices and tip for the end user on how to remedy the problem.
	 */
	export class QuerySummary extends Component {
	    element: HTMLElement;
	    options: IQuerySummaryOptions;
	    static ID: string;
	    /**
	     * Options for the component
	     * @componentOptions
	     */
	    static options: IQuerySummaryOptions;
	    private textContainer;
	    constructor(element: HTMLElement, options?: IQuerySummaryOptions, bindings?: IComponentBindings);
	    private hide();
	    private show();
	    private handleQuerySuccess(data);
	    private displayInfoOnNoResults();
	}

}
declare module Coveo {
	
	
	export interface IShareQueryOptions {
	}
	/**
	 * ShareQuery shows 2 text boxes, one with a shareable link and the
	 * other with the complete query expression of the currently performed query.<br/>
	 * It populates the {@link Settings} component's menu for easy access.
	 */
	export class ShareQuery extends Component {
	    element: HTMLElement;
	    options: IShareQueryOptions;
	    static ID: string;
	    static options: IShareQueryOptions;
	    dialogBoxContent: HTMLElement;
	    private linkToThisQuery;
	    private completeQuery;
	    /**
	     * Create a new ShareQuery component.
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options: IShareQueryOptions, bindings?: IComponentBindings);
	    /**
	     * Show the ShareQuery
	     */
	    open(): void;
	    /**
	     * Hide the ShareQuery
	     */
	    close(): void;
	    /**
	     * Get the link to the current query
	     */
	    getLinkToThisQuery(): string;
	    /**
	     * Set the link to the current query
	     */
	    setLinkToThisQuery(link: string): void;
	    /**
	     * Get the complete query string
	     */
	    getCompleteQuery(): string;
	    /**
	     * Set the complete query string
	     */
	    setCompleteQuery(completeQuery: string): void;
	    private handleProcessNewQueryResults(args);
	    private outputIfNotNull(value);
	    private buildContent();
	    private buildTextBoxWithLabel(label, input);
	    static create(element: HTMLElement, options?: IShareQueryOptions, root?: HTMLElement): ShareQuery;
	}

}
declare module Coveo {
	
	
	
	export interface ISortOptions {
	    sortCriteria?: SortCriteria[];
	    caption?: string;
	}
	/**
	 * This component displays a sort criteria for searching.
	 */
	export class Sort extends Component {
	    element: HTMLElement;
	    options: ISortOptions;
	    static ID: string;
	    /**
	     * Options for the component
	     * @componentOptions
	     */
	    static options: ISortOptions;
	    private currentCriteria;
	    /**
	     * Create a new Sort component.
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: ISortOptions, bindings?: IComponentBindings);
	    /**
	     * Select the Sort component.
	     * @param direction The sort direction (e.g. ascending, descending).
	     *
	     * Will trigger a query if the selection made the criteria change (if it was toggled).
	     */
	    select(direction?: string): void;
	    enable(): void;
	    disable(): void;
	    /**
	     * Get the current SortCriteria.
	     */
	    getCurrentCriteria(): SortCriteria;
	    /**
	     * Returns true if one of the sort criterias matches the passed argument.
	     * @param sortId The sort criteria to verify with (e.g. 'date descending')
	     */
	    match(sortId: string): boolean;
	    private handleQueryStateChanged(data);
	    private update();
	    private handleBuildingQuery(data);
	    private handleQuerySuccess(data);
	    private handleQueryError(data);
	    private handleClick();
	    private isToggle();
	    private isSelected();
	    private updateAppearance();
	}

}
declare module Coveo {
	
	
	export interface ITriggersOptions {
	}
	/**
	 * This component enables the use of triggers (<code>notify</code>, <code>execute</code>, <code>query</code>, <code>redirect</code>) generated by the Search API
	 * based on <a href='https://developers.coveo.com/display/public/SearchREST/Trigger'>Trigger statements</a>
	 * in the query pipeline (See <a href='https://developers.coveo.com/display/public/SearchREST/Managing+the+Query+Pipeline'>Managing the Query Pipeline</a>)
	 */
	export class Triggers extends Component {
	    element: HTMLElement;
	    options: ITriggersOptions;
	    bindings: IComponentBindings;
	    _window: Window;
	    static ID: string;
	    static options: ITriggersOptions;
	    /**
	     * The list of notifications returned by the Search API for the current query (via 'notify' triggers).<br/>
	     * This list is automatically displayed visually in the component.
	     */
	    notifications: string[];
	    /**
	     * Build a new Triggers component
	     * @param element
	     * @param options
	     * @param bindings
	     * @param _window
	     */
	    constructor(element: HTMLElement, options?: ITriggersOptions, bindings?: IComponentBindings, _window?: Window);
	    private handleProcessNewQueryResults(data);
	    private executeTriggers(trigger, type, func, single?);
	}

}
declare module Coveo {
	
	
	export interface IRecommendationQueryOptions {
	}
	export class RecommendationQuery extends Component {
	    element: HTMLElement;
	    options: IRecommendationQueryOptions;
	    static ID: string;
	    /**
	     * The options for the RecommendationQuery component
	     * @componentOptions
	     */
	    static options: IRecommendationQueryOptions;
	    private content;
	    constructor(element: HTMLElement, options?: IRecommendationQueryOptions, bindings?: IComponentBindings);
	    private handleBuildingQuery(data);
	}

}
declare module Coveo {
	
	
	
	
	export interface ITemplateLoaderOptions {
	    template: Template;
	    condition?: String;
	}
	export class TemplateLoader extends Component {
	    element: HTMLElement;
	    options: ITemplateLoaderOptions;
	    bindings: IComponentBindings;
	    result: IQueryResult;
	    static ID: string;
	    static options: ITemplateLoaderOptions;
	    constructor(element: HTMLElement, options?: ITemplateLoaderOptions, bindings?: IComponentBindings, result?: IQueryResult);
	    private initialize();
	}

}
declare module Coveo {
	
	export interface ISuggestionForOmniboxOptionsOnSelect {
	    (value: string, args: IPopulateOmniboxEventArgs): void;
	}
	export interface ISuggestionForOmniboxOptions {
	    omniboxZIndex?: number;
	    headerTitle?: string;
	    onSelect?: ISuggestionForOmniboxOptionsOnSelect;
	    numberOfSuggestions?: number;
	}
	export interface ISuggestionForOmniboxTemplate {
	    header?: {
	        template: (...args: any[]) => string;
	        title: string;
	    };
	    row: (...args: any[]) => string;
	}
	export interface ISuggestionForOmniboxResult {
	    value: string;
	}
	export class SuggestionForOmnibox {
	    structure: ISuggestionForOmniboxTemplate;
	    onSelect: (value: string, args: IPopulateOmniboxEventArgs) => void;
	    constructor(structure: ISuggestionForOmniboxTemplate, onSelect: (value: string, args: IPopulateOmniboxEventArgs) => void);
	    buildOmniboxElement(results: ISuggestionForOmniboxResult[], args: IPopulateOmniboxEventArgs): HTMLElement;
	    private buildElementHeader();
	    private buildRowElements(results, args);
	}

}
declare module Coveo {
	
	
	
	export interface IAnalyticsSuggestionsOptions extends ISuggestionForOmniboxOptions {
	}
	/**
	 * This component is used to provide query suggestions based on the most commonly logged queries by a Coveo Analytics service.
	 * In order to provide relevant suggestions, they are shown in order of successful document views: thus, queries resulting in no clicks from users or that require refinements are not suggested if better options exist.
	 * These suggestions appear in the Omnibox Component. This component is thus highly related to the {@link Analytics} Component.
	 * While a user is typing in a query box, he will be able to see and select the most commonly used queries.
	 */
	export class AnalyticsSuggestions extends Component {
	    options: IAnalyticsSuggestionsOptions;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IAnalyticsSuggestionsOptions;
	    private suggestionForOmnibox;
	    private partialQueries;
	    private lastSuggestions;
	    private resultsToBuildWith;
	    private currentlyDisplayedSuggestions;
	    constructor(element: HTMLElement, options: IAnalyticsSuggestionsOptions, bindings?: IComponentBindings);
	    /**
	     * Select a currently displayed suggestion. This means that at least one suggestion must have been returned at least once.
	     * The suggestion parameter can either be a number (0 based index of the suggestion to select) or a string that match the suggestion
	     * @param suggestion
	     */
	    selectSuggestion(suggestion: number): any;
	    selectSuggestion(suggestion: string): any;
	    private handlePopulateOmnibox(args);
	    private onRowSelection(value, args);
	    private cleanCustomData(toClean, rejectLength?);
	}

}
declare module Coveo {
	
	
	
	export interface IFieldSuggestionsOptions extends ISuggestionForOmniboxOptions {
	    field?: string;
	    queryOverride?: string;
	}
	/**
	 * This component provides query suggestions based on a particular facet field.
	 * For example, this can be used to provide auto-complete suggestions when you type in document titles.
	 */
	export class FieldSuggestions extends Component {
	    options: IFieldSuggestionsOptions;
	    static ID: string;
	    /**
	     * @componentOptions
	     */
	    static options: IFieldSuggestionsOptions;
	    private suggestionForOmnibox;
	    private currentlyDisplayedSuggestions;
	    /**
	     * Create a new FieldSuggestions component
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options: IFieldSuggestionsOptions, bindings?: IComponentBindings);
	    /**
	     * Select a currently displayed suggestion. This means that at least one suggestion must have been returned at least once.
	     * The suggestion parameter can either be a number (0 based index of the suggestion to select) or a string that match the suggestion
	     * @param suggestion
	     */
	    selectSuggestion(suggestion: number): any;
	    selectSuggestion(suggestion: string): any;
	    private handlePopulateOmnibox(args);
	    private onRowSelection(value, args);
	    private buildListFieldValueRequest(valueToSearch);
	}

}
declare module Coveo {
	/// <reference path="../../../../node_modules/modal-box/bin/ModalBox.d.ts" />
	
	
	export interface IAuthenticationProviderOptions {
	    name?: string;
	    caption?: string;
	    useIFrame?: boolean;
	    showIFrame?: boolean;
	}
	/**
	 * This component arranges for queries to be executed with an identity obtained
	 * using an Authentication Provider configured on the Coveo Search API
	 * (see [On-Premises SharePoint Claims Authentication](https://developers.coveo.com/display/public/SearchREST/On-Premises+SharePoint+Claims+Authentication)).
	 * When needed, the component will handle redirecting the browser to the address
	 * that starts the authentication process.
	 *
	 * Using the standard `data-tab` attribute, you can enable the
	 * AuthenticationProvider component only for tabs in which authentication is
	 * required (see {@link Tab}).
	 */
	export class AuthenticationProvider extends Component {
	    element: HTMLElement;
	    options: IAuthenticationProviderOptions;
	    _window: Window;
	    static ID: string;
	    /**
	     * The options for the component.
	     * @componentOptions
	     */
	    static options: IAuthenticationProviderOptions;
	    private handlers;
	    private redirectCount;
	    /**
	     * Build a new AuthenticationProvider component
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options?: IAuthenticationProviderOptions, bindings?: IComponentBindings, _window?: Window);
	    private handleBuildingCallOptions(args);
	    private handleQueryError(args);
	    private authenticateWithProvider();
	    private redirectToAuthenticationProvider();
	    private authenticateWithIFrame();
	    private createHandler(modalbox, iframe);
	    private handleNuke();
	    private createPopupForWaitMessage(iframe);
	    private createPopupForVisibleIFrame(iframe);
	    private getAuthenticationProviderUriForRedirect();
	    private getAuthenticationProviderUriForIFrame();
	}

}
declare module Coveo {
	
	
	
	export interface IResultTaggingOptions {
	    field: string;
	    suggestBoxSize?: number;
	    autoCompleteTimer?: number;
	}
	export interface IAnalyticsResultTaggingMeta {
	    facetId: string;
	    facetValue?: string;
	    facetTitle?: string;
	}
	/**
	 * This component can be used as part of a result template to list the current tag field values for the search result
	 * and display a control that allows end-users to add a value to a tag field.
	 */
	export class ResultTagging extends Component {
	    element: HTMLElement;
	    options: IResultTaggingOptions;
	    result: IQueryResult;
	    static ID: string;
	    static autoCompleteClass: string;
	    /**
	     * @componentOptions
	     */
	    static options: IResultTaggingOptions;
	    static AUTO_COMPLETE_CLASS: string;
	    private autoCompleteZone;
	    private textBox;
	    private autoCompletePopup;
	    private tagZone;
	    private tags;
	    constructor(element: HTMLElement, options?: IResultTaggingOptions, bindings?: IComponentBindings, result?: IQueryResult);
	    private buildExistingTags();
	    private buildTagIcon();
	    private focusOnTextBox();
	    private buildTagValue(tagValue);
	    private buildShortenedTagWithTitle(tagValue);
	    private buildTextBox();
	    private buildAddIcon();
	    private buildClearIcon();
	    private bindFacetEventOnValue(element, value);
	    private clearPopup();
	    private showPopup();
	    private populateSuggestions();
	    private manageAutocompleteAutoHide();
	    private buildRegEx(searchTerm);
	    private buildTermToExclude(term);
	    private manageUpDownEnter(code);
	    private computeNextIndex(code, selectableArray);
	    private buildSelectableValue(lookupValue);
	    private doRemoveTag(element, tagValue);
	    private doAddTagWithValue(tagValue);
	    private doAddSingleTagValue(tagValue);
	    private doAddTag();
	}

}
declare module Coveo {
	
	
	
	export interface IResultsPreferencesOptions {
	    enableOpenInOutlook?: boolean;
	    enableOpenInNewWindow?: boolean;
	}
	/**
	 * This component allows users to select preferences related to their search results.<br/>
	 * These preferences are saved in the localStorage of each user.<br/>
	 * This component is normally accessible visually using the {@link Settings} menu.<br/>
	 * It is usually located, in the DOM, inside the {@link PreferencesPanel} component.
	 */
	export class ResultsPreferences extends Component {
	    element: HTMLElement;
	    options: IResultsPreferencesOptions;
	    bindings: IComponentBindings;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IResultsPreferencesOptions;
	    preferences: IResultLinkOptions;
	    private preferencePanelLocalStorage;
	    private preferencesPanel;
	    private preferencePanelCheckboxInput;
	    /**
	     * Create a new ResultsPreference component
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options: IResultsPreferencesOptions, bindings: IComponentBindings);
	    /**
	     * Save the current state of the preferences to local storage
	     */
	    save(): void;
	    exitWithoutSave(): void;
	    private updateComponentOptionsModel();
	    private buildTitle();
	    private buildCheckboxesInput();
	    private fromCheckboxInputToPreferences();
	    private fromPreferencesToCheckboxInput();
	    private fromPreferenceChangeEventToUsageAnalyticsLog(e);
	}

}
declare module Coveo {
	
	
	export var context: any;
	export interface IPipelineContextOptions {
	}
	export class PipelineContext extends Component {
	    element: HTMLElement;
	    options: IPipelineContextOptions;
	    bindings: IComponentBindings;
	    static ID: string;
	    static CURRENT_URL: string;
	    private content;
	    constructor(element: HTMLElement, options?: IPipelineContextOptions, bindings?: IComponentBindings);
	    private handleBuildingQuery(args);
	    getContextKeys(): string[];
	    getContextValue(key: string): string;
	}

}
declare module Coveo {
	
	
	
	
	
	export interface IOmniboxResultListOptions extends IResultListOptions {
	    omniboxZIndex?: number;
	    onSelect?: (result: IQueryResult, resultElement: HTMLElement, omniboxObject: IPopulateOmniboxEventArgs) => void;
	    headerTitle?: string;
	    queryOverride?: string;
	}
	/**
	 * This component is exactly like a normal ResultList Component, except that it will render itself inside the Omnibox Component.
	 * This will provide a kind of search as you type functionnality, allowing you to easily render complex Result Templates inside the Omnibox Component.
	 *
	 * # Example
	 * ```
	 *     <div class="CoveoOmniboxResultList">
	 *         <script class="result-template" type="text/x-underscore">
	 *             <div>
	 *                 <a class='CoveoResultLink'></a>
	 *             </div>
	 *         </script>
	 *     </div>
	 * ```
	 */
	export class OmniboxResultList extends ResultList {
	    element: HTMLElement;
	    options: IOmniboxResultListOptions;
	    bindings: IComponentBindings;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: IOmniboxResultListOptions;
	    private lastOmniboxRequest;
	    constructor(element: HTMLElement, options?: IOmniboxResultListOptions, bindings?: IComponentBindings);
	    /**
	     * Build and return an array of HTMLElement with the given result set.
	     * @param results
	     */
	    buildResults(results: IQueryResults): HTMLElement[];
	    renderResults(resultsElement: HTMLElement[], append?: boolean): void;
	    private setupOptions();
	    private handlePopulateOmnibox(args);
	    private handleQueryOverride(args);
	    private onRowSelection(result, resultElement, omniboxObject);
	}

}
declare module Coveo {
	
	
	export interface ICurrentTabOptions {
	    tabSectionToOpen: string;
	}
	/**
	 * This component is used to display the name of the currently selected tab.
	 * If no tabs are selected, this component is hidden.
	 */
	export class CurrentTab extends Component {
	    element: HTMLElement;
	    options: ICurrentTabOptions;
	    static ID: string;
	    /**
	     * The options for the component
	     * @componentOptions
	     */
	    static options: ICurrentTabOptions;
	    constructor(element: HTMLElement, options?: ICurrentTabOptions, bindings?: IComponentBindings);
	    private handleTabChange();
	}

}
declare module Coveo {
	
	
	export interface IImageResultListOptions extends IResultListOptions {
	    layoutType?: string;
	    heightThreshold?: number;
	    columnWidth?: number;
	}
	/**
	 * This component is an extension of the ResultList component to display image results.
	 */
	export class ImageResultList extends ResultList {
	    element: HTMLElement;
	    options: IImageResultListOptions;
	    static ID: string;
	    static rowLayoutTypeStr: string;
	    static columnLayoutTypeStr: string;
	    /**
	     * The options for the component.
	     * This component inherits the options of the {@link ResultList} component.
	     * @componentOptions
	     */
	    static options: IImageResultListOptions;
	    private columnResultsArray;
	    private imagesInCurrentRow;
	    private resultIndex;
	    private lastRowHeight;
	    constructor(element: HTMLElement, options?: IImageResultListOptions, bindings?: IComponentBindings, elementClassId?: string);
	    private getResultsElement();
	    private getResultsElementImages();
	    private getResultsContainerDiv();
	    private bindWindowResizeEvent();
	    private handleNuke();
	    private resize();
	    private handleProcessNewResultsDisplayed();
	    private addTransitionAllToElement(elements);
	    private retrieveLayoutMethod();
	    private onImageProxy(callback);
	    private getHorizontalMargin(element);
	    private getVerticalMargin(element);
	    private setupColumns();
	    private positionColumns(colWidth, margin);
	    private setResultsContainerHeight(height);
	    private setupRows();
	    private getCurrentRowHeight(results, containerWidth);
	    private getImageDimensionsFromResult(result);
	    private setCurrentRowImagesDimensions(images, height, top);
	    private adjustNumberOfResults();
	}

}
declare module Coveo {
	
	
	export var jQueryInstance: JQueryStatic;
	export class CoveoJQuery {
	    static automaticallyCreateComponentsInside(element: HTMLElement, initParameters: IInitializationParameters, ignore?: string[]): void;
	    static registerAutoCreateComponent(cmp: IComponentDefinition): void;
	}
	export function jQueryIsDefined(): boolean;

}
declare module Coveo {
	export let underscoreInstance: any;

}
declare module Coveo {
	
	
	
	
	export interface IFollowItemOptions {
	    watchedFields?: string[];
	    modifiedDateField?: string;
	}
	/**
	 * This component allows the user to follow a particular result.
	 * By following a result, the user will receive emails informing him when the result has changed.
	 * A {@link SearchAlerts} component must be present in the page for this component to work.
	 */
	export class FollowItem extends Component {
	    element: HTMLElement;
	    options: IFollowItemOptions;
	    bindings: IResultsComponentBindings;
	    result: IQueryResult;
	    static ID: string;
	    static fields: string[];
	    /**
	     * The options for the follow item component
	     * @componentOptions
	     */
	    static options: IFollowItemOptions;
	    private container;
	    private text;
	    private subscription;
	    constructor(element: HTMLElement, options?: IFollowItemOptions, bindings?: IResultsComponentBindings, result?: IQueryResult);
	    private updateIsFollowed();
	    setFollowed(subscription: ISubscription): void;
	    setNotFollowed(): void;
	    protected getText(): string;
	    /**
	     * Follows the result if it was not followed and stops following the result if it was followed.
	     */
	    toggleFollow(): void;
	    private handleSubscriptionDeleted(args);
	    private handleSubscriptionCreated(args);
	    private remove();
	    private getId();
	    private static buildFollowRequest(id, title, options);
	}

}
declare module Coveo {
	
	
	
	export interface ISearchAlertMessageOptions {
	    closeDelay: number;
	}
	/**
	 * This component allows the {@link SearchAlerts} component to display messages.
	 * This component should not be included in a web page. Instead, use a {@link SearchAlerts} component and access its message attribute.
	 */
	export class SearchAlertsMessage extends Component {
	    element: HTMLElement;
	    options: ISearchAlertMessageOptions;
	    bindings: IComponentBindings;
	    static ID: string;
	    /**
	     * The options for the SearchAlertsMessage component
	     * @componentOptions
	     */
	    static options: ISearchAlertMessageOptions;
	    private message;
	    private closeTimeout;
	    constructor(element: HTMLElement, options: ISearchAlertMessageOptions, bindings?: IComponentBindings);
	    getCssClass(): string;
	    /**
	     * Displays a message near the dom attribute.
	     * @param dom Specifies where to display the message.
	     * @param message The message.
	     * @param error Specifies whether this is an error message or not.
	     */
	    showMessage(dom: Dom, message: string, error: boolean): void;
	    private handleSubscriptionCreated(args);
	    private handleSearchAlertsFail(args);
	    private startCloseDelay();
	    private stopCloseDelay();
	    private close();
	}

}
declare module Coveo {
	/// <reference path="../../../../node_modules/modal-box/bin/ModalBox.d.ts" />
	
	
	
	
	export interface ISearchAlertsOptions {
	    enableManagePanel?: boolean;
	    enableFollowQuery?: boolean;
	    modifiedDateField?: string;
	    enableMessage?: boolean;
	    messageCloseDelay?: number;
	}
	/**
	 * This component allows the user to manage his search alerts and to follow queries by adding menu items in the {@link Settings} component.
	 * By following queries, the user will receive emails informing him when the results of the query have changed.
	 */
	export class SearchAlerts extends Component {
	    element: HTMLElement;
	    options: ISearchAlertsOptions;
	    static ID: string;
	    /**
	     * The options for the search alerts
	     * @componentOptions
	     */
	    static options: ISearchAlertsOptions;
	    private modal;
	    /**
	     * A reference to a {@link SearchAlertsMessage} component used to display message.
	     * This attribute is set only when the enableMessage option is true.
	     */
	    message: SearchAlertsMessage;
	    constructor(element: HTMLElement, options: ISearchAlertsOptions, bindings?: IComponentBindings);
	    /**
	     * Opens the search alerts manage panel.
	     * This panel allows the user to stop following queries or documents.
	     * It also allows the user to change the frequency at which he will receive emails.
	     */
	    openPanel(): Promise<ISubscription>;
	    private handleSearchAlertsFail();
	    private close();
	    private addSearchAlert(subscription, container);
	    private updateAndSyncSearchAlert(subscription);
	    /**
	     * Follow the last query.
	     * The user will start to receive emails when the results from that query changes.
	     */
	    followQuery(): void;
	    private triggerSearchAlertsFail();
	    protected findQueryBoxDom(): HTMLElement;
	    private static buildFollowQueryRequest(query, options);
	    static create(element: HTMLElement, options?: ISearchAlertsOptions, root?: HTMLElement): SearchAlerts;
	}

}
declare module Coveo {
	
	
	export interface ITextOptions {
	    value?: string;
	    size?: string;
	    style?: string;
	    weight?: string;
	    textAlign?: string;
	    marginTop?: string;
	    marginBottom?: string;
	    marginLeft?: string;
	    marginRight?: string;
	    paddingTop?: string;
	    paddingBottom?: string;
	    paddingLeft?: string;
	    paddingRight?: string;
	}
	/**
	 * This component only role is to be embedded in a result template and to output a simple text value.<br/>
	 * Thus, the only purpose is to be able to easily add different text value with the interface editor.<br/>
	 * If you are not designing a search using the interface editor, the usage of this component is not pertinent.
	 */
	export class Text extends Component {
	    element: HTMLElement;
	    options: ITextOptions;
	    static ID: string;
	    /**
	     * @componentOptions
	     */
	    static options: ITextOptions;
	    constructor(element: HTMLElement, options?: ITextOptions, bindings?: IComponentBindings);
	}

}
declare module Coveo {
	
	
	/**
	 * This component inherits from the {@link Folding} component.
	 * Folding conversations and threads requires different processing.
	 * When you need to fold children under a parent item, use this component.<br/>
	 * <b>This component works well with Chatter and Lithium</b>
	 */
	export class FoldingForThread extends Folding {
	    element: HTMLElement;
	    options: IFoldingOptions;
	    static ID: string;
	    /**
	     * Create a new FoldingForThread component
	     * @param element
	     * @param options
	     * @param bindings
	     */
	    constructor(element: HTMLElement, options: IFoldingOptions, bindings?: IComponentBindings);
	}

}
declare module Coveo {
	export class ChatterUtils {
	    static buildURI(objectURI: string, objectId: string, newObjectId: string): string;
	    static bindClickEventToElement(element: HTMLElement, openInPrimaryTab: boolean, openInSubTab: boolean): HTMLElement;
	}

}
declare module Coveo {
	
	
	
	export interface IChatterLikedByOptions {
	    nbLikesToRender: number;
	    openInPrimaryTab: boolean;
	    openInSubTab: boolean;
	}
	export class ChatterLikedBy extends Component {
	    element: HTMLElement;
	    options: IChatterLikedByOptions;
	    bindings: IComponentBindings;
	    result: IQueryResult;
	    static ID: string;
	    static options: IChatterLikedByOptions;
	    static fields: string[];
	    constructor(element: HTMLElement, options?: IChatterLikedByOptions, bindings?: IComponentBindings, result?: IQueryResult);
	    private renderLikesList(element, result, likeNames, likeIds, nbLikesToRender);
	    private renderLikeLink(result, likeName, likeId);
	}

}
declare module Coveo {
	
	
	
	export interface IChatterPostAttachmentOption {
	}
	export class ChatterPostAttachment extends Component {
	    element: HTMLElement;
	    options: IChatterPostAttachmentOption;
	    bindings: IResultsComponentBindings;
	    result: IQueryResult;
	    static ID: string;
	    static fields: string[];
	    constructor(element: HTMLElement, options?: IChatterPostAttachmentOption, bindings?: IResultsComponentBindings, result?: IQueryResult);
	}

}
declare module Coveo {
	
	
	
	export interface IChatterPostedByOption {
	    enablePostedOn: boolean;
	    useFromInstead: boolean;
	    openInPrimaryTab: boolean;
	    openInSubTab: boolean;
	}
	export class ChatterPostedBy extends Component {
	    element: HTMLElement;
	    options: IChatterPostedByOption;
	    bindings: IResultsComponentBindings;
	    result: IQueryResult;
	    static ID: string;
	    static options: IChatterPostedByOption;
	    static fields: string[];
	    constructor(element: HTMLElement, options?: IChatterPostedByOption, bindings?: IResultsComponentBindings, result?: IQueryResult);
	    private renderLink(text, id);
	}

}
declare module Coveo {
	
	
	
	export interface IChatterTopicOption {
	}
	export class ChatterTopic extends Component {
	    element: HTMLElement;
	    options: IChatterTopicOption;
	    bindings: IResultsComponentBindings;
	    result: IQueryResult;
	    static ID: string;
	    static fields: string[];
	    constructor(element: HTMLElement, options?: IChatterTopicOption, bindings?: IResultsComponentBindings, result?: IQueryResult);
	}

}
declare module Coveo {
	export interface IAPIAnalyticsFacetSelection {
	    entryName: string;
	    status: string;
	}

}
declare module Coveo {
	
	export interface IAPIAnalyticsFacet {
	    name: string;
	    fieldName: string;
	    sort: string;
	    mode: string;
	    selections: IAPIAnalyticsFacetSelection[];
	}

}
declare module Coveo {
	/// <reference path="Omnibox.d.ts" />
	
	export class TopQueryAddon {
	    omnibox: Omnibox;
	    static INDEX: number;
	    cache: {
	        [hash: string]: Promise<IOmniboxSuggestion[]>;
	    };
	    constructor(omnibox: Omnibox);
	    getSuggestion(): Promise<IOmniboxSuggestion[]>;
	}

}
declare module Coveo {
	
	
	
	export class StandaloneResult {
	    searchInterface: SearchInterface;
	    result: IQueryResult;
	    element: HTMLElement;
	    constructor(searchInterface: SearchInterface, resultTemplate: Template, result: IQueryResult);
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	
	
	export class FakeResults {
	    static createFakeResults(count?: number, token?: string): IQueryResults;
	    static createFakeResultsWithChildResults(count?: number, numberOfChildResults?: number, totalNumberOfChildResult?: number): IQueryResults;
	    static createFakeResult(token?: string): IQueryResult;
	    static createFakeResultWithChildResult(token: string, numberOfChildResult: number, totalNumberOfChildResult?: number): IQueryResult;
	    static createFakeResultWithAttachments(token?: string, numberOfAttachments?: number, attachmentType?: string[], flags?: string, attachmentsFlags?: string[], withSubAttachments?: boolean): IQueryResult;
	    static createFakeGroupByResult(field: string, token: string, count: number, includeComputedValues?: boolean): IGroupByResult;
	    static createFakeRangeGroupByResult(field: string, start?: number, end?: number, steps?: number): IGroupByResult;
	    static createFakeHierarchicalGroupByResult(field: string, token: string, numberOfLevel?: number, countByLevel?: number, delimitingCharacter?: string, includeComputedValues?: boolean, weirdCasing?: boolean): IGroupByResult;
	    static createFakeGroupByValue(token: string, count: number, score?: number, computedValue?: number): IGroupByValue;
	    static createFakeGroupByRangeValue(from: number, to: number, token: string, count: number, score?: number, computedValue?: number): IGroupByValue;
	    static createFakeFieldValue(token: string, count: number): IIndexFieldValue;
	    static createFakeFieldValues(token: string, count: number): IIndexFieldValue[];
	    static createFakeOmniboxData(token?: string, numberOfRows?: number, numberOfSelectablePerRow?: number, zIndex?: number): any[];
	    static createFakeDeferredOmniboxData(numberOfRows: number): any[];
	    static createFakeOmniboxSelectableData(token: string, numberOfSelectables: number): any[];
	    static createFakeFeedItemResult(token: string, nbLikes?: number, nbTopics?: number, hasAttachment?: boolean): IQueryResult;
	    static createFakeSearchEvent(token?: string): ISearchEvent;
	    static createFakeClickEvent(token?: string): IClickEvent;
	    static createPopulateOmniboxEventArgs(queryboxContent: string, cursorPosition: number, rows?: IOmniboxDataRow[]): IPopulateOmniboxEventArgs;
	}

}
declare module Coveo {
	
	
	
	
	
	
	
	
	
	
	
	export interface IMockEnvironment extends IComponentBindings {
	    root: HTMLElement;
	    element: HTMLElement;
	    result: IQueryResult;
	    searchEndpoint: SearchEndpoint;
	    searchInterface: SearchInterface;
	    queryController: QueryController;
	    queryStateModel: QueryStateModel;
	    usageAnalytics: IAnalyticsClient;
	}
	export interface IMockEnvironmentWithData<T> extends IMockEnvironment {
	    data: T;
	}
	export class MockEnvironmentBuilder {
	    root: HTMLElement;
	    element: HTMLElement;
	    result: IQueryResult;
	    searchEndpoint: SearchEndpoint;
	    searchInterface: SearchInterface;
	    queryController: QueryController;
	    queryStateModel: QueryStateModel;
	    componentStateModel: ComponentStateModel;
	    usageAnalytics: IAnalyticsClient;
	    componentOptionsModel: ComponentOptionsModel;
	    os: OS_NAME;
	    private built;
	    withRoot(root: HTMLElement): this;
	    withElement(element: HTMLElement): this;
	    withLiveQueryStateModel(): this;
	    withQueryStateModel(model: QueryStateModel): this;
	    withOldDesign(): this;
	    withCollaborativeRating(): this;
	    withOs(os: OS_NAME): this;
	    withResult(result?: IQueryResult): MockEnvironmentBuilder;
	    withEndpoint(endpoint?: SearchEndpoint): MockEnvironmentBuilder;
	    build(): IMockEnvironment;
	    getBindings(): IMockEnvironment;
	}
	export interface IBasicComponentSetup<T extends BaseComponent> {
	    env: IMockEnvironment;
	    cmp: T;
	}
	export class AdvancedComponentSetupOptions {
	    element: HTMLElement;
	    cmpOptions: any;
	    modifyBuilder: (env: MockEnvironmentBuilder) => MockEnvironmentBuilder;
	    constructor(element?: HTMLElement, cmpOptions?: any, modifyBuilder?: (env: MockEnvironmentBuilder) => MockEnvironmentBuilder);
	    merge(toMerge: AdvancedComponentSetupOptions): this;
	}
	export function mock<T>(contructorFunc: any, name?: string): T;
	export function mockWindow(): Window;
	export function mockComponent<T extends BaseComponent>(constructorFunc: any, name?: string): T;
	export function mockSearchInterface(): SearchInterface;
	export function mockQueryController(): QueryController;
	export function mockSearchEndpoint(): SearchEndpoint;
	export function mockUsageAnalytics(): IAnalyticsClient;
	export function basicComponentSetup<T>(klass: any, options?: {}): {
	    env: IMockEnvironment;
	    cmp: T;
	};
	export function basicResultComponentSetup<T>(klass: any): {
	    env: IMockEnvironment;
	    cmp: T;
	};
	export function basicSearchInterfaceSetup<T extends SearchInterface>(klass: any): {
	    env: IMockEnvironment;
	    cmp: T;
	};
	export function optionsSearchInterfaceSetup<T extends SearchInterface, U>(klass: any, options: U): {
	    env: IMockEnvironment;
	    cmp: T;
	};
	export function optionsResultComponentSetup<T, U>(klass: any, options: U, result: IQueryResult): {
	    env: IMockEnvironment;
	    cmp: T;
	};
	export function optionsComponentSetup<T, U>(klass: any, options: U): {
	    env: IMockEnvironment;
	    cmp: T;
	};
	export function advancedComponentSetup<T>(klass: any, options?: AdvancedComponentSetupOptions): {
	    env: IMockEnvironment;
	    cmp: T;
	};
	export function advancedResultComponentSetup<T>(klass: any, result: IQueryResult, options?: AdvancedComponentSetupOptions): {
	    env: IMockEnvironment;
	    cmp: T;
	};
	export function initPageViewScript(store: CoveoAnalytics.HistoryStore): void;

}
declare module Coveo {
	export function FacetQueryControllerTest(): void;

}
declare module Coveo {
	export function HistoryControllerTest(): void;

}
declare module Coveo {
	export function QueryControllerTest(): void;

}
declare module Coveo {
	/// <reference path="../../test/lib/jasmine.d.ts" />
	export function registerCustomMatcher(): void;

}
declare module Coveo {
	export const JQuery: any;

}
declare module Coveo {
	
	
	
	
	
	
	
	
	
	export interface ISimulateQueryData {
	    query?: IQuery;
	    queryBuilder?: QueryBuilder;
	    searchAsYouType?: boolean;
	    promise?: Promise<IQueryResults>;
	    error?: IEndpointError;
	    results?: IQueryResults;
	    queryCorrections?: IQueryCorrection[];
	    groupByResults?: IGroupByResult[];
	    callbackDuringQuery?: () => void;
	    callbackAfterNoResults?: () => void;
	    callbackAfterQuery?: () => void;
	    doNotFlushDefer?: boolean;
	    deferSuccess?: boolean;
	    cancel?: boolean;
	}
	export class Simulate {
	    static isPhantomJs(): boolean;
	    static query(env: IMockEnvironment, options?: ISimulateQueryData): ISimulateQueryData;
	    static omnibox(env: IMockEnvironment, options?: any): IOmniboxData;
	    static breadcrumb(env: IMockEnvironment, options?: any): IBreadcrumbItem[];
	    static keyUp(element: HTMLElement, key: number, shiftKey?: boolean): void;
	    static addJQuery(): void;
	    static removeJQuery(): void;
	}

}
declare module Coveo {
	export function PromisesShimTest(): void;

}
declare module Coveo {
	export function ModelTest(): void;

}
declare module Coveo {
	export function QueryStateModelTest(): void;

}
declare module Coveo {
	
	
	export class NoopComponent extends Component {
	    static ID: string;
	    constructor(element: HTMLElement, options: any, bindings: IComponentBindings);
	}

}
declare module Coveo {
	export function EndpointCallerTest(): void;

}
declare module Coveo {
	export function SearchEndpointTest(): void;

}
declare module Coveo {
	export function CookieUtilsTest(): void;

}
declare module Coveo {
	export function DomTests(): void;

}
declare module Coveo {
	export function HighlightUtilsTest(): void;

}
declare module Coveo {
	export function L10NTest(): void;

}
declare module Coveo {
	export function AggregateTest(): void;

}
declare module Coveo {
	export function AnalyticsEndpointTest(): void;

}
declare module Coveo {
	export function AnalyticsSuggestionsTest(): void;

}
declare module Coveo {
	export function AnalyticsTest(): void;

}
declare module Coveo {
	export function AuthenticationProviderTest(): void;

}
declare module Coveo {
	export function BadgeTest(): void;

}
declare module Coveo {
	export function BreadcrumbTest(): void;

}
declare module Coveo {
	export function ChatterLikedByTest(): void;

}
declare module Coveo {
	export function ChatterPostAttachmentTest(): void;

}
declare module Coveo {
	export function ChatterPostedByTest(): void;

}
declare module Coveo {
	export function ComponentEventsTest(): void;

}
declare module Coveo {
	export function ComponentOptionsTest(): void;

}
declare module Coveo {
	export function ComponentTest(): void;

}
declare module Coveo {
	export function CurrentTabTest(): void;

}
declare module Coveo {
	export function DidYouMeanTest(): void;

}
declare module Coveo {
	export function ErrorReportTest(): void;

}
declare module Coveo {
	export function ExcerptTest(): void;

}
declare module Coveo {
	export function ExportToExcelTest(): void;

}
declare module Coveo {
	export function ExpressionBuilderTest(): void;

}
declare module Coveo {
	export function FacetHeaderTest(): void;

}
declare module Coveo {
	export function FacetSearchParametersTest(): void;

}
declare module Coveo {
	export function FacetSearchTest(): void;

}
declare module Coveo {
	export function FacetSettingsTest(): void;

}
declare module Coveo {
	export function FacetSliderTest(): void;

}
declare module Coveo {
	export function FacetTest(): void;

}
declare module Coveo {
	export function FieldSuggestionsTest(): void;

}
declare module Coveo {
	export function FieldTableTest(): void;

}
declare module Coveo {
	export function FieldValueTest(): void;

}
declare module Coveo {
	export function FoldingTest(): void;

}
declare module Coveo {
	export function FollowItemTest(): void;

}
declare module Coveo {
	export function HiddenQueryTest(): void;

}
declare module Coveo {
	export function HierarchicalFacetTest(): void;

}
declare module Coveo {
	export function IconTest(): void;

}
declare module Coveo {
	export function ImageResultListTest(): void;

}
declare module Coveo {
	export function InitializationTest(): void;

}
declare module Coveo {
	export function LiveAnalyticsClientTest(): void;

}
declare module Coveo {
	export function MatrixTest(): void;

}
declare module Coveo {
	export function OmniboxTest(): void;

}
declare module Coveo {
	export function PagerTest(): void;

}
declare module Coveo {
	export function PendingSearchAsYouTypeSearchEventTest(): void;

}
declare module Coveo {
	export function PreferencesPanelTest(): void;

}
declare module Coveo {
	export function QueryboxQueryParametersTest(): void;

}
declare module Coveo {
	export function QueryboxTest(): void;

}
declare module Coveo {
	export function QueryBuilderTest(): void;

}
declare module Coveo {
	export function QueryDurationTest(): void;

}
declare module Coveo {
	export function QuerySummaryTest(): void;

}
declare module Coveo {
	export function RecommendationAnalyticsClientTest(): void;

}
declare module Coveo {
	export function RecommendationQueryTest(): void;

}
declare module Coveo {
	export function RecommendationTest(): void;

}
declare module Coveo {
	export function ResultAttachmentsTest(): void;

}
declare module Coveo {
	export function ResultFoldingTest(): void;

}
declare module Coveo {
	export function ResultLinkTest(): void;

}
declare module Coveo {
	export function ResultListTest(): void;

}
declare module Coveo {
	export function ResultRatingTest(): void;

}
declare module Coveo {
	export function ResultsPreferencesTest(): void;

}
declare module Coveo {
	export function SearchAlertsMessageTest(): void;

}
declare module Coveo {
	export function SearchAlertsTest(): void;

}
declare module Coveo {
	export function SearchButtonTest(): void;

}
declare module Coveo {
	export function SearchInterfaceTest(): void;

}
declare module Coveo {
	export function SettingsTest(): void;

}
declare module Coveo {
	export function ShareQueryTest(): void;

}
declare module Coveo {
	export function SliderTest(): void;

}
declare module Coveo {
	export function SortCriteriaTest(): void;

}
declare module Coveo {
	export function SortTest(): void;

}
declare module Coveo {
	export function TabTest(): void;

}
declare module Coveo {
	export function TemplateLoaderTest(): void;

}
declare module Coveo {
	export function ThumbnailTest(): void;

}
declare module Coveo {
	export function TriggersTest(): void;

}
declare module Coveo {
	export function ValueElementRendererTest(): void;

}
declare module Coveo {
	export function ResultsPerPageTest(): void;

}
declare module Coveo {
	export function FacetValuesOrderTest(): void;

}
declare module Coveo {
}
