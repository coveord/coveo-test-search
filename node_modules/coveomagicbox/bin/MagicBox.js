var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/// <reference path="../Grammar.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Result = (function () {
            function Result(value, expression, input) {
                var _this = this;
                this.expression = expression;
                this.input = input;
                if (_.isString(value)) {
                    this.value = value;
                }
                else if (_.isArray(value)) {
                    this.subResults = value;
                    _.forEach(this.subResults, function (subResult) {
                        subResult.parent = _this;
                    });
                }
            }
            Result.prototype.isSuccess = function () {
                // if null is the value, this mean the expression could not parse this input
                return this.value != null || (this.subResults != null && _.all(this.subResults, function (subResult) { return subResult.isSuccess(); }));
            };
            /**
             * Return path to this result ([parent.parent, parent, this])
             */
            Result.prototype.path = function (until) {
                var path = this.parent != null && this.parent != until ? this.parent.path(until) : [];
                path.push(this);
                return path;
            };
            /**
             * Return the closest parent that match the condition (can be it-self). If match is a string, it will search for the result expresion id
             */
            Result.prototype.findParent = function (match) {
                var parent = this;
                var iterator = _.isString(match) ? function (result) { return match == result.expression.id; } : match;
                while (parent != null && !iterator(parent)) {
                    parent = parent.parent;
                }
                return parent;
            };
            /**
             * Return the first child that match the condition (can be it-self). If match is a string, it will search for the result expresion id
             */
            Result.prototype.find = function (match) {
                var iterator = _.isString(match) ? function (result) { return match == result.expression.id; } : match;
                if (iterator(this)) {
                    return this;
                }
                if (this.subResults) {
                    for (var i = 0; i < this.subResults.length; i++) {
                        var subResultFind = this.subResults[i].find(iterator);
                        if (subResultFind) {
                            return subResultFind;
                        }
                    }
                }
                return null;
            };
            /**
            * Return all children that match the condition (can be it-self). If match is a string, it will search for the result expresion id
            */
            Result.prototype.findAll = function (match) {
                var results = [];
                var iterator = _.isString(match) ? function (result) { return match == result.expression.id; } : match;
                if (iterator(this)) {
                    results.push(this);
                }
                if (this.subResults) {
                    results = _.reduce(this.subResults, function (results, subResult) { return results.concat(subResult.findAll(iterator)); }, results);
                }
                return results;
            };
            /**
             * Return the first child that match the condition (can be it-self). If match is a string, it will search for the result expresion id
             */
            Result.prototype.resultAt = function (index, match) {
                if (index < 0 || index > this.getLength()) {
                    return [];
                }
                if (match != null) {
                    if (_.isString(match)) {
                        if (match == this.expression.id) {
                            return [this];
                        }
                    }
                    else {
                        if (match(this)) {
                            return [this];
                        }
                    }
                }
                else {
                    var value = this.value == null && this.subResults == null ? this.input : this.value;
                    if (value != null) {
                        return [this];
                    }
                }
                if (this.subResults != null) {
                    var results = [];
                    for (var i = 0; i < this.subResults.length; i++) {
                        var subResult = this.subResults[i];
                        results = results.concat(subResult.resultAt(index, match));
                        index -= subResult.getLength();
                        if (index < 0) {
                            break;
                        }
                    }
                    return results;
                }
                return [];
            };
            /**
            * Return all fail result.
            */
            Result.prototype.getExpect = function () {
                if (this.value == null && this.subResults == null) {
                    return [this];
                }
                if (this.subResults != null) {
                    return _.reduce(this.subResults, function (expect, result) { return expect.concat(result.getExpect()); }, []);
                }
                return [];
            };
            /**
            * Return the best fail result (The farthest result who got parsed). We also remove duplicate and always return the simplest result of a kind
            */
            Result.prototype.getBestExpect = function () {
                var expects = this.getExpect();
                var groups = _.groupBy(expects, function (expect) { return expect.input; });
                var key = _.last(_.keys(groups).sort(function (a, b) {
                    return b.length - a.length;
                }));
                var bestResults = groups[key];
                var groups = _.groupBy(bestResults, function (expect) { return expect.expression.id; });
                return _.map(groups, function (bestResults) {
                    return _.chain(bestResults)
                        .map(function (result) {
                        return {
                            path: result.path().length,
                            result: result
                        };
                    })
                        .sortBy('path')
                        .pluck('result')
                        .first()
                        .value();
                });
            };
            Result.prototype.getHumanReadableExpect = function () {
                var expect = this.getBestExpect();
                var input = expect.length > 0 ? _.last(expect).input : '';
                return 'Expected ' +
                    _.map(expect, function (result) { return result.getHumanReadable(); }).join(' or ') +
                    ' but ' +
                    (input.length > 0 ? JSON.stringify(input[0]) : 'end of input') +
                    ' found.';
            };
            /**
             * Return a string that represent what is before this result
             */
            Result.prototype.before = function () {
                if (this.parent == null) {
                    return '';
                }
                var index = _.indexOf(this.parent.subResults, this);
                return this.parent.before() + _.chain(this.parent.subResults).first(index).map(function (subResult) { return subResult.toString(); }).join('').value();
            };
            /**
             * Return a string that represent what is after this result
             */
            Result.prototype.after = function () {
                if (this.parent == null) {
                    return '';
                }
                var index = _.indexOf(this.parent.subResults, this);
                return _.chain(this.parent.subResults).last(this.parent.subResults.length - index - 1).map(function (subResult) { return subResult.toString(); }).join('').value() + this.parent.after();
            };
            /**
             * Return the length of the result
             */
            Result.prototype.getLength = function () {
                if (this.value != null) {
                    return this.value.length;
                }
                if (this.subResults != null) {
                    return _.reduce(this.subResults, function (length, subResult) { return length + subResult.getLength(); }, 0);
                }
                return this.input.length;
            };
            Result.prototype.toHtmlElement = function () {
                var element = document.createElement('span');
                var id = this.expression != null ? this.expression.id : null;
                if (id != null) {
                    element.setAttribute("data-id", id);
                }
                element.setAttribute("data-success", this.isSuccess().toString());
                if (this.value != null) {
                    element.appendChild(document.createTextNode(this.value));
                    element.setAttribute("data-value", this.value);
                }
                else if (this.subResults != null) {
                    _.each(this.subResults, function (subResult) {
                        element.appendChild(subResult.toHtmlElement());
                    });
                }
                else {
                    element.appendChild(document.createTextNode(this.input));
                    element.setAttribute("data-input", this.input);
                    element.className = 'magic-box-error' + (this.input.length > 0 ? '' : ' magic-box-error-empty');
                }
                element['result'] = this;
                return element;
            };
            /**
             * Clean the result to have the most relevant result. If the result is successful just return a clone of it.
             */
            Result.prototype.clean = function (path) {
                if (path != null || !this.isSuccess()) {
                    path = path || _.last(this.getBestExpect()).path(this);
                    var next = _.first(path);
                    if (next != null) {
                        var nextIndex = _.indexOf(this.subResults, next);
                        var subResults = nextIndex == -1 ? [] : _.map(_.first(this.subResults, nextIndex), function (subResult) { return subResult.clean(); });
                        subResults.push(next.clean(_.rest(path)));
                        return new Result(subResults, this.expression, this.input);
                    }
                    else {
                        return new Result(null, this.expression, this.input);
                    }
                }
                if (this.value != null) {
                    return new Result(this.value, this.expression, this.input);
                }
                if (this.subResults != null) {
                    return new Result(_.map(this.subResults, function (subResult) { return subResult.clean(); }), this.expression, this.input);
                }
            };
            Result.prototype.clone = function () {
                if (this.value != null) {
                    return new Result(this.value, this.expression, this.input);
                }
                if (this.subResults != null) {
                    return new Result(_.map(this.subResults, function (subResult) { return subResult.clone(); }), this.expression, this.input);
                }
                return new Result(null, this.expression, this.input);
            };
            Result.prototype.toString = function () {
                if (this.value != null) {
                    return this.value;
                }
                if (this.subResults != null) {
                    return _.map(this.subResults, function (subresult) { return subresult.toString(); }).join('');
                }
                return this.input;
            };
            Result.prototype.getHumanReadable = function () {
                if (this.expression instanceof MagicBox.ExpressionConstant) {
                    return JSON.stringify(this.expression.value);
                }
                return this.expression.id;
            };
            return Result;
        }());
        MagicBox.Result = Result;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="../Grammar.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var EndOfInputResult = (function (_super) {
            __extends(EndOfInputResult, _super);
            function EndOfInputResult(result) {
                _super.call(this, [result], MagicBox.ExpressionEndOfInput, result.input);
                var endOfInput = new MagicBox.Result(null, MagicBox.ExpressionEndOfInput, result.input.substr(result.getLength()));
                endOfInput.parent = this;
                this.subResults.push(endOfInput);
            }
            return EndOfInputResult;
        }(MagicBox.Result));
        MagicBox.EndOfInputResult = EndOfInputResult;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="../Grammar.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var OptionResult = (function (_super) {
            __extends(OptionResult, _super);
            function OptionResult(result, expression, input, failAttempt) {
                var _this = this;
                _super.call(this, result != null ? [result] : null, expression, input);
                this.result = result;
                this.expression = expression;
                this.input = input;
                this.failAttempt = failAttempt;
                _.forEach(this.failAttempt, function (subResult) {
                    subResult.parent = _this;
                });
            }
            /**
            * Return all fail result.
            */
            OptionResult.prototype.getExpect = function () {
                var _this = this;
                var expect = [];
                if (this.result != null) {
                    expect = this.result.getExpect();
                }
                expect = _.reduce(this.failAttempt, function (expect, result) { return expect.concat(result.getExpect()); }, expect);
                if (expect.length > 0 && _.all(expect, function (result) { return result.input == _this.input; })) {
                    return [this];
                }
                return expect;
            };
            /**
             * Clean the result to have the most relevant result. If the result is successful just return a clone of it.
             */
            OptionResult.prototype.clean = function (path) {
                if (path != null || !this.isSuccess()) {
                    // Result will be a ref. We skip it for cleaner tree.
                    path = _.rest(path || _.last(this.getBestExpect()).path(this));
                    // next can be Result or one of the failAttempt. In both case we have only one child
                    var next = _.first(path);
                    if (next == null) {
                        return new MagicBox.Result(null, this.expression, this.input);
                    }
                    return new MagicBox.Result([next.clean(_.rest(path))], this.expression, this.input);
                }
                // Result will be a ref. We skip it for cleaner tree.
                return new MagicBox.Result(_.map(this.result.subResults, function (subResult) { return subResult.clean(); }), this.expression, this.input);
            };
            return OptionResult;
        }(MagicBox.Result));
        MagicBox.OptionResult = OptionResult;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="../Grammar.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var RefResult = (function (_super) {
            __extends(RefResult, _super);
            function RefResult(results, expression, input, lastResult) {
                _super.call(this, results, expression, input);
                this.results = results;
                this.expression = expression;
                this.input = input;
                if (_.last(results) != lastResult) {
                    this.failAttempt = lastResult;
                    if (this.failAttempt != null) {
                        this.failAttempt.parent = this;
                    }
                }
            }
            /**
            * Return all fail result.
            */
            RefResult.prototype.getExpect = function () {
                var expect = _super.prototype.getExpect.call(this);
                // add the failAttempt to the expect
                if (this.failAttempt != null) {
                    return expect.concat(this.failAttempt.getExpect());
                }
                return expect;
            };
            /**
             * Clean the result to have the most relevant result. If the result is successful just return a clone of it.
             */
            RefResult.prototype.clean = function (path) {
                // if there is no failAttempt, we will use the default clean
                if (this.failAttempt != null && (path != null || !this.isSuccess())) {
                    path = path || _.last(this.getBestExpect()).path(this);
                    var next = _.first(path);
                    // if the next is in the subResults, not the failAttempt, do the default clean;
                    if (next != null && next == this.failAttempt) {
                        var last = _.last(this.subResults);
                        // if the last is not successful, remove it because we want the failAttempt path
                        var subResults = _.map(last != null && last.isSuccess() ? this.subResults : _.initial(this.subResults), function (subResult) { return subResult.clean(); });
                        subResults.push(next.clean(_.rest(path)));
                        return new MagicBox.Result(subResults, this.expression, this.input);
                    }
                }
                return _super.prototype.clean.call(this, path);
            };
            return RefResult;
        }(MagicBox.Result));
        MagicBox.RefResult = RefResult;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="../Grammar.ts" />
/// <reference path="../Grammar.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var ExpressionConstant = (function () {
            function ExpressionConstant(value, id) {
                this.value = value;
                this.id = id;
            }
            ExpressionConstant.prototype.parse = function (input, end) {
                // the value must be at the start of the input
                var success = input.indexOf(this.value) == 0;
                var result = new MagicBox.Result(success ? this.value : null, this, input);
                // if is successful and we require the end but the length of parsed is
                // lower than the input length, return a EndOfInputExpected Result
                if (success && end && input.length > this.value.length) {
                    return new MagicBox.EndOfInputResult(result);
                }
                return result;
            };
            ExpressionConstant.prototype.toString = function () {
                return this.value;
            };
            return ExpressionConstant;
        }());
        MagicBox.ExpressionConstant = ExpressionConstant;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="../Grammar.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        MagicBox.ExpressionEndOfInput = {
            id: 'end of input',
            parse: null
        };
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="../Grammar.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var ExpressionFunction = (function () {
            function ExpressionFunction(func, id, grammar) {
                this.func = func;
                this.id = id;
                this.grammar = grammar;
            }
            ExpressionFunction.prototype.parse = function (input, end) {
                return this.func(input, end, this);
            };
            ExpressionFunction.prototype.toString = function () {
                return this.id;
            };
            return ExpressionFunction;
        }());
        MagicBox.ExpressionFunction = ExpressionFunction;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="../Grammar.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var ExpressionList = (function () {
            function ExpressionList(parts, id) {
                this.parts = parts;
                this.id = id;
                if (parts.length == 0) {
                    throw JSON.stringify(id) + ' should have at least 1 parts';
                }
            }
            ExpressionList.prototype.parse = function (input, end) {
                var subResults = [];
                var subResult;
                var subInput = input;
                for (var i = 0; i < this.parts.length; i++) {
                    var part = this.parts[i];
                    subResult = part.parse(subInput, end && i == this.parts.length - 1);
                    subResults.push(subResult);
                    // if the subResult do not succeed, stop the parsing
                    if (!subResult.isSuccess()) {
                        break;
                    }
                    else {
                        subInput = subInput.substr(subResult.getLength());
                    }
                }
                return new MagicBox.Result(subResults, this, input);
            };
            ExpressionList.prototype.toString = function () {
                return this.id;
            };
            return ExpressionList;
        }());
        MagicBox.ExpressionList = ExpressionList;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="../Grammar.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var ExpressionOptions = (function () {
            function ExpressionOptions(parts, id) {
                this.parts = parts;
                this.id = id;
            }
            ExpressionOptions.prototype.parse = function (input, end) {
                var failAttempt = [];
                for (var i = 0; i < this.parts.length; i++) {
                    var subResult = this.parts[i].parse(input, end);
                    if (subResult.isSuccess()) {
                        return new MagicBox.OptionResult(subResult, this, input, failAttempt);
                    }
                    failAttempt.push(subResult);
                }
                return new MagicBox.OptionResult(null, this, input, failAttempt);
            };
            ExpressionOptions.prototype.toString = function () {
                return this.id;
            };
            return ExpressionOptions;
        }());
        MagicBox.ExpressionOptions = ExpressionOptions;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="../Grammar.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var ExpressionRef = (function () {
            function ExpressionRef(ref, occurrence, id, grammar) {
                this.ref = ref;
                this.occurrence = occurrence;
                this.id = id;
                this.grammar = grammar;
            }
            ExpressionRef.prototype.parse = function (input, end) {
                var ref = this.grammar.getExpression(this.ref);
                if (ref == null) {
                    throw 'Expression not found:' + this.ref;
                }
                if (this.occurrence == '?' || this.occurrence == null) {
                    return this.parseOnce(input, end, ref);
                }
                else {
                    return this.parseMany(input, end, ref);
                }
                ;
            };
            ExpressionRef.prototype.parseOnce = function (input, end, ref) {
                var refResult = ref.parse(input, end);
                var success = refResult.isSuccess();
                if (!success && this.occurrence == '?') {
                    if (end) {
                        // if end was found
                        if (input.length == 0) {
                            return new MagicBox.RefResult([], this, input, refResult);
                        }
                        // if end was not found and all error expression are EndOfInput, reparse with end = false.
                        if (_.all(refResult.getBestExpect(), function (expect) { return expect.expression == MagicBox.ExpressionEndOfInput; })) {
                            return new MagicBox.RefResult([new MagicBox.Result(null, MagicBox.ExpressionEndOfInput, input)], this, input, refResult);
                        }
                        return refResult;
                    }
                    // the ref is not required and it do not need to end the input
                    return new MagicBox.RefResult([], this, input, null);
                }
                return new MagicBox.RefResult([refResult], this, input, success ? null : refResult);
            };
            ExpressionRef.prototype.parseMany = function (input, end, ref) {
                var subResults = [];
                var subResult;
                var subInput = input;
                var success;
                // try to parse until it do not match, do not manage the end yet
                do {
                    subResult = ref.parse(subInput, false);
                    success = subResult.isSuccess();
                    if (success) {
                        subResults.push(subResult);
                        subInput = subInput.substr(subResult.getLength());
                    }
                } while (success && subResult.input != subInput);
                // minimal occurance of a ref
                var requiredOccurance = _.isNumber(this.occurrence) ? this.occurrence : (this.occurrence == '+' ? 1 : 0);
                // if the minimal occurance is not reached add the fail result to the list
                if (subResults.length < requiredOccurance) {
                    subResults.push(subResult);
                }
                else if (end) {
                    // if there is at least one match, check if the last match is at the end
                    if (subResults.length > 0) {
                        var last = _.last(subResults);
                        subResult = ref.parse(last.input, true);
                        if (subResult.isSuccess()) {
                            // if successful, replace the last subResult by the one with end
                            subResults[subResults.length - 1] = subResult;
                        }
                        else {
                            // if not successful, we keep the last successful result and we add a endOfInputExpected Result after it
                            subResults.push(new MagicBox.Result(null, MagicBox.ExpressionEndOfInput, last.input.substr(last.getLength())));
                            // we parse back the last with the length of the successful Result (at the same place we put the endOfInputExpected) and put it in failAttempt
                            subResult = ref.parse(last.input.substr(last.getLength()), true);
                        }
                    }
                    else if (input.length != 0) {
                        // if there is no result at all and we are not at the end, return a endOfInputExpected Result
                        var endOfInput = new MagicBox.Result(null, MagicBox.ExpressionEndOfInput, input);
                        return new MagicBox.RefResult([endOfInput], this, input, subResult);
                    }
                }
                return new MagicBox.RefResult(subResults, this, input, subResult);
            };
            ExpressionRef.prototype.toString = function () {
                return this.id;
            };
            return ExpressionRef;
        }());
        MagicBox.ExpressionRef = ExpressionRef;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="../Grammar.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var ExpressionRegExp = (function () {
            function ExpressionRegExp(value, id, grammar) {
                this.value = value;
                this.id = id;
            }
            ExpressionRegExp.prototype.parse = function (input, end) {
                var groups = input.match(this.value);
                // if the RegExp do not match at the start, ignore it
                if (groups != null && groups.index != 0) {
                    groups = null;
                }
                var result = new MagicBox.Result(groups != null ? groups[0] : null, this, input);
                // if is successful and we require the end but the length of parsed is
                // lower than the input length, return a EndOfInputExpected Result
                if (result.isSuccess() && end && input.length > result.value.length) {
                    return new MagicBox.EndOfInputResult(result);
                }
                return result;
            };
            ExpressionRegExp.prototype.toString = function () {
                return this.id;
            };
            return ExpressionRegExp;
        }());
        MagicBox.ExpressionRegExp = ExpressionRegExp;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="MagicBox.ts" />
/// <reference path="Result/Result.ts" />
/// <reference path="Result/EndOfInputResult.ts" />
/// <reference path="Result/OptionResult.ts" />
/// <reference path="Result/RefResult.ts" />
/// <reference path="Expression/Expression.ts" />
/// <reference path="Expression/ExpressionConstant.ts" />
/// <reference path="Expression/ExpressionEndOfInput.ts" />
/// <reference path="Expression/ExpressionFunction.ts" />
/// <reference path="Expression/ExpressionList.ts" />
/// <reference path="Expression/ExpressionOptions.ts" />
/// <reference path="Expression/ExpressionRef.ts" />
/// <reference path="Expression/ExpressionRegExp.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Grammar = (function () {
            function Grammar(start, expressions) {
                if (expressions === void 0) { expressions = {}; }
                this.expressions = {};
                this.start = new MagicBox.ExpressionRef(start, null, 'start', this);
                this.addExpressions(expressions);
            }
            Grammar.prototype.addExpressions = function (expressions) {
                var _this = this;
                _.each(expressions, function (basicExpression, id) {
                    _this.addExpression(id, basicExpression);
                });
            };
            Grammar.prototype.addExpression = function (id, basicExpression) {
                if (id in this.expressions) {
                    throw 'Grammar already contain the id:' + id;
                }
                this.expressions[id] = Grammar.buildExpression(basicExpression, id, this);
            };
            Grammar.prototype.getExpression = function (id) {
                return this.expressions[id];
            };
            Grammar.prototype.parse = function (value) {
                return this.start.parse(value, true);
            };
            Grammar.buildExpression = function (value, id, grammar) {
                var type = typeof value;
                if (type == 'undefined') {
                    throw 'Invalid Expression: ' + value;
                }
                if (_.isString(value)) {
                    return this.buildStringExpression(value, id, grammar);
                }
                if (_.isArray(value)) {
                    return new MagicBox.ExpressionOptions(_.map(value, function (v, i) { return new MagicBox.ExpressionRef(v, null, id + '_' + i, grammar); }), id);
                }
                if (_.isRegExp(value)) {
                    return new MagicBox.ExpressionRegExp(value, id, grammar);
                }
                if (_.isFunction(value)) {
                    return new MagicBox.ExpressionFunction(value, id, grammar);
                }
                throw 'Invalid Expression: ' + value;
            };
            Grammar.buildStringExpression = function (value, id, grammar) {
                var matchs = Grammar.stringMatch(value, Grammar.spliter);
                var expressions = _.map(matchs, function (match, i) {
                    if (match[1]) {
                        var ref = match[1];
                        var occurrence = match[3] ? Number(match[3]) : match[2] || null;
                        return new MagicBox.ExpressionRef(ref, occurrence, id + '_' + i, grammar);
                    }
                    else {
                        return new MagicBox.ExpressionConstant(match[4], id + '_' + i);
                    }
                });
                if (expressions.length == 1) {
                    var expression = expressions[0];
                    expression.id = id;
                    return expression;
                }
                else {
                    return new MagicBox.ExpressionList(expressions, id);
                }
            };
            Grammar.stringMatch = function (str, re) {
                var groups = [];
                var group;
                var cloneRegExp = new RegExp(re.source, 'g');
                while ((group = cloneRegExp.exec(str)) !== null) {
                    groups.push(group);
                }
                return groups;
            };
            Grammar.spliter = /\[(\w+)(\*|\+|\?|\{([1-9][0-9]*)\})?\]|(.[^\[]*)/;
            return Grammar;
        }());
        MagicBox.Grammar = Grammar;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="MagicBox.ts"/>
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var InputManager = (function () {
            function InputManager(element, onchange, magicBox) {
                this.element = element;
                this.onchange = onchange;
                this.magicBox = magicBox;
                this.hasFocus = false;
                this.justPressedTab = false;
                this.underlay = document.createElement('div');
                this.underlay.className = "magic-box-underlay";
                this.highlightContainer = document.createElement('span');
                this.highlightContainer.className = "magic-box-highlight-container";
                this.underlay.appendChild(this.highlightContainer);
                this.ghostTextContainer = document.createElement('span');
                this.ghostTextContainer.className = "magic-box-ghost-text";
                this.underlay.appendChild(this.ghostTextContainer);
                this.input = MagicBox.$$(element).find('input');
                if (!this.input) {
                    this.input = document.createElement('input');
                    element.appendChild(this.underlay);
                    element.appendChild(this.input);
                }
                else {
                    element.insertBefore(this.underlay, this.input);
                }
                this.input.spellcheck = false;
                this.input.setAttribute('form', 'coveo-dummy-form');
                this.input.setAttribute('autocomplete', 'off');
                this.setupHandler();
            }
            /**
            * Update the input with the result value
            */
            InputManager.prototype.updateInput = function () {
                if (this.input.value != this.result.input) {
                    this.input.value = this.result.input;
                    if (this.hasFocus) {
                        this.setCursor(this.getValue().length);
                    }
                }
            };
            /**
            * Update the highlight with the result value
            */
            InputManager.prototype.updateHighlight = function () {
                this.highlightContainer.innerHTML = '';
                this.highlightContainer.appendChild(this.result.toHtmlElement());
            };
            /**
            * Update the ghostText with the wordCompletion
            */
            InputManager.prototype.updateWordCompletion = function () {
                this.ghostTextContainer.innerHTML = '';
                if (this.wordCompletion != null) {
                    this.ghostTextContainer.appendChild(document.createTextNode(this.wordCompletion.substr(this.result.input.length)));
                }
            };
            InputManager.prototype.updateScroll = function (defer) {
                var _this = this;
                if (defer === void 0) { defer = true; }
                var callback = function () {
                    // this is the cheapest call we can do before update scroll
                    if (_this.underlay.clientWidth < _this.underlay.scrollWidth) {
                        _this.underlay.style.visibility = 'hidden';
                        _this.underlay.scrollLeft = _this.input.scrollLeft;
                        _this.underlay.scrollTop = _this.input.scrollTop;
                        _this.underlay.style.visibility = 'visible';
                    }
                    _this.updateScrollDefer = null;
                    // one day we will have to remove this
                    if (_this.hasFocus) {
                        _this.updateScroll();
                    }
                };
                // sometime we want it to be updated as soon as posible to have no flickering
                if (!defer) {
                    callback();
                }
                else if (this.updateScrollDefer == null) {
                    this.updateScrollDefer = MagicBox.requestAnimationFrame(callback);
                }
            };
            /**
            * Set the result and update visual if needed
            */
            InputManager.prototype.setResult = function (result, wordCompletion) {
                this.result = result;
                this.updateInput();
                this.updateHighlight();
                // reuse last wordCompletion for a better visual
                if (_.isUndefined(wordCompletion) && this.wordCompletion != null && this.wordCompletion.indexOf(this.result.input) == 0) {
                    this.updateWordCompletion();
                }
                else {
                    this.setWordCompletion(wordCompletion);
                }
                this.updateScroll();
            };
            /**
            * Set the word completion. will be ignore if the word completion do not start with the result input
            */
            InputManager.prototype.setWordCompletion = function (wordCompletion) {
                if (wordCompletion != null && wordCompletion.toLowerCase().indexOf(this.result.input.toLowerCase()) != 0) {
                    wordCompletion = null;
                }
                this.wordCompletion = wordCompletion;
                this.updateWordCompletion();
                this.updateScroll();
            };
            /**
            * Set cursor position
            */
            InputManager.prototype.setCursor = function (index) {
                this.input.focus();
                if (this.input.createTextRange) {
                    var range = this.input.createTextRange();
                    range.move("character", index);
                    range.select();
                }
                else if (this.input.selectionStart != null) {
                    this.input.focus();
                    this.input.setSelectionRange(index, index);
                }
            };
            InputManager.prototype.getCursor = function () {
                return this.input.selectionStart;
            };
            InputManager.prototype.setupHandler = function () {
                var _this = this;
                this.input.onblur = function () {
                    _this.hasFocus = false;
                    setTimeout(function () {
                        if (!_this.hasFocus) {
                            _this.onblur && _this.onblur();
                        }
                    }, 300);
                    _this.updateScroll();
                };
                this.input.onfocus = function () {
                    if (!_this.hasFocus) {
                        _this.hasFocus = true;
                        _this.updateScroll();
                        _this.onfocus && _this.onfocus();
                    }
                };
                this.input.onkeydown = function (e) {
                    _this.keydown(e);
                };
                this.input.onkeyup = function (e) {
                    _this.keyup(e);
                };
                this.input.onclick = function () {
                    _this.onchangecursor();
                };
                this.input.oncut = function () {
                    setTimeout(function () {
                        _this.onInputChange();
                    });
                };
                this.input.onpaste = function () {
                    setTimeout(function () {
                        _this.onInputChange();
                    });
                };
            };
            InputManager.prototype.focus = function () {
                var _this = this;
                this.hasFocus = true;
                // neet a timeout for IE8-9
                setTimeout(function () {
                    _this.input.focus();
                    _this.setCursor(_this.getValue().length);
                });
            };
            InputManager.prototype.blur = function () {
                if (this.hasFocus) {
                    this.input.blur();
                }
            };
            InputManager.prototype.keydown = function (e) {
                var _this = this;
                switch (e.keyCode || e.which) {
                    case 9:
                        if (!this.justPressedTab) {
                            if (this.magicBox.hasSuggestions()) {
                                e.preventDefault();
                            }
                        }
                        else {
                            this.blur();
                        }
                        this.justPressedTab = true;
                        break;
                    default:
                        e.stopPropagation();
                        this.justPressedTab = false;
                        if (this.onkeydown == null || this.onkeydown(e.keyCode || e.which)) {
                            MagicBox.requestAnimationFrame(function () {
                                _this.onInputChange();
                            });
                        }
                        else {
                            e.preventDefault();
                        }
                        break;
                }
            };
            InputManager.prototype.keyup = function (e) {
                switch (e.keyCode || e.which) {
                    // TAB
                    case 9:
                        this.tabPress();
                        break;
                    case 37: // Left
                    case 39:
                        this.onchangecursor();
                        break;
                    default:
                        if (this.onkeydown == null || this.onkeyup(e.keyCode || e.which)) {
                            this.onInputChange();
                        }
                        else {
                            e.preventDefault();
                        }
                        break;
                }
            };
            InputManager.prototype.tabPress = function () {
                if (this.wordCompletion != null) {
                    this.input.value = this.wordCompletion;
                }
                this.ontabpress && this.ontabpress();
                this.magicBox.showSuggestion();
            };
            InputManager.prototype.onInputChange = function () {
                if (this.result.input != this.input.value) {
                    this.onchange(this.input.value, false);
                }
            };
            InputManager.prototype.getValue = function () {
                return this.input.value;
            };
            InputManager.prototype.getWordCompletion = function () {
                return this.wordCompletion;
            };
            return InputManager;
        }());
        MagicBox.InputManager = InputManager;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="MagicBox.ts"/>
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var SuggestionsManager = (function () {
            function SuggestionsManager(element, options) {
                var _this = this;
                this.element = element;
                this.options = _.defaults(options, {
                    selectableClass: 'magic-box-suggestion',
                    selectedClass: 'magic-box-selected'
                });
                // Put in a sane default, so as to not reject every suggestions if not set on initialization
                if (this.options.timeout == undefined) {
                    this.options.timeout = 500;
                }
                this.hasSuggestions = false;
                MagicBox.$$(this.element).on('mouseover', function (e) {
                    _this.handleMouseOver(e);
                });
                MagicBox.$$(this.element).on('mouseout', function (e) {
                    _this.handleMouseOut(e);
                });
            }
            SuggestionsManager.prototype.handleMouseOver = function (e) {
                var target = MagicBox.$$(e.target);
                var parents = target.parents(this.options.selectableClass);
                if (target.hasClass(this.options.selectableClass)) {
                    this.addSelectedClass(target.el);
                }
                else if (parents.length > 0 && this.element.contains(parents[0])) {
                    this.addSelectedClass(parents[0]);
                }
            };
            SuggestionsManager.prototype.handleMouseOut = function (e) {
                var target = MagicBox.$$(e.target);
                var targetParents = target.parents(this.options.selectableClass);
                //e.relatedTarget is not available if moving off the browser window
                if (e.relatedTarget) {
                    var relatedTargetParents = MagicBox.$$(e.relatedTarget).parents(this.options.selectableClass);
                    if (target.hasClass(this.options.selectedClass) && !MagicBox.$$(e.relatedTarget).hasClass(this.options.selectableClass)) {
                        target.removeClass(this.options.selectedClass);
                    }
                    else if (relatedTargetParents.length == 0 && targetParents.length > 0) {
                        MagicBox.$$(targetParents[0]).removeClass(this.options.selectedClass);
                    }
                }
                else {
                    if (target.hasClass(this.options.selectedClass)) {
                        target.removeClass(this.options.selectedClass);
                    }
                    else if (targetParents.length > 0) {
                        MagicBox.$$(targetParents[0]).removeClass(this.options.selectedClass);
                    }
                }
            };
            SuggestionsManager.prototype.moveDown = function () {
                var selected = this.element.getElementsByClassName(this.options.selectedClass).item(0);
                var selectables = this.element.getElementsByClassName(this.options.selectableClass);
                var index = -1;
                if (selected != null) {
                    MagicBox.$$(selected).removeClass(this.options.selectedClass);
                    for (var i = 0; i < selectables.length; i++) {
                        if (selected == selectables.item(i)) {
                            index = i;
                            break;
                        }
                    }
                    index = index == -1 ? 0 : index + 1;
                }
                else {
                    index = 0;
                }
                selected = selectables.item(index);
                if (selected != null)
                    MagicBox.$$(selected).addClass(this.options.selectedClass);
                return this.returnMoved(selected);
            };
            SuggestionsManager.prototype.moveUp = function () {
                var selected = this.element.getElementsByClassName(this.options.selectedClass).item(0);
                var selectables = this.element.getElementsByClassName(this.options.selectableClass);
                var index = -1;
                if (selected != null) {
                    MagicBox.$$(selected).removeClass(this.options.selectedClass);
                    for (var i = 0; i < selectables.length; i++) {
                        if (selected == selectables.item(i)) {
                            index = i;
                            break;
                        }
                    }
                    index = index == -1 ? selectables.length - 1 : index - 1;
                }
                else {
                    index = selectables.length - 1;
                }
                selected = selectables.item(index);
                if (selected != null)
                    MagicBox.$$(selected).addClass(this.options.selectedClass);
                return this.returnMoved(selected);
            };
            SuggestionsManager.prototype.select = function () {
                var selected = this.element.getElementsByClassName(this.options.selectedClass).item(0);
                if (selected != null) {
                    MagicBox.$$(selected).trigger("keyboardSelect");
                }
                return selected;
            };
            SuggestionsManager.prototype.mergeSuggestions = function (suggestions, callback) {
                var _this = this;
                var results = [];
                var timeout;
                // clean empty / null values in the array of suggestions
                suggestions = _.compact(suggestions);
                var promise = this.pendingSuggestion = new Promise(function (resolve, reject) {
                    // Concat all promises results together in one flat array.
                    // If one promise take too long to resolve, simply skip it
                    _.each(suggestions, function (sugg) {
                        var shouldRejectPart = false;
                        setTimeout(function () {
                            shouldRejectPart = true;
                        }, _this.options.timeout);
                        sugg.then(function (item) {
                            if (!shouldRejectPart && item) {
                                results = results.concat(item);
                            }
                        });
                    });
                    // Resolve the promise when one of those conditions is met first :
                    // - All suggestions resolved
                    // - Timeout is reached before all promises have processed -> resolve with what we have so far
                    // - No suggestions given (length 0 or undefined)
                    var onResolve = function () {
                        if (timeout) {
                            clearTimeout(timeout);
                        }
                        if (results.length == 0) {
                            resolve([]);
                        }
                        else if (promise == _this.pendingSuggestion || (_this.pendingSuggestion == null)) {
                            resolve(results.sort(function (a, b) { return b.index - a.index; }));
                        }
                        else {
                            reject('new request queued');
                        }
                    };
                    if (suggestions.length == 0) {
                        onResolve();
                    }
                    if (suggestions == undefined) {
                        onResolve();
                    }
                    timeout = setTimeout(function () {
                        onResolve();
                    }, _this.options.timeout);
                    Promise.all(suggestions)
                        .then(function () { return onResolve(); });
                });
                promise.then(function (suggestions) {
                    if (callback) {
                        callback(suggestions);
                    }
                    _this.updateSuggestions(suggestions);
                    return suggestions;
                }).catch(function () {
                    return null;
                });
            };
            SuggestionsManager.prototype.updateSuggestions = function (suggestions) {
                var _this = this;
                this.element.innerHTML = '';
                this.element.className = "magic-box-suggestions";
                _.each(suggestions, function (suggestion) {
                    var dom = suggestion.dom;
                    if (!dom) {
                        dom = document.createElement('div');
                        dom.className = 'magic-box-suggestion';
                        if (suggestion.html != null) {
                            dom.innerHTML = suggestion.html;
                        }
                        else if (suggestion.text != null) {
                            dom.appendChild(document.createTextNode(suggestion.text));
                        }
                        else if (suggestion.separator != null) {
                            dom.className = 'magic-box-suggestion-seperator';
                            var suggestionLabel = document.createElement('div');
                            suggestionLabel.className = 'magic-box-suggestion-seperator-label';
                            suggestionLabel.appendChild(document.createTextNode(suggestion.separator));
                            dom.appendChild(suggestionLabel);
                        }
                        MagicBox.$$(dom).on('click', function () {
                            suggestion.onSelect();
                        });
                        MagicBox.$$(dom).on('keyboardSelect', function () {
                            suggestion.onSelect();
                        });
                        MagicBox.$$(dom).addClass(_this.options.selectableClass);
                    }
                    else {
                        // this need to be done if the selection is in cache and the dom is set in the suggestion
                        MagicBox.$$(dom).removeClass(_this.options.selectedClass);
                        var found = MagicBox.$$(dom).find('.' + _this.options.selectableClass);
                        MagicBox.$$(found).removeClass(_this.options.selectedClass);
                    }
                    dom['suggestion'] = suggestion;
                    _this.element.appendChild(dom);
                });
                if (suggestions.length > 0) {
                    MagicBox.$$(this.element).addClass('magic-box-hasSuggestion');
                    this.hasSuggestions = true;
                }
                else {
                    MagicBox.$$(this.element).removeClass('magic-box-hasSuggestion');
                    this.hasSuggestions = false;
                }
            };
            SuggestionsManager.prototype.returnMoved = function (selected) {
                if (selected != null) {
                    if (selected['suggestion']) {
                        return selected['suggestion'];
                    }
                    if (selected['no-text-suggestion']) {
                        return null;
                    }
                    if (selected instanceof HTMLElement) {
                        return {
                            text: MagicBox.$$(selected).text()
                        };
                    }
                }
                return null;
            };
            SuggestionsManager.prototype.addSelectedClass = function (suggestion) {
                var selected = this.element.getElementsByClassName(this.options.selectedClass);
                for (var i = 0; i < selected.length; i++) {
                    var elem = selected.item(i);
                    MagicBox.$$(elem).removeClass(this.options.selectedClass);
                }
                MagicBox.$$(suggestion).addClass(this.options.selectedClass);
            };
            return SuggestionsManager;
        }());
        MagicBox.SuggestionsManager = SuggestionsManager;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Utils;
        (function (Utils) {
            function escapeRegExp(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            }
            var escapeText = function (classname, text) {
                return "<span class=\"" + classname + "\">" + _.escape(text) + "</span>";
            };
            function highlightText(text, highligth, ignoreCase, matchClass, doNotMatchClass) {
                if (ignoreCase === void 0) { ignoreCase = false; }
                if (matchClass === void 0) { matchClass = 'magic-box-hightlight'; }
                if (doNotMatchClass === void 0) { doNotMatchClass = ''; }
                if (highligth.length == 0) {
                    return text;
                }
                var escaped = escapeRegExp(highligth);
                var stringRegex = '(' + escaped + ')|(.*?(?=' + escaped + ')|.+)';
                var regex = new RegExp(stringRegex, ignoreCase ? 'gi' : 'g');
                return text.replace(regex, function (text, match, notmatch) { return escapeText(match != null ? matchClass : doNotMatchClass, text); });
            }
            Utils.highlightText = highlightText;
            /**
             * This is essentially an helper class for dom manipulation.<br/>
             * This is intended to provide some basic functionality normally offered by jQuery.<br/>
             * To minimize the multiple jQuery conflict we have while integrating in various system, we implemented the very small subset that the framework need.<br/>
             * See {@link $$}, which is a function that wraps this class constructor, for less verbose code.
             */
            var Dom = (function () {
                /**
                 * Create a new Dom object with the given HTMLElement
                 * @param el The HTMLElement to wrap in a Dom object
                 */
                function Dom(el) {
                    this.el = el;
                }
                /**
                 * Get or set the text content of the HTMLElement.<br/>
                 * @param txt Optional. If given, this will set the text content of the element. If not, will return the text content.
                 * @returns {string}
                 */
                Dom.prototype.text = function (txt) {
                    if (txt) {
                        if (this.el.innerText != undefined) {
                            this.el.innerText = txt;
                        }
                        else if (this.el.textContent != undefined) {
                            this.el.textContent = txt;
                        }
                    }
                    else {
                        return this.el.innerText || this.el.textContent;
                    }
                };
                /**
                 * Performant way to transform a NodeList to an array of HTMLElement, for manipulation<br/>
                 * http://jsperf.com/nodelist-to-array/72
                 * @param nodeList a {NodeList} to convert to an array
                 * @returns {HTMLElement[]}
                 */
                Dom.prototype.nodeListToArray = function (nodeList) {
                    var i = nodeList.length;
                    var arr = new Array(i);
                    while (i--) {
                        arr[i] = nodeList.item(i);
                    }
                    return arr;
                };
                /**
                 * Empty (remove all child) from the element;
                 */
                Dom.prototype.empty = function () {
                    while (this.el.firstChild) {
                        this.el.removeChild(this.el.firstChild);
                    }
                };
                /**
                 * Show the element;
                 */
                Dom.prototype.show = function () {
                    this.el.style.display = 'visible';
                };
                /**
                 * Hide the element;
                 */
                Dom.prototype.hide = function () {
                    this.el.style.display = 'none';
                };
                /**
                 * Toggle the element visibility.<br/>
                 * Optional visible parameter, if specified will set the element visibility
                 * @param visible Optional parameter to display or hide the element
                 */
                Dom.prototype.toggle = function (visible) {
                    if (visible === undefined) {
                        if (this.el.style.display == 'visible') {
                            this.hide();
                        }
                        else {
                            this.show();
                        }
                    }
                    else {
                        if (visible) {
                            this.show();
                        }
                        else {
                            this.hide();
                        }
                    }
                };
                /**
                 * Find a child element, given a CSS selector<br/>
                 * @param selector A CSS selector, can be a .className or #id
                 * @returns {HTMLElement}
                 */
                Dom.prototype.find = function (selector) {
                    return this.el.querySelector(selector);
                };
                /**
                 * Check if the element match the selector.<br/>
                 * The selector can be a class, an id or a tag.<br/>
                 * Eg : .is('.foo') or .is('#foo') or .is('div').
                 */
                Dom.prototype.is = function (selector) {
                    if (this.el.tagName.toLowerCase() == selector.toLowerCase()) {
                        return true;
                    }
                    if (selector[0] == '.') {
                        if (this.hasClass(selector.substr(1))) {
                            return true;
                        }
                    }
                    if (selector[0] == '#') {
                        if (this.el.getAttribute('id') == selector.substr(1)) {
                            return true;
                        }
                    }
                    return false;
                };
                /**
                 * Get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.<br/>
                 * Stops at the body of the document
                 * @param selector A CSS selector, a classname
                 */
                Dom.prototype.closest = function (selector) {
                    var current = this.el, found = false;
                    while (!found) {
                        if (MagicBox.$$(current).hasClass(selector)) {
                            found = true;
                        }
                        if (current.tagName.toLowerCase() == 'body') {
                            break;
                        }
                        if (current.parentElement == null) {
                            break;
                        }
                        if (!found) {
                            current = current.parentElement;
                        }
                    }
                    if (found) {
                        return current;
                    }
                    return undefined;
                };
                /**
                 * Get the first element that matches the classname by testing the element itself and traversing up through its ancestors in the DOM tree.
                 *
                 * Stops at the body of the document
                 * @returns {any}
                 */
                Dom.prototype.parent = function (className) {
                    if (this.el.parentElement == undefined) {
                        return undefined;
                    }
                    return this.traverseAncestorForClass(this.el.parentElement, className);
                };
                /**
                 *  Get all the ancestors of the current element that match the given className
                 *
                 *  Return an empty array if none found.
                 * @param className
                 * @returns {HTMLElement[]}
                 */
                Dom.prototype.parents = function (className) {
                    var parentsFound = [];
                    var parentFound = this.parent(className);
                    while (parentFound) {
                        parentsFound.push(parentFound);
                        parentFound = new Dom(parentFound).parent(className);
                    }
                    return parentsFound;
                };
                /**
                 * Find all child that match the given CSS selector<br/>
                 * @param selector A CSS selector, can be a .className
                 * @returns {HTMLElement[]}
                 */
                Dom.prototype.findAll = function (selector) {
                    return this.nodeListToArray(this.el.querySelectorAll(selector));
                };
                /**
                 * Find the child elements using a className
                 * @param className Class of the childs elements to find
                 * @returns {HTMLElement[]}
                 */
                Dom.prototype.findClass = function (className) {
                    if ('getElementsByClassName' in this.el) {
                        return this.nodeListToArray(this.el.getElementsByClassName(className));
                    }
                    // For ie 8
                    return this.nodeListToArray(this.el.querySelectorAll('.' + className));
                };
                /**
                 * Find an element using an ID
                 * @param id ID of the element to find
                 * @returns {HTMLElement}
                 */
                Dom.prototype.findId = function (id) {
                    return document.getElementById(id);
                };
                /**
                 * Add a class to the element. Takes care of not adding the same class if the element already has it.
                 * @param className Classname to add to the element
                 */
                Dom.prototype.addClass = function (className) {
                    if (!this.hasClass(className)) {
                        if (this.el.className) {
                            this.el.className += ' ' + className;
                        }
                        else {
                            this.el.className = className;
                        }
                    }
                };
                /**
                 * Remove the class on the element. Works even if the element does not possess the class.
                 * @param className Classname to remove on the the element
                 */
                Dom.prototype.removeClass = function (className) {
                    this.el.className = this.el.className.replace(new RegExp("(^|\\s)" + className + "(\\s|\\b)", 'g'), '$1');
                };
                Dom.prototype.toggleClass = function (className, toggle) {
                    if (toggle) {
                        this.addClass(className);
                    }
                    else {
                        this.removeClass(className);
                    }
                };
                /**
                 * Return an array with all the classname on the element. Empty array if the element has not classname
                 * @returns {any|Array}
                 */
                Dom.prototype.getClass = function () {
                    return this.el.className.match(Dom.CLASS_NAME_REGEX) || [];
                };
                /**
                 * Check if the element has the given class name
                 * @param className Classname to verify
                 * @returns {boolean}
                 */
                Dom.prototype.hasClass = function (className) {
                    return _.contains(this.getClass(), className);
                };
                /**
                 * Detach the element from the DOM.
                 */
                Dom.prototype.detach = function () {
                    this.el.parentElement && this.el.parentElement.removeChild(this.el);
                };
                Dom.prototype.on = function (type, eventHandle) {
                    var _this = this;
                    if (_.isArray(type)) {
                        _.each(type, function (t) {
                            _this.on(t, eventHandle);
                        });
                    }
                    else {
                        var jq = this.getJQuery();
                        if (jq) {
                            jq(this.el).on(type, eventHandle);
                        }
                        else if (this.el.addEventListener) {
                            var fn = function (e) {
                                eventHandle(e, e.detail);
                            };
                            Dom.handlers.push({
                                eventHandle: eventHandle,
                                fn: fn
                            });
                            this.el.addEventListener(type, fn, false);
                        }
                        else if (this.el['on']) {
                            this.el['on']("on" + type, eventHandle);
                        }
                    }
                };
                Dom.prototype.one = function (type, eventHandle) {
                    var _this = this;
                    if (_.isArray(type)) {
                        _.each(type, function (t) {
                            _this.one(t, eventHandle);
                        });
                    }
                    else {
                        var once = function (e) {
                            _this.off(type, once);
                            return eventHandle(e);
                        };
                        this.on(type, once);
                    }
                };
                Dom.prototype.off = function (type, eventHandle) {
                    var _this = this;
                    if (_.isArray(type)) {
                        _.each(type, function (t) {
                            _this.off(t, eventHandle);
                        });
                    }
                    else {
                        var jq = this.getJQuery();
                        if (jq) {
                            jq(this.el).off(type, eventHandle);
                        }
                        else if (this.el.removeEventListener) {
                            var idx = 0;
                            var found = _.find(Dom.handlers, function (handlerObj, i) {
                                if (handlerObj.eventHandle == eventHandle) {
                                    idx = i;
                                    return true;
                                }
                            });
                            if (found) {
                                this.el.removeEventListener(type, found.fn, false);
                                Dom.handlers.splice(idx, 1);
                            }
                        }
                        else if (this.el['off']) {
                            this.el['off']("on" + type, eventHandle);
                        }
                    }
                };
                /**
                 * Trigger an event on the element.
                 * @param type The event type to trigger
                 * @param data
                 */
                Dom.prototype.trigger = function (type, data) {
                    var jq = this.getJQuery();
                    if (jq) {
                        jq(this.el).trigger(type, data);
                    }
                    else if (CustomEvent !== undefined) {
                        var event = new CustomEvent(type, { detail: data, bubbles: true });
                        this.el.dispatchEvent(event);
                    }
                    else {
                    }
                };
                /**
                 * Check if the element is "empty" (has no innerHTML content). Whitespace is considered empty</br>
                 * @returns {boolean}
                 */
                Dom.prototype.isEmpty = function () {
                    return Dom.ONLY_WHITE_SPACE_REGEX.test(this.el.innerHTML);
                };
                /**
                 * Check if the element is a descendant of parent
                 * @param other
                 */
                Dom.prototype.isDescendant = function (parent) {
                    var node = this.el.parentNode;
                    while (node != null) {
                        if (node == parent) {
                            return true;
                        }
                        node = node.parentNode;
                    }
                    return false;
                };
                Dom.prototype.traverseAncestorForClass = function (current, className) {
                    if (current === void 0) { current = this.el; }
                    if (className.indexOf('.') == 0) {
                        className = className.substr(1);
                    }
                    var found = false;
                    while (!found) {
                        if (MagicBox.$$(current).hasClass(className)) {
                            found = true;
                        }
                        if (current.tagName.toLowerCase() == 'body') {
                            break;
                        }
                        if (current.parentElement == null) {
                            break;
                        }
                        if (!found) {
                            current = current.parentElement;
                        }
                    }
                    if (found) {
                        return current;
                    }
                    return undefined;
                };
                Dom.prototype.getJQuery = function () {
                    if (window['jQuery'] != undefined) {
                        return window['jQuery'];
                    }
                    return false;
                };
                Dom.CLASS_NAME_REGEX = /-?[_a-zA-Z]+[_a-zA-Z0-9-]*/g;
                Dom.ONLY_WHITE_SPACE_REGEX = /^\s*$/;
                Dom.handlers = [];
                return Dom;
            }());
            Utils.Dom = Dom;
        })(Utils = MagicBox.Utils || (MagicBox.Utils = {}));
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        /**
         * Convenience wrapper for the {@link Dom} class. Used to do $$(element)
         * @param el HTMLElement to wrap
         */
        MagicBox.$$ = function (el) {
            if (window['Coveo'] && window['Coveo']['$$']) {
                return window['Coveo']['$$'](el);
            }
            else {
                return new MagicBox.Utils.Dom(el);
            }
        };
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="Grammars.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Grammars;
        (function (Grammars) {
            function loadSubGrammar(expressions, basicExpressions, grammars, subGrammar) {
                _.each(subGrammar.expressions, function (expression) {
                    if (!_.contains(expressions, expression)) {
                        expressions.push(expression);
                    }
                });
                _.each(subGrammar.basicExpressions, function (expression) {
                    if (!_.contains(basicExpressions, expression)) {
                        basicExpressions.push(expression);
                    }
                });
                _.each(subGrammar.grammars, function (expressionDef, id) {
                    if (!(id in grammars)) {
                        grammars[id] = expressionDef;
                    }
                    else {
                        if (_.isArray(grammars[id]) && _.isArray(expressionDef)) {
                            _.each(expressionDef, function (value) {
                                grammars[id].push(value);
                            });
                        }
                        else {
                            _.each(expressionDef, function (value) {
                                grammars[id].push(value);
                            });
                            throw 'Can not merge ' + id + '(' + new String(expressionDef) + ' => ' + new String(grammars[id]) + ')';
                        }
                    }
                });
            }
            function Expressions() {
                var subGrammars = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    subGrammars[_i - 0] = arguments[_i];
                }
                var expressions = [];
                var BasicExpression = [];
                var grammars = {
                    Start: ['Expressions', 'Empty'],
                    Expressions: '[OptionalSpaces][Expression][ExpressionsList*][OptionalSpaces]',
                    ExpressionsList: '[Spaces][Expression]',
                    Expression: expressions,
                    BasicExpression: BasicExpression,
                    OptionalSpaces: / */,
                    Spaces: / +/,
                    Empty: /(?!.)/
                };
                for (var i = 0; i < subGrammars.length; i++) {
                    loadSubGrammar(expressions, BasicExpression, grammars, subGrammars[i]);
                    _.each(subGrammars[i].include, function (subGrammar) {
                        if (!_.contains(subGrammars, subGrammar)) {
                            subGrammars.push(subGrammar);
                        }
                    });
                }
                expressions.push('BasicExpression');
                return {
                    start: 'Start',
                    expressions: grammars
                };
            }
            Grammars.Expressions = Expressions;
            function ExpressionsGrammar() {
                var subGrammars = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    subGrammars[_i - 0] = arguments[_i];
                }
                var grammar = Expressions.apply(this, subGrammars);
                return new MagicBox.Grammar(grammar.start, grammar.expressions);
            }
            Grammars.ExpressionsGrammar = ExpressionsGrammar;
        })(Grammars = MagicBox.Grammars || (MagicBox.Grammars = {}));
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="Grammars.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Grammars;
        (function (Grammars) {
            Grammars.notWordStart = ' ()[],$@\'"';
            Grammars.notInWord = ' ()[],:';
            Grammars.Basic = {
                basicExpressions: ['Word', 'DoubleQuoted'],
                grammars: {
                    DoubleQuoted: '"[NotDoubleQuote]"',
                    NotDoubleQuote: /[^"]*/,
                    SingleQuoted: "'[NotSingleQuote]'",
                    NotSingleQuote: /[^']*/,
                    Number: /[0-9]+/,
                    Word: function (input, end, expression) {
                        var regex = new RegExp('[^' + Grammars.notWordStart.replace(/(.)/g, '\\$1') + '][^' + Grammars.notInWord.replace(/(.)/g, '\\$1') + ']*');
                        var groups = input.match(regex);
                        if (groups != null && groups.index != 0) {
                            groups = null;
                        }
                        var result = new MagicBox.Result(groups != null ? groups[0] : null, expression, input);
                        if (result.isSuccess() && end && input.length > result.value.length) {
                            return new MagicBox.EndOfInputResult(result);
                        }
                        return result;
                    }
                }
            };
        })(Grammars = MagicBox.Grammars || (MagicBox.Grammars = {}));
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="Grammars.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Grammars;
        (function (Grammars) {
            Grammars.SubExpression = {
                basicExpressions: ['SubExpression'],
                grammars: {
                    SubExpression: '([Expressions])'
                }
            };
        })(Grammars = MagicBox.Grammars || (MagicBox.Grammars = {}));
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="Grammars.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Grammars;
        (function (Grammars) {
            Grammars.Date = {
                grammars: {
                    Date: '[DateYear]/[DateMonth]/[DateDay]',
                    DateYear: /([0-9]{4})/,
                    DateMonth: /(1[0-2]|0?[1-9])/,
                    DateDay: /([1-2][0-9]|3[0-1]|0?[1-9])/,
                    DateRange: '[Date][Spaces?]..[Spaces?][Date]',
                    DateRelative: ['DateRelativeNegative', 'DateRelativeTerm'],
                    DateRelativeTerm: /now|today|yesterday/,
                    DateRelativeNegative: '[DateRelativeTerm][DateRelativeNegativeRef]',
                    DateRelativeNegativeRef: /([\-\+][0-9]+(s|m|h|d|mo|y))/
                },
                include: [Grammars.Basic]
            };
        })(Grammars = MagicBox.Grammars || (MagicBox.Grammars = {}));
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="Grammars.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Grammars;
        (function (Grammars) {
            Grammars.Field = {
                basicExpressions: ['FieldSimpleQuery', 'FieldQuery', 'Field'],
                grammars: {
                    FieldQuery: '[Field][OptionalSpaces][FieldQueryOperation]',
                    FieldQueryOperation: ['FieldQueryValue', 'FieldQueryNumeric'],
                    FieldQueryValue: '[FieldOperator][OptionalSpaces][FieldValue]',
                    FieldQueryNumeric: '[FieldOperatorNumeric][OptionalSpaces][FieldValueNumeric]',
                    FieldSimpleQuery: '[FieldName]:[OptionalSpaces][FieldValue]',
                    Field: '@[FieldName]',
                    FieldName: /[a-zA-Z][a-zA-Z0-9\.\_]*/,
                    FieldOperator: /==|=|<>/,
                    FieldOperatorNumeric: /<=|>=|<|>/,
                    FieldValue: ['DateRange', 'NumberRange', 'DateRelative', 'Date', 'Number', 'FieldValueList', 'FieldValueString'],
                    FieldValueNumeric: ['DateRelative', 'Date', 'Number'],
                    FieldValueString: ['DoubleQuoted', 'FieldValueNotQuoted'],
                    FieldValueList: '([FieldValueString][FieldValueStringList*])',
                    FieldValueStringList: '[FieldValueSeparator][FieldValueString]',
                    FieldValueSeparator: / *, */,
                    FieldValueNotQuoted: /[^ \(\),]+/,
                    NumberRange: '[Number][Spaces?]..[Spaces?][Number]'
                },
                include: [Grammars.Date, Grammars.Basic]
            };
        })(Grammars = MagicBox.Grammars || (MagicBox.Grammars = {}));
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="Grammars.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Grammars;
        (function (Grammars) {
            Grammars.QueryExtension = {
                basicExpressions: ['QueryExtension'],
                grammars: {
                    QueryExtension: '$[QueryExtensionName]([QueryExtensionArguments])',
                    QueryExtensionName: /\w+/,
                    QueryExtensionArguments: '[QueryExtensionArgumentList*][QueryExtensionArgument]',
                    QueryExtensionArgumentList: '[QueryExtensionArgument][Spaces?],[Spaces?]',
                    QueryExtensionArgument: '[QueryExtensionArgumentName]:[Spaces?][QueryExtensionArgumentValue]',
                    QueryExtensionArgumentName: /\w+/,
                    QueryExtensionArgumentValue: ["SingleQuoted", "Expressions"]
                },
                include: [Grammars.Basic]
            };
        })(Grammars = MagicBox.Grammars || (MagicBox.Grammars = {}));
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="Grammars.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Grammars;
        (function (Grammars) {
            Grammars.NestedQuery = {
                basicExpressions: ['NestedQuery'],
                grammars: {
                    NestedQuery: '[[NestedField][OptionalSpaces][Expressions]]',
                    NestedField: '[[Field]]',
                    FieldValue: ['NestedQuery']
                },
                include: [Grammars.Field]
            };
        })(Grammars = MagicBox.Grammars || (MagicBox.Grammars = {}));
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="Grammars.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Grammars;
        (function (Grammars) {
            Grammars.Complete = {
                include: [Grammars.NestedQuery, Grammars.QueryExtension, Grammars.SubExpression, Grammars.Field, Grammars.Basic]
            };
        })(Grammars = MagicBox.Grammars || (MagicBox.Grammars = {}));
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
/// <reference path="../MagicBox.ts" />
/// <reference path="Expressions.ts" />
/// <reference path="Basic.ts" />
/// <reference path="SubExpression.ts" />
/// <reference path="Date.ts" />
/// <reference path="Field.ts" />
/// <reference path="QueryExtension.ts" />
/// <reference path="NestedQuery.ts" />
/// <reference path="Complete.ts" />
/// <reference path="../bin/underscore.d.ts" />
/// <reference path="../bin/promise.d.ts" />
/// <reference path="./Grammar.ts" />
/// <reference path="./InputManager.ts"/>
/// <reference path="./SuggestionsManager.ts"/>
/// <reference path="./Utils.ts"/>
/// <reference path="./Grammars/Grammars.ts" />
var Coveo;
(function (Coveo) {
    var MagicBox;
    (function (MagicBox) {
        var Instance = (function () {
            function Instance(element, grammar, options) {
                var _this = this;
                if (options === void 0) { options = {}; }
                this.element = element;
                this.grammar = grammar;
                this.options = options;
                this.lastSuggestions = [];
                if (_.isUndefined(this.options.inline)) {
                    this.options.inline = false;
                }
                MagicBox.$$(element).addClass('magic-box');
                if (this.options.inline) {
                    MagicBox.$$(element).addClass('magic-box-inline');
                }
                this.result = this.grammar.parse('');
                this.displayedResult = this.result.clean();
                this.clearDom = document.createElement('div');
                this.clearDom.className = "magic-box-clear";
                var icon = document.createElement('div');
                icon.className = "magic-box-icon";
                this.clearDom.appendChild(icon);
                var inputContainer = MagicBox.$$(element).find('.magic-box-input');
                if (!inputContainer) {
                    inputContainer = document.createElement('div');
                    inputContainer.className = "magic-box-input";
                    element.appendChild(this.clearDom);
                    element.appendChild(inputContainer);
                }
                else {
                    element.insertBefore(this.clearDom, inputContainer);
                }
                this.inputManager = new MagicBox.InputManager(inputContainer, function (text, wordCompletion) {
                    if (!wordCompletion) {
                        _this.setText(text);
                        _this.showSuggestion();
                        _this.onchange && _this.onchange();
                    }
                    else {
                        _this.setText(text);
                        _this.onselect && _this.onselect(_this.getFirstSuggestionText());
                    }
                }, this);
                this.inputManager.ontabpress = function () {
                    _this.ontabpress && _this.ontabpress();
                };
                var existingValue = this.inputManager.getValue();
                if (existingValue) {
                    this.displayedResult.input = existingValue;
                }
                this.inputManager.setResult(this.displayedResult);
                var suggestionsContainer = document.createElement('div');
                suggestionsContainer.className = "magic-box-suggestions";
                this.element.appendChild(suggestionsContainer);
                this.suggestionsManager = new MagicBox.SuggestionsManager(suggestionsContainer, {
                    selectableClass: this.options.selectableSuggestionClass,
                    selectedClass: this.options.selectedSuggestionClass,
                    timeout: this.options.suggestionTimeout
                });
                this.setupHandler();
            }
            Instance.prototype.getResult = function () {
                return this.result;
            };
            Instance.prototype.getDisplayedResult = function () {
                return this.displayedResult;
            };
            Instance.prototype.setText = function (text) {
                MagicBox.$$(this.element).toggleClass('magic-box-notEmpty', text.length > 0);
                this.result = this.grammar.parse(text);
                this.displayedResult = this.result.clean();
                this.inputManager.setResult(this.displayedResult);
            };
            Instance.prototype.setCursor = function (index) {
                this.inputManager.setCursor(index);
            };
            Instance.prototype.getCursor = function () {
                return this.inputManager.getCursor();
            };
            Instance.prototype.resultAtCursor = function (match) {
                return this.displayedResult.resultAt(this.getCursor(), match);
            };
            Instance.prototype.setupHandler = function () {
                var _this = this;
                this.inputManager.onblur = function () {
                    MagicBox.$$(_this.element).removeClass('magic-box-hasFocus');
                    _this.onblur && _this.onblur();
                    if (!_this.options.inline) {
                        _this.clearSuggestion();
                    }
                };
                this.inputManager.onfocus = function () {
                    MagicBox.$$(_this.element).addClass('magic-box-hasFocus');
                    _this.showSuggestion();
                    _this.onfocus && _this.onfocus();
                };
                this.inputManager.onkeydown = function (key) {
                    if (key == 38 || key == 40) {
                        return false;
                    }
                    if (key == 13) {
                        var suggestion = _this.suggestionsManager.select();
                        if (suggestion == null) {
                            _this.onsubmit && _this.onsubmit();
                        }
                        return false;
                    }
                    else if (key == 27) {
                        _this.clearSuggestion();
                        _this.blur();
                    }
                    return true;
                };
                this.inputManager.onchangecursor = function () {
                    _this.showSuggestion();
                };
                this.inputManager.onkeyup = function (key) {
                    if (key == 38) {
                        _this.onmove && _this.onmove();
                        _this.focusOnSuggestion(_this.suggestionsManager.moveUp());
                        _this.onchange && _this.onchange();
                    }
                    else if (key == 40) {
                        _this.onmove && _this.onmove();
                        _this.focusOnSuggestion(_this.suggestionsManager.moveDown());
                        _this.onchange && _this.onchange();
                    }
                    else {
                        return true;
                    }
                    return false;
                };
                this.clearDom.onclick = function () {
                    _this.clear();
                };
            };
            Instance.prototype.showSuggestion = function () {
                var _this = this;
                this.suggestionsManager.mergeSuggestions(this.getSuggestions != null ? this.getSuggestions() : [], function (suggestions) {
                    _this.updateSuggestion(suggestions);
                });
            };
            Instance.prototype.updateSuggestion = function (suggestions) {
                var _this = this;
                this.lastSuggestions = suggestions;
                var firstSuggestion = this.getFirstSuggestionText();
                this.inputManager.setWordCompletion(firstSuggestion && firstSuggestion.text);
                this.onsuggestions && this.onsuggestions(suggestions);
                _.each(suggestions, function (suggestion) {
                    if (suggestion.onSelect == null && suggestion.text != null) {
                        suggestion.onSelect = function () {
                            _this.setText(suggestion.text);
                            _this.onselect && _this.onselect(suggestion);
                        };
                    }
                });
            };
            Instance.prototype.focus = function () {
                MagicBox.$$(this.element).addClass('magic-box-hasFocus');
                this.inputManager.focus();
            };
            Instance.prototype.blur = function () {
                this.inputManager.blur();
            };
            Instance.prototype.clearSuggestion = function () {
                var _this = this;
                this.suggestionsManager.mergeSuggestions([], function (suggestions) {
                    _this.updateSuggestion(suggestions);
                });
                this.inputManager.setWordCompletion(null);
            };
            Instance.prototype.focusOnSuggestion = function (suggestion) {
                if (suggestion == null || suggestion.text == null) {
                    suggestion = this.getFirstSuggestionText();
                    this.inputManager.setResult(this.displayedResult, suggestion && suggestion.text);
                }
                else {
                    this.inputManager.setResult(this.grammar.parse(suggestion.text).clean(), suggestion.text);
                }
            };
            Instance.prototype.getFirstSuggestionText = function () {
                return _.find(this.lastSuggestions, function (suggestion) { return suggestion.text != null; });
                ;
            };
            Instance.prototype.getText = function () {
                return this.inputManager.getValue();
            };
            Instance.prototype.getWordCompletion = function () {
                return this.inputManager.getWordCompletion();
            };
            Instance.prototype.clear = function () {
                this.setText('');
                this.showSuggestion();
                this.focus();
                this.onclear && this.onclear();
            };
            Instance.prototype.hasSuggestions = function () {
                return this.suggestionsManager.hasSuggestions;
            };
            return Instance;
        }());
        MagicBox.Instance = Instance;
        function create(element, grammar, options) {
            return new Instance(element, grammar, options);
        }
        MagicBox.create = create;
        function requestAnimationFrame(callback) {
            if ('requestAnimationFrame' in window) {
                return window.requestAnimationFrame(callback);
            }
            return setTimeout(callback);
        }
        MagicBox.requestAnimationFrame = requestAnimationFrame;
    })(MagicBox = Coveo.MagicBox || (Coveo.MagicBox = {}));
})(Coveo || (Coveo = {}));
