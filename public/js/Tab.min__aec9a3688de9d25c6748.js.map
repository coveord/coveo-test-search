{"version":3,"sources":["Tab.min__aec9a3688de9d25c6748.js","./src/ui/ResponsiveComponents/ResponsiveComponentsUtils.ts","./node_modules/popper.js/dist/esm/popper.js","./src/ui/Tab/Tab.ts","./src/utils/EventsUtils.ts","./src/ui/ResponsiveComponents/ResponsiveTabs.ts"],"names":["webpackJsonpCoveo__temporary","127","module","exports","__webpack_require__","Object","defineProperty","value","shouldDrawFacetSlider","root","facetSliderElement","ResponsiveDropdownContent","isTargetInsideOpenedDropdown","this","isSmallFacetActivated","isSmallTabsActivated","hasClass","smallTabsClassName","smallFacetClassName","isSmallRecommendationActivated","smallRecommendationClassName","activateSmallTabs","addClass","deactivateSmallTabs","removeClass","activateSmallFacet","deactivateSmallFacet","activateSmallRecommendation","deactivateSmallRecommendation","ResponsiveComponentsUtils","173","__webpack_exports__","microtaskDebounce","fn","called","window","Promise","resolve","then","taskDebounce","scheduled","setTimeout","timeoutDuration","isFunction","functionToCheck","getType","toString","call","getStyleComputedProperty","element","property","nodeType","css","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","document","body","ownerDocument","_getStyleComputedProp","overflow","overflowX","test","overflowY","isIE","version","isIE11","isIE10","getOffsetParent","documentElement","noOffsetParent","offsetParent","nextElementSibling","indexOf","isOffsetContainer","firstElementChild","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","getScroll","side","arguments","length","undefined","upperSide","html","scrollingElement","includeScroll","rect","subtract","scrollTop","scrollLeft","modifier","top","bottom","left","right","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","computedStyle","Math","max","getWindowSizes","height","width","getClientRect","offsets","_extends","getBoundingClientRect","e","result","sizes","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","isFixed","getFixedPositionOffsetParent","parentElement","el","getBoundaries","popper","reference","padding","boundariesElement","boundaries","boundariesNode","_getWindowSizes","getArea","_ref","computeAutoPlacement","placement","refRect","rects","sortedAreas","keys","map","key","area","sort","a","b","filteredAreas","filter","_ref2","computedPlacement","variation","split","getReferenceOffsets","state","getOuterSizes","x","marginBottom","y","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","referenceOffsets","popperRect","popperOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","find","arr","check","Array","prototype","findIndex","prop","cur","match","obj","runModifiers","modifiers","data","ends","slice","forEach","console","warn","enabled","update","isDestroyed","instance","arrowStyles","attributes","flipped","options","positionFixed","flip","originalPlacement","position","isCreated","onUpdate","onCreate","isModifierEnabled","modifierName","some","name","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","i","prefix","toCheck","style","destroy","removeAttribute","willChange","disableEventListeners","removeOnDestroy","removeChild","getWindow","defaultView","attachToScrollParents","event","callback","scrollParents","isBody","target","addEventListener","passive","push","setupEventListeners","updateBound","scrollElement","eventsEnabled","enableEventListeners","scheduleUpdate","removeEventListeners","removeEventListener","cancelAnimationFrame","isNumeric","n","isNaN","isFinite","setStyles","unit","setAttributes","setAttribute","applyStyle","arrowElement","applyStyleOnLoad","modifierOptions","computeStyle","legacyGpuAccelerationOption","gpuAcceleration","offsetParentRect","floor","round","prefixedProperty","invertTop","invertLeft","arrow","isModifierRequired","requestingName","requestedName","requesting","isRequired","_requesting","requested","_data$offsets$arrow","querySelector","_data$offsets","isVertical","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","center","popperMarginSide","popperBorderSide","sideValue","min","getOppositeVariation","clockwise","counter","index","validPlacements","concat","reverse","placementOpposite","flipOrder","behavior","BEHAVIORS","FLIP","CLOCKWISE","COUNTERCLOCKWISE","step","refOffsets","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","flipVariations","keepTogether","toValue","str","parseOffset","offset","basePlacement","useHeight","fragments","frag","trim","divider","search","splitRegex","ops","op","mergeWithPrevious","reduce","index2","preventOverflow","transformProp","popperStyles","transform","priority","primary","escapeWithReference","secondary","shift","shiftvariation","shiftOffsets","hide","bound","inner","subtractLength","isBrowser","longerTimeoutBrowsers","navigator","userAgent","supportsMicroTasks","debounce","MSInputMethodContext","documentMode","classCallCheck","Constructor","TypeError","createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","assign","source","hasOwnProperty","placements","onLoad","Defaults","Popper","_this","requestAnimationFrame","bind","jquery","Utils","global","PopperUtils","200","__extends","extendStatics","setPrototypeOf","__proto__","d","p","__","constructor","create","bindings","Tab","ID","ComponentOptions","initComponentOptions","onRootElement","QueryEvents","buildingQuery","args","handleBuildingQuery","InitializationEvents","afterInitialization","handleAfterInitialization","onQueryState","MODEL_EVENTS","CHANGE_ONE","QUERY_STATE_ATTRIBUTES","T","handleQueryStateChanged","AccessibleButton","withElement","withSelectAction","select","withTitle","caption","withOwner","build","render","ResponsiveTabs","init","disabled","t","id","QueryStateModel","defaultAttributes","layout","queryStateModel","setMultiple","usageAnalytics","logSearchEvent","analyticsActionCauseList","interfaceChange","interfaceChangeTo","queryController","executeQuery","isElementIncludedInTab","Assert","exists","includedTabs","splitListOfTabs","getAttribute","excludedTabs","icon","isNonEmptyString","iconSpan","$$","insertBefore","firstChild","captionP","createElement","text","appendChild","isSelected","queryBuilder","tab","expression","constant","constantExpression","add","advancedExpression","enableDuplicateFiltering","pipeline","maximumAge","setEndpoint","endpoint","showAndHideAppropriateElements","set","LAYOUT","get","attributesEnum","showElements","hideElements","each","findAll","toggleAllComponentsUnder","one","querySuccess","elem","enable","togglePossibleComponent","possibleComponent","possibleCmp","Component","disable","display","doExport","exportGlobally","buildStringOption","required","section","buildLocalizedStringOption","buildQueryExpressionOption","buildCustomOption","SearchEndpoint","endpoints","buildBooleanOption","defaultValue","buildNumberOption","enableResponsiveMode","dropdownHeaderLabel","Initialization","registerAutoCreateComponent","482","addPrefixedEvent","pascalCaseEventName","_","removePrefixedEvent","EventsUtils","673","674","coveoRoot","ignoreNextDocumentClick","getDropdownHeaderLabel","searchInterface","SearchInterface","dropdownContent","buildDropdownContent","dropdownHeader","buildDropdownHeader","bindDropdownContentEvents","bindDropdownHeaderEvents","tabSection","manageTabSwapping","bindNukeEvents","initialTabOrder","tabsInTabSection","component","logger","Logger","info","ResponsiveComponentsManager","register","handleResizeEvent","needSmallMode","changeToSmallMode","changeToLargeMode","shouldAddTabsToDropdown","addTabsToDropdown","shouldRemoveTabsFromDropdown","removeTabsFromDropdown","isDropdownOpen","positionPopup","shouldAutoModeResolveToSmall","responsiveComponents","getResponsiveMode","mediumWidth","getMediumScreenWidth","ResponsiveComponents","isLargeFormatOverflowing","isOverflowing","emptyDropdown","cleanUpDropdown","currentTab","TAB_IN_DROPDOWN_HEADER_CSS_CLASS","facetDropdownHeader","tabIsSelected","addToDropdownIfNeeded","isDropdownEmpty","current","dropdownTabs","tabsInTabDropdown","removeFromDropdownIfNeeded","fromDropdownToTabSection","unselectedTabs","pop","append","virtualTabSection","cloneNode","visibility","detach","scrollWidth","className","content","SVGIcons","icons","arrowDown","SVGDom","addClassToSVGInContainer","toggle","closeDropdown","openDropdown","type","withLabel","SMALL_INTERFACE_CLASS_NAME","contentList","dropdownClickListener","documentClickListener","on","ACTIVE_DROPDOWN_CSS_CLASS","off","canAddTabToDropdown","TAB_IN_DROPDOWN_CSS_CLASS","list","listElement","prepend","canRemoveTabFromDropdown","tabIsInDropdown","computeCssClassNameForType","tabElement","fadeOutFadeIn","lastTabInSection","propertyName","opacity","replaceWith","swapOnSelect","KeyboardUtils","keypressAction","KEYBOARD","ENTER","relatedTarget","nuke","insertAfter","lastTabInTabSection","last","computeCssClassName","l","DROPDOWN_HEADER_LABEL_DEFAULT_VALUE","tabsInSection","childElement","isHtmlElement","child","childHasTabCssClassName","675"],"mappings":"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","file":"Tab.min__aec9a3688de9d25c6748.js","sourcesContent":["webpackJsonpCoveo__temporary([22],{\n\n/***/ 127:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ResponsiveDropdownContent_1 = __webpack_require__(66);\nvar ResponsiveComponentsUtils = /** @class */ (function () {\n    function ResponsiveComponentsUtils() {\n    }\n    ResponsiveComponentsUtils.shouldDrawFacetSlider = function (root, facetSliderElement) {\n        return ResponsiveDropdownContent_1.ResponsiveDropdownContent.isTargetInsideOpenedDropdown(facetSliderElement) || !this.isSmallFacetActivated(root);\n    };\n    ResponsiveComponentsUtils.isSmallTabsActivated = function (root) {\n        return root.hasClass(this.smallTabsClassName);\n    };\n    ResponsiveComponentsUtils.isSmallFacetActivated = function (root) {\n        return root.hasClass(this.smallFacetClassName);\n    };\n    ResponsiveComponentsUtils.isSmallRecommendationActivated = function (root) {\n        return root.hasClass(this.smallRecommendationClassName);\n    };\n    ResponsiveComponentsUtils.activateSmallTabs = function (root) {\n        root.addClass(this.smallTabsClassName);\n    };\n    ResponsiveComponentsUtils.deactivateSmallTabs = function (root) {\n        root.removeClass(this.smallTabsClassName);\n    };\n    ResponsiveComponentsUtils.activateSmallFacet = function (root) {\n        root.addClass(this.smallFacetClassName);\n    };\n    ResponsiveComponentsUtils.deactivateSmallFacet = function (root) {\n        root.removeClass(this.smallFacetClassName);\n    };\n    ResponsiveComponentsUtils.activateSmallRecommendation = function (root) {\n        root.addClass(this.smallRecommendationClassName);\n    };\n    ResponsiveComponentsUtils.deactivateSmallRecommendation = function (root) {\n        root.removeClass(this.smallRecommendationClassName);\n    };\n    ResponsiveComponentsUtils.smallTabsClassName = 'coveo-small-tabs';\n    ResponsiveComponentsUtils.smallFacetClassName = 'coveo-small-facets';\n    ResponsiveComponentsUtils.smallRecommendationClassName = 'coveo-small-recommendation';\n    return ResponsiveComponentsUtils;\n}());\nexports.ResponsiveComponentsUtils = ResponsiveComponentsUtils;\n\n\n/***/ }),\n\n/***/ 173:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(global) {/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.14.3\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nvar longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nvar timeoutDuration = 0;\nfor (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var css = getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);\n}\n\nfunction getWindowSizes() {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};\n  var width = sizes.width || element.clientWidth || result.right - result.left;\n  var height = sizes.height || element.clientHeight || result.bottom - result.top;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && parent.nodeName === 'HTML') {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop, 10);\n    var marginLeft = parseFloat(styles.marginLeft, 10);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var styles = getComputedStyle(element);\n  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroy the popper\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicity asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger onUpdate callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  // Avoid blurry text by using full pixel integers.\n  // For pixel-perfect positioning, top/bottom prefers rounded\n  // values, while left/right prefers floored values.\n  var offsets = {\n    left: Math.floor(popper.left),\n    top: Math.round(popper.top),\n    bottom: Math.round(popper.bottom),\n    right: Math.floor(popper.right)\n  };\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    top = -offsetParentRect.height + offsets.bottom;\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    left = -offsetParentRect.width + offsets.right;\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjuction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-right` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unitless, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the height.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * An scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper this makes sure the popper has always a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier, can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near eachothers\n   * without leaving any gap between the two. Expecially useful when the arrow is\n   * enabled and you want to assure it to point to its reference element.\n   * It cares only about the first axis, you can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjuction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations).\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position,\n     * the popper will never be placed outside of the defined boundaries\n     * (except if keepTogether is enabled)\n     */\n    boundariesElement: 'viewport'\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define you own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the informations used by Popper.js\n * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overriden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass as 3rd argument an object with the same\n * structure of this object, example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated, this callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Create a new Popper.js instance\n   * @class Popper\n   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper.\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedule an update, it will run on the next UI update available\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Popper);\n//# sourceMappingURL=popper.js.map\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(85)))\n\n/***/ }),\n\n/***/ 200:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(673);\nvar underscore_1 = __webpack_require__(0);\nvar InitializationEvents_1 = __webpack_require__(17);\nvar QueryEvents_1 = __webpack_require__(11);\nvar GlobalExports_1 = __webpack_require__(3);\nvar Assert_1 = __webpack_require__(5);\nvar Model_1 = __webpack_require__(18);\nvar QueryStateModel_1 = __webpack_require__(13);\nvar SearchEndpoint_1 = __webpack_require__(51);\nvar AccessibleButton_1 = __webpack_require__(16);\nvar Dom_1 = __webpack_require__(1);\nvar Utils_1 = __webpack_require__(4);\nvar AnalyticsActionListMeta_1 = __webpack_require__(10);\nvar Component_1 = __webpack_require__(7);\nvar ComponentOptions_1 = __webpack_require__(8);\nvar Initialization_1 = __webpack_require__(2);\nvar ResponsiveTabs_1 = __webpack_require__(674);\n/**\n * The Tab component renders a widget that allows the end user to select a specific search interface.\n *\n * This component attaches itself to a `div` element. It is in charge of adding an advanced expression to the outgoing\n * query in order to refine the results.\n *\n * The Tab component can also hide and show different parts of the UI. For each individual component in the UI, you can\n * specify whether you wish to include or exclude that component when the user selects a certain Tab (see [Using Components\n * Only on Specific Tabs](https://docs.coveo.com/en/508/javascript-search-framework/using-components-only-on-specific-tabs)).\n *\n * **Setting a New Endpoint for a Tab:**\n *\n * A Tab can use a custom endpoint when performing a query. Of course, you need to make sure that the endpoint exists in\n * the array of Coveo.SearchEndpoint.endpoints (see {@link SearchEndpoint.endpoints}).\n *\n * ```\n * Coveo.SearchEndpoint.endpoints[\"specialEndpoint\"] = new Coveo.SearchEndpoint({\n *     restUri : 'https://somewhere.com/rest/search'\n * })\n *\n * [ ... ]\n *\n * <div class='CoveoTab' data-endpoint='specialEndpoint'></div>\n *\n * ```\n */\nvar Tab = /** @class */ (function (_super) {\n    __extends(Tab, _super);\n    /**\n     * Creates a new Tab. Binds on buildingQuery event as well as an event on click of the element.\n     * @param element The HTMLElement on which to instantiate the component. Normally a `div`.\n     * @param options The options for the Tab component.\n     * @param bindings The bindings that the component requires to function normally. If not set, these will be\n     * automatically resolved (with a slower execution time).\n     */\n    function Tab(element, options, bindings) {\n        var _this = _super.call(this, element, Tab.ID, bindings) || this;\n        _this.element = element;\n        _this.options = options;\n        _this.options = ComponentOptions_1.ComponentOptions.initComponentOptions(element, Tab, options);\n        _this.bind.onRootElement(QueryEvents_1.QueryEvents.buildingQuery, function (args) { return _this.handleBuildingQuery(args); });\n        _this.bind.onRootElement(InitializationEvents_1.InitializationEvents.afterInitialization, function () { return _this.handleAfterInitialization(); });\n        _this.bind.onQueryState(Model_1.MODEL_EVENTS.CHANGE_ONE, QueryStateModel_1.QUERY_STATE_ATTRIBUTES.T, function (args) {\n            return _this.handleQueryStateChanged(args);\n        });\n        new AccessibleButton_1.AccessibleButton()\n            .withElement(element)\n            .withSelectAction(function () { return _this.select(); })\n            .withTitle(_this.options.caption)\n            .withOwner(_this.bind)\n            .build();\n        _this.render();\n        ResponsiveTabs_1.ResponsiveTabs.init(_this.root, _this, _this.options);\n        return _this;\n    }\n    /**\n     * Selects the current Tab.\n     *\n     * Also logs the `interfaceChange` event in the usage analytics with the new current {@link Tab.options.id} as metada\n     * and triggers a new query.\n     */\n    Tab.prototype.select = function () {\n        if (!this.disabled) {\n            var state = {\n                t: this.options.id,\n                sort: this.options.sort || QueryStateModel_1.QueryStateModel.defaultAttributes.sort\n            };\n            if (this.options.layout) {\n                state.layout = this.options.layout;\n            }\n            this.queryStateModel.setMultiple(state);\n            this.usageAnalytics.logSearchEvent(AnalyticsActionListMeta_1.analyticsActionCauseList.interfaceChange, {\n                interfaceChangeTo: this.options.id\n            });\n            this.queryController.executeQuery();\n        }\n    };\n    /**\n     * Indicates whether the HTMLElement argument is included in the Tab. *Included* elements are shown when the Tab is\n     * selected, whereas *excluded* elements are not.\n     * @param element The HTMLElement to verify.\n     * @returns {boolean} `true` if the HTMLElement is included in the Tab; `false` if it is excluded.\n     */\n    Tab.prototype.isElementIncludedInTab = function (element) {\n        Assert_1.Assert.exists(element);\n        var includedTabs = this.splitListOfTabs(element.getAttribute('data-tab'));\n        var excludedTabs = this.splitListOfTabs(element.getAttribute('data-tab-not'));\n        Assert_1.Assert.check(!(includedTabs.length != 0 && excludedTabs.length != 0), 'You cannot both explicitly include and exclude an element from tabs.');\n        return ((includedTabs.length != 0 && underscore_1.indexOf(includedTabs, this.options.id) != -1) ||\n            (excludedTabs.length != 0 && underscore_1.indexOf(excludedTabs, this.options.id) == -1) ||\n            (includedTabs.length == 0 && excludedTabs.length == 0));\n    };\n    Tab.prototype.render = function () {\n        var icon = this.options.icon;\n        if (Utils_1.Utils.isNonEmptyString(icon)) {\n            var iconSpan = Dom_1.$$('span').el;\n            Dom_1.$$(iconSpan).addClass(['coveo-icon', icon]);\n            this.element.insertBefore(iconSpan, this.element.firstChild);\n        }\n        var caption = this.options.caption;\n        if (Utils_1.Utils.isNonEmptyString(caption)) {\n            var captionP = document.createElement('p');\n            Dom_1.$$(captionP).text(caption);\n            this.element.appendChild(captionP);\n        }\n    };\n    Tab.prototype.handleBuildingQuery = function (data) {\n        Assert_1.Assert.exists(data);\n        if (!this.disabled && this.isSelected()) {\n            data.queryBuilder.tab = this.options.id;\n            if (Utils_1.Utils.isNonEmptyString(this.options.expression)) {\n                if (this.options.constant) {\n                    data.queryBuilder.constantExpression.add(this.options.expression);\n                }\n                else {\n                    data.queryBuilder.advancedExpression.add(this.options.expression);\n                }\n            }\n            if (this.options.enableDuplicateFiltering) {\n                data.queryBuilder.enableDuplicateFiltering = true;\n            }\n            if (this.options.pipeline != null) {\n                data.queryBuilder.pipeline = this.options.pipeline;\n            }\n            if (this.options.maximumAge != null) {\n                data.queryBuilder.maximumAge = this.options.maximumAge;\n            }\n        }\n    };\n    Tab.prototype.handleQueryStateChanged = function (data) {\n        Assert_1.Assert.exists(data);\n        if (!this.disabled && this.isSelected()) {\n            Dom_1.$$(this.element).addClass('coveo-selected');\n            this.queryController.setEndpoint(this.options.endpoint);\n            this.showAndHideAppropriateElements();\n        }\n        else {\n            Dom_1.$$(this.element).removeClass('coveo-selected');\n        }\n    };\n    Tab.prototype.handleAfterInitialization = function () {\n        if (this.isSelected() && this.options.layout) {\n            this.queryStateModel.set(QueryStateModel_1.QUERY_STATE_ATTRIBUTES.LAYOUT, this.options.layout);\n        }\n    };\n    Tab.prototype.isSelected = function () {\n        var activeTab = this.queryStateModel.get(QueryStateModel_1.QueryStateModel.attributesEnum.t);\n        return activeTab == this.options.id;\n    };\n    Tab.prototype.showAndHideAppropriateElements = function () {\n        var _this = this;\n        var showElements = [];\n        var hideElements = [];\n        underscore_1.each(Dom_1.$$(this.root).findAll('[data-tab],[data-tab-not]'), function (element) {\n            if (_this.isElementIncludedInTab(element)) {\n                _this.toggleAllComponentsUnder(element, true);\n                showElements.push(element);\n            }\n            else {\n                _this.toggleAllComponentsUnder(element, false);\n                hideElements.push(element);\n            }\n        });\n        Dom_1.$$(this.root).one(QueryEvents_1.QueryEvents.querySuccess, function () {\n            underscore_1.each(showElements, function (elem) { return Dom_1.$$(elem).removeClass('coveo-tab-disabled'); });\n            underscore_1.each(hideElements, function (elem) { return Dom_1.$$(elem).addClass('coveo-tab-disabled'); });\n        });\n    };\n    Tab.prototype.splitListOfTabs = function (value) {\n        if (Utils_1.Utils.exists(value)) {\n            return underscore_1.map(value.split(','), function (tab) { return Utils_1.Utils.trim(tab); });\n        }\n        else {\n            return [];\n        }\n    };\n    Tab.prototype.toggleAllComponentsUnder = function (element, enable) {\n        Assert_1.Assert.exists(element);\n        var togglePossibleComponent = function (possibleComponent) {\n            var possibleCmp = Component_1.Component.get(possibleComponent, undefined, true);\n            if (possibleCmp) {\n                if (enable) {\n                    possibleCmp.enable();\n                }\n                else {\n                    possibleCmp.disable();\n                }\n            }\n        };\n        togglePossibleComponent(element);\n        underscore_1.each(Dom_1.$$(element).findAll('*'), function (el) {\n            togglePossibleComponent(el);\n        });\n    };\n    Tab.prototype.enable = function () {\n        _super.prototype.enable.call(this);\n        this.element.style.display = '';\n    };\n    Tab.prototype.disable = function () {\n        _super.prototype.disable.call(this);\n        this.element.style.display = 'none';\n    };\n    Tab.ID = 'Tab';\n    Tab.doExport = function () {\n        GlobalExports_1.exportGlobally({\n            Tab: Tab\n        });\n    };\n    /**\n     * The options for a Tab\n     * @componentOptions\n     */\n    Tab.options = {\n        /**\n         * Specifies a unique ID for the Tab.\n         *\n         * Specifying a value for this option is necessary for this component to work.\n         */\n        id: ComponentOptions_1.ComponentOptions.buildStringOption({ required: true, section: 'Common Options' }),\n        /**\n         * Specifies the caption of the Tab.\n         *\n         * Specifying a value for this option is necessary for this component to work.\n         */\n        caption: ComponentOptions_1.ComponentOptions.buildLocalizedStringOption({ required: true, section: 'Common Options' }),\n        /**\n         * Specifies an icon to use for the Tab.\n         *\n         * @deprecated This options is mostly kept for legacy reasons. If possible, you should avoid using it.\n         */\n        icon: ComponentOptions_1.ComponentOptions.buildStringOption(),\n        /**\n         * Specifies an advanced expression or filter that the Tab should add to any outgoing query.\n         *\n         * **Example:**\n         *\n         * `@objecttype==Message`\n         *\n         * Default value is `undefined` and the Tab applies no additional expression or filter to the query.\n         */\n        expression: ComponentOptions_1.ComponentOptions.buildQueryExpressionOption({ section: 'Common Options' }),\n        /**\n         * Specifies the {@link SearchEndpoint} to point to when performing queries from within the Tab.\n         *\n         * By default, the Tab uses the \"default\" endpoint.\n         */\n        endpoint: ComponentOptions_1.ComponentOptions.buildCustomOption(function (endpoint) { return (endpoint != null ? SearchEndpoint_1.SearchEndpoint.endpoints[endpoint] : null); }),\n        /**\n         * Specifies the default sort criteria to use when selecting the Tab. A {@link Sort} component with the same\n         * parameter needs to be present in the search interface in order for this option to function properly.\n         *\n         * **Examples:**\n         *\n         * - `data-sort='relevancy'`\n         * - `data-sort='date descending'`\n         *\n         * Default value is `undefined` and the normal {@link Sort} component behavior applies.\n         */\n        sort: ComponentOptions_1.ComponentOptions.buildStringOption(),\n        /**\n         * Specifies the default layout to display when the user selects the Tab (see {@link ResultList.options.layout} and\n         * {@link ResultLayout}).\n         *\n         * See the {@link ValidLayout} type for the list of possible values.\n         *\n         * If not specified, it will default to 'list'.\n         *\n         * See also [Result Layouts](https://docs.coveo.com/en/360/).\n         *\n         * Default value is `undefined` and the component selects the first available layout.\n         */\n        layout: ComponentOptions_1.ComponentOptions.buildStringOption(),\n        /**\n         * Specifies whether to include the {@link Tab.options.expression} in the constant part of the query.\n         *\n         * The index specially optimizes the constant part of the query to execute faster. However, you must be careful not\n         * to include dynamic query expressions, otherwise the cache will lose its efficiency.\n         *\n         * Default value is `true`.\n         */\n        constant: ComponentOptions_1.ComponentOptions.buildBooleanOption({ defaultValue: true, section: 'Filtering' }),\n        /**\n         * Whether to filter out duplicates, so that items resembling one another only appear once in the query results.\n         *\n         * **Notes:**\n         * - Two items must be at least 85% similar to one another to be considered duplicates.\n         * - When a pair of duplicates is found, only the higher-ranked item of the two is kept in the result set.\n         * - Enabling this feature can make the total result count less precise, as only the requested page of query results is submitted to duplicate filtering.\n         * - The default value for this option can be modified through the {@link SearchInterface} component.\n         */\n        enableDuplicateFiltering: ComponentOptions_1.ComponentOptions.buildBooleanOption({ defaultValue: false }),\n        /**\n         * Specifies the name of the query pipeline to use for the queries when the Tab is selected.\n         *\n         * You can specify a value for this option if your index is in a Coveo Cloud organization in which pipelines have\n         * been created (see [Adding and Managing Query Pipelines](https://docs.coveo.com/en/1791/)).\n         *\n         * Default value is `undefined`, which means that pipeline selection conditions defined in the Coveo Cloud\n         * organization apply.\n         */\n        pipeline: ComponentOptions_1.ComponentOptions.buildStringOption(),\n        /**\n         * Specifies the maximum age (in milliseconds) that cached query results can have to still be usable as results\n         * instead of performing a new query on the index from within the Tab. The cache is located in the Coveo Search API\n         * (which resides between the index and the search interface).\n         *\n         * If cached results that are older than the age you specify in this option are available, a new query will be\n         * performed on the index anyhow.\n         *\n         * On high-volume public web sites, specifying a higher value for this option can greatly improve query response\n         * time at the cost of result freshness.\n         *\n         * **Note:**\n         *\n         * > It is also possible to set a maximum cache age for the entire {@link SearchInterface} rather than for a single\n         * > Tab (see {@link SearchInterface.options.maximumAge}).\n         *\n         * Default value is `undefined` and the Coveo Search API determines the maximum cache age. This is typically\n         * equivalent to 30 minutes (see [maximumAge](https://docs.coveo.com/en/1461/#RestQueryParameters-maximumAge)).\n         */\n        maximumAge: ComponentOptions_1.ComponentOptions.buildNumberOption(),\n        /**\n         * Specifies whether to enable responsive mode for tabs. Responsive mode makes overflowing tabs disappear, instead\n         * making them available using a dropdown button. Responsive tabs are enabled either when tabs overflow or when the\n         * width of the search interface becomes too small.\n         *\n         * Disabling responsive mode for one Tab also disables it for all tabs. Therefore, you only need to set this option\n         * to `false` on one Tab to disable responsive mode.\n         *\n         * Default value is `true`.\n         *\n         * @availablesince [October 2016 Release (v1.1550.5)](https://docs.coveo.com/en/309/#october-2016-release-v115505)\n         */\n        enableResponsiveMode: ComponentOptions_1.ComponentOptions.buildBooleanOption({ defaultValue: true, section: 'ResponsiveOptions' }),\n        /**\n         * Specifies the label of the button that allows to show the hidden tabs when in responsive mode.\n         *\n         * If more than one Tab in the search interface specifies a value for this option, then the framework uses the first\n         * occurrence of the option.\n         *\n         * The default value is `\"More\"`.\n         */\n        dropdownHeaderLabel: ComponentOptions_1.ComponentOptions.buildLocalizedStringOption({ section: 'ResponsiveOptions' })\n    };\n    return Tab;\n}(Component_1.Component));\nexports.Tab = Tab;\nInitialization_1.Initialization.registerAutoCreateComponent(Tab);\n\n\n/***/ }),\n\n/***/ 482:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ = __webpack_require__(0);\nvar EventsUtils = /** @class */ (function () {\n    function EventsUtils() {\n    }\n    // eventName must be in PascalCase\n    EventsUtils.addPrefixedEvent = function (element, pascalCaseEventName, callback) {\n        _.each(this.prefixes, function (prefix) {\n            if (prefix == '') {\n                pascalCaseEventName = pascalCaseEventName.toLowerCase();\n            }\n            element.addEventListener(prefix + pascalCaseEventName, callback, false);\n        });\n    };\n    // eventName must be in PascalCase\n    EventsUtils.removePrefixedEvent = function (element, pascalCaseEventName, callback) {\n        _.each(this.prefixes, function (prefix) {\n            if (prefix == '') {\n                pascalCaseEventName = pascalCaseEventName.toLowerCase();\n            }\n            element.removeEventListener(prefix + pascalCaseEventName, callback, false);\n        });\n    };\n    EventsUtils.prefixes = ['webkit', 'moz', 'MS', 'o', ''];\n    return EventsUtils;\n}());\nexports.EventsUtils = EventsUtils;\n\n\n/***/ }),\n\n/***/ 673:\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n\n/***/ 674:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(675);\nvar underscore_1 = __webpack_require__(0);\nvar InitializationEvents_1 = __webpack_require__(17);\nvar Logger_1 = __webpack_require__(9);\nvar Strings_1 = __webpack_require__(6);\nvar Dom_1 = __webpack_require__(1);\nvar EventsUtils_1 = __webpack_require__(482);\nvar SVGDom_1 = __webpack_require__(15);\nvar SVGIcons_1 = __webpack_require__(12);\nvar Utils_1 = __webpack_require__(4);\nvar Component_1 = __webpack_require__(7);\nvar SearchInterface_1 = __webpack_require__(20);\nvar Tab_1 = __webpack_require__(200);\nvar ResponsiveComponents_1 = __webpack_require__(53);\nvar ResponsiveComponentsManager_1 = __webpack_require__(83);\nvar ResponsiveComponentsUtils_1 = __webpack_require__(127);\nvar AccessibleButton_1 = __webpack_require__(16);\nvar popper_js_1 = __webpack_require__(173);\nvar KeyboardUtils_1 = __webpack_require__(26);\nvar ResponsiveTabs = /** @class */ (function () {\n    function ResponsiveTabs(coveoRoot, ID) {\n        this.coveoRoot = coveoRoot;\n        this.ID = ID;\n        this.ignoreNextDocumentClick = false;\n        this.dropdownHeaderLabel = this.getDropdownHeaderLabel();\n        this.searchInterface = Component_1.Component.get(this.coveoRoot.el, SearchInterface_1.SearchInterface, false);\n        this.dropdownContent = this.buildDropdownContent();\n        this.dropdownHeader = this.buildDropdownHeader();\n        this.bindDropdownContentEvents();\n        this.bindDropdownHeaderEvents();\n        this.tabSection = Dom_1.$$(this.coveoRoot.find('.coveo-tab-section'));\n        this.manageTabSwapping();\n        this.bindNukeEvents();\n        this.initialTabOrder = this.tabsInTabSection.slice();\n    }\n    ResponsiveTabs.init = function (root, component, options) {\n        this.logger = new Logger_1.Logger('ResponsiveTabs');\n        if (!Dom_1.$$(root).find('.coveo-tab-section')) {\n            this.logger.info('No element with class coveo-tab-section. Responsive tabs cannot be enabled.');\n            return;\n        }\n        ResponsiveComponentsManager_1.ResponsiveComponentsManager.register(ResponsiveTabs, Dom_1.$$(root), Tab_1.Tab.ID, component, options);\n    };\n    ResponsiveTabs.prototype.handleResizeEvent = function () {\n        if (this.needSmallMode() && !ResponsiveComponentsUtils_1.ResponsiveComponentsUtils.isSmallTabsActivated(this.coveoRoot)) {\n            this.changeToSmallMode();\n        }\n        else if (!this.needSmallMode() && ResponsiveComponentsUtils_1.ResponsiveComponentsUtils.isSmallTabsActivated(this.coveoRoot)) {\n            this.changeToLargeMode();\n        }\n        if (this.shouldAddTabsToDropdown()) {\n            this.addTabsToDropdown();\n        }\n        else if (this.shouldRemoveTabsFromDropdown()) {\n            this.removeTabsFromDropdown();\n        }\n        if (this.isDropdownOpen()) {\n            this.positionPopup();\n        }\n    };\n    ResponsiveTabs.prototype.needSmallMode = function () {\n        // Ignore everything if the responsiveMode is not auto.\n        if (!this.searchInterface) {\n            return this.shouldAutoModeResolveToSmall();\n        }\n        switch (this.searchInterface.responsiveComponents.getResponsiveMode()) {\n            case 'small':\n            case 'medium':\n                return true;\n            case 'auto':\n            default:\n                return this.shouldAutoModeResolveToSmall();\n        }\n    };\n    ResponsiveTabs.prototype.shouldAutoModeResolveToSmall = function () {\n        var mediumWidth = this.searchInterface\n            ? this.searchInterface.responsiveComponents.getMediumScreenWidth()\n            : new ResponsiveComponents_1.ResponsiveComponents().getMediumScreenWidth();\n        if (this.coveoRoot.width() <= mediumWidth) {\n            return true;\n        }\n        else if (!ResponsiveComponentsUtils_1.ResponsiveComponentsUtils.isSmallTabsActivated(this.coveoRoot)) {\n            return this.isOverflowing(this.tabSection.el);\n        }\n        else {\n            return this.isLargeFormatOverflowing();\n        }\n    };\n    ResponsiveTabs.prototype.changeToSmallMode = function () {\n        ResponsiveComponentsUtils_1.ResponsiveComponentsUtils.activateSmallTabs(this.coveoRoot);\n    };\n    ResponsiveTabs.prototype.changeToLargeMode = function () {\n        this.emptyDropdown();\n        this.cleanUpDropdown();\n        ResponsiveComponentsUtils_1.ResponsiveComponentsUtils.deactivateSmallTabs(this.coveoRoot);\n    };\n    ResponsiveTabs.prototype.shouldAddTabsToDropdown = function () {\n        return ((this.isOverflowing(this.tabSection.el) || this.tabSection.el.clientWidth === 0) &&\n            ResponsiveComponentsUtils_1.ResponsiveComponentsUtils.isSmallTabsActivated(this.coveoRoot));\n    };\n    ResponsiveTabs.prototype.addTabsToDropdown = function () {\n        var currentTab;\n        if (!this.tabSection.find(\".\" + ResponsiveTabs.TAB_IN_DROPDOWN_HEADER_CSS_CLASS)) {\n            var facetDropdownHeader = this.tabSection.find('.coveo-facet-dropdown-header');\n            if (facetDropdownHeader) {\n                this.dropdownHeader.insertBefore(facetDropdownHeader);\n            }\n            else {\n                this.tabSection.el.appendChild(this.dropdownHeader.el);\n            }\n        }\n        for (var i = this.initialTabOrder.length - 1; i >= 0; i--) {\n            currentTab = this.initialTabOrder[i];\n            if (this.tabIsSelected(currentTab) && i > 0) {\n                currentTab = this.initialTabOrder[--i];\n            }\n            this.addToDropdownIfNeeded(currentTab);\n            if (!this.isOverflowing(this.tabSection.el)) {\n                break;\n            }\n        }\n    };\n    ResponsiveTabs.prototype.shouldRemoveTabsFromDropdown = function () {\n        return (!this.isOverflowing(this.tabSection.el) &&\n            this.tabSection.el.clientWidth !== 0 &&\n            ResponsiveComponentsUtils_1.ResponsiveComponentsUtils.isSmallTabsActivated(this.coveoRoot) &&\n            !this.isDropdownEmpty());\n    };\n    ResponsiveTabs.prototype.removeTabsFromDropdown = function () {\n        var _this = this;\n        var dropdownTabs = this.tabsInTabDropdown;\n        var current;\n        while (!this.isOverflowing(this.tabSection.el) && !this.isDropdownEmpty()) {\n            current = dropdownTabs.shift();\n            this.removeFromDropdownIfNeeded(current);\n            this.fromDropdownToTabSection(Dom_1.$$(current));\n        }\n        if (this.isOverflowing(this.tabSection.el)) {\n            var unselectedTabs = underscore_1.filter(this.tabsInTabSection, function (tab) { return !_this.tabIsSelected(tab); });\n            this.addToDropdownIfNeeded(unselectedTabs.pop());\n        }\n        if (this.isDropdownEmpty()) {\n            this.cleanUpDropdown();\n        }\n    };\n    ResponsiveTabs.prototype.emptyDropdown = function () {\n        var _this = this;\n        if (!this.isDropdownEmpty()) {\n            var dropdownTabs = this.tabsInTabDropdown;\n            while (!this.isDropdownEmpty()) {\n                var current = dropdownTabs.shift();\n                this.removeFromDropdownIfNeeded(current);\n            }\n            this.initialTabOrder.forEach(function (tab) { return _this.tabSection.append(tab); });\n        }\n    };\n    ResponsiveTabs.prototype.isLargeFormatOverflowing = function () {\n        var virtualTabSection = Dom_1.$$(this.tabSection.el.cloneNode(true));\n        var dropdownHeader = virtualTabSection.find(\".\" + ResponsiveTabs.TAB_IN_DROPDOWN_HEADER_CSS_CLASS);\n        if (dropdownHeader) {\n            virtualTabSection.el.removeChild(dropdownHeader);\n        }\n        virtualTabSection.el.style.position = 'absolute';\n        virtualTabSection.el.style.visibility = 'hidden';\n        if (!this.isDropdownEmpty()) {\n            underscore_1.each(this.dropdownContent.findAll('.CoveoTab'), function (tab) {\n                virtualTabSection.el.appendChild(tab.cloneNode(true));\n            });\n        }\n        virtualTabSection.insertBefore(this.tabSection.el);\n        ResponsiveComponentsUtils_1.ResponsiveComponentsUtils.deactivateSmallTabs(this.coveoRoot);\n        var isOverflowing = this.isOverflowing(this.tabSection.el) || this.isOverflowing(virtualTabSection.el);\n        ResponsiveComponentsUtils_1.ResponsiveComponentsUtils.activateSmallTabs(this.coveoRoot);\n        virtualTabSection.detach();\n        return isOverflowing;\n    };\n    ResponsiveTabs.prototype.isOverflowing = function (el) {\n        return el.clientWidth < el.scrollWidth;\n    };\n    ResponsiveTabs.prototype.buildDropdownHeader = function () {\n        var dropdownHeader = Dom_1.$$('a', { className: \"coveo-dropdown-header \" + ResponsiveTabs.TAB_IN_DROPDOWN_HEADER_CSS_CLASS });\n        var content = Dom_1.$$('p');\n        content.text(this.dropdownHeaderLabel);\n        var icon = Dom_1.$$('span', { className: 'coveo-more-tabs' }, SVGIcons_1.SVGIcons.icons.arrowDown);\n        SVGDom_1.SVGDom.addClassToSVGInContainer(icon.el, 'coveo-more-tabs-svg');\n        content.el.appendChild(icon.el);\n        dropdownHeader.el.appendChild(content.el);\n        return dropdownHeader;\n    };\n    ResponsiveTabs.prototype.bindDropdownHeaderEvents = function () {\n        var _this = this;\n        var toggle = function (event) {\n            if (_this.isDropdownOpen()) {\n                _this.closeDropdown();\n            }\n            else {\n                _this.openDropdown();\n            }\n            if (event.type === 'click') {\n                _this.ignoreNextDocumentClick = true;\n            }\n        };\n        new AccessibleButton_1.AccessibleButton()\n            .withElement(this.dropdownHeader)\n            .withSelectAction(toggle)\n            .withLabel(this.getDropdownHeaderLabel())\n            .build();\n    };\n    ResponsiveTabs.prototype.buildDropdownContent = function () {\n        var dropdownContent = Dom_1.$$('div', {\n            className: 'coveo-tab-list-container ' + SearchInterface_1.SearchInterface.SMALL_INTERFACE_CLASS_NAME\n        });\n        var contentList = Dom_1.$$('ol', { className: 'coveo-tab-list' });\n        dropdownContent.el.appendChild(contentList.el);\n        return dropdownContent;\n    };\n    ResponsiveTabs.prototype.bindDropdownContentEvents = function () {\n        var _this = this;\n        this.dropdownClickListener = function () {\n            if (_this.isDropdownOpen()) {\n                _this.ignoreNextDocumentClick = true;\n            }\n        };\n        this.documentClickListener = function (event) {\n            if (!_this.ignoreNextDocumentClick) {\n                _this.closeDropdown();\n            }\n            _this.ignoreNextDocumentClick = false;\n        };\n        Dom_1.$$(this.dropdownHeader).on('click', this.dropdownClickListener);\n        Dom_1.$$(this.dropdownContent).on('click', this.dropdownClickListener);\n    };\n    ResponsiveTabs.prototype.isDropdownOpen = function () {\n        return this.dropdownHeader.hasClass(ResponsiveTabs.ACTIVE_DROPDOWN_CSS_CLASS);\n    };\n    ResponsiveTabs.prototype.closeDropdown = function () {\n        Dom_1.$$(document.documentElement).off('click', this.documentClickListener);\n        this.dropdownContent.detach();\n        this.dropdownHeader.removeClass(ResponsiveTabs.ACTIVE_DROPDOWN_CSS_CLASS);\n    };\n    ResponsiveTabs.prototype.openDropdown = function () {\n        Dom_1.$$(document.documentElement).on('click', this.documentClickListener);\n        this.positionPopup();\n        this.dropdownHeader.addClass(ResponsiveTabs.ACTIVE_DROPDOWN_CSS_CLASS);\n    };\n    ResponsiveTabs.prototype.addToDropdownIfNeeded = function (tab) {\n        if (!this.canAddTabToDropdown(tab)) {\n            return;\n        }\n        Dom_1.$$(tab).addClass(ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS);\n        var list = Dom_1.$$(this.dropdownContent.find('ol'));\n        var listElement = Dom_1.$$('li', null, tab);\n        list.prepend(listElement.el);\n    };\n    ResponsiveTabs.prototype.removeFromDropdownIfNeeded = function (tab) {\n        if (!this.canRemoveTabFromDropdown(tab)) {\n            return;\n        }\n        Dom_1.$$(tab).removeClass(ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS);\n        Dom_1.$$(tab.parentElement).detach();\n    };\n    ResponsiveTabs.prototype.canAddTabToDropdown = function (tab) {\n        return tab && !this.tabIsInDropdown(tab) && this.dropdownHeader;\n    };\n    ResponsiveTabs.prototype.canRemoveTabFromDropdown = function (tab) {\n        return tab && this.tabIsInDropdown(tab) && this.dropdownContent;\n    };\n    ResponsiveTabs.prototype.cleanUpDropdown = function () {\n        this.dropdownHeader.removeClass(ResponsiveTabs.ACTIVE_DROPDOWN_CSS_CLASS);\n        this.dropdownHeader.detach();\n        this.dropdownContent.detach();\n    };\n    ResponsiveTabs.prototype.isDropdownEmpty = function () {\n        if (this.dropdownContent) {\n            var tabs = this.dropdownContent.findAll('.CoveoTab');\n            return tabs.length == 0;\n        }\n        return false;\n    };\n    ResponsiveTabs.prototype.manageTabSwapping = function () {\n        var _this = this;\n        underscore_1.each(this.coveoRoot.findAll('.' + Component_1.Component.computeCssClassNameForType(this.ID)), function (tabElement) {\n            var tab = Dom_1.$$(tabElement);\n            var fadeOutFadeIn = function (event) {\n                var lastTabInSection = _this.tabsInTabSection.pop();\n                if (event.propertyName == 'opacity') {\n                    if (tab.el.style.opacity == '0') {\n                        Dom_1.$$(lastTabInSection).addClass(ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS);\n                        tab.replaceWith(lastTabInSection);\n                        tab.removeClass(ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS);\n                        _this.fromDropdownToTabSection(tab);\n                        // Because of the DOM manipulation, sometimes the animation will not trigger. Accessing the computed styles makes sure\n                        // the animation will happen.\n                        window.getComputedStyle(tab.el).opacity;\n                        window.getComputedStyle(lastTabInSection).opacity;\n                        tab.el.style.opacity = lastTabInSection.style.opacity = '1';\n                    }\n                    else if (tab.el.style.opacity == '1') {\n                        _this.closeDropdown();\n                        EventsUtils_1.EventsUtils.removePrefixedEvent(tab.el, 'TransitionEnd', fadeOutFadeIn);\n                        _this.handleResizeEvent();\n                    }\n                }\n            };\n            var swapOnSelect = function () {\n                if (_this.tabIsInDropdown(tab)) {\n                    var lastTabInSection = _this.tabsInTabSection.pop();\n                    if (lastTabInSection) {\n                        EventsUtils_1.EventsUtils.addPrefixedEvent(tab.el, 'TransitionEnd', fadeOutFadeIn);\n                        tab.el.style.opacity = lastTabInSection.style.opacity = '0';\n                    }\n                }\n            };\n            tab.on('click', function () { return swapOnSelect(); });\n            tab.on('keyup', KeyboardUtils_1.KeyboardUtils.keypressAction(KeyboardUtils_1.KEYBOARD.ENTER, swapOnSelect));\n            tab.on('blur', function (e) {\n                if (e.relatedTarget && !_this.tabIsInDropdown(e.relatedTarget)) {\n                    _this.closeDropdown();\n                }\n            });\n        });\n    };\n    ResponsiveTabs.prototype.bindNukeEvents = function () {\n        var _this = this;\n        Dom_1.$$(this.coveoRoot).on(InitializationEvents_1.InitializationEvents.nuke, function () {\n            Dom_1.$$(document.documentElement).off('click', _this.documentClickListener);\n        });\n    };\n    ResponsiveTabs.prototype.positionPopup = function () {\n        this.dropdownContent.insertAfter(this.dropdownHeader.el);\n        new popper_js_1.default(this.dropdownHeader.el, this.dropdownContent.el, {\n            modifiers: {\n                preventOverflow: {\n                    boundariesElement: this.coveoRoot.el\n                }\n            }\n        });\n    };\n    ResponsiveTabs.prototype.fromDropdownToTabSection = function (tab) {\n        var lastTabInTabSection = underscore_1.last(this.tabsInTabSection);\n        if (!lastTabInTabSection) {\n            this.tabSection.prepend(tab.el);\n            return;\n        }\n        var comesAfterInitialTabOrder = this.initialTabOrder.indexOf(tab.el) > this.initialTabOrder.indexOf(lastTabInTabSection);\n        if (comesAfterInitialTabOrder) {\n            tab.insertAfter(lastTabInTabSection);\n        }\n        else {\n            tab.insertBefore(lastTabInTabSection);\n        }\n    };\n    ResponsiveTabs.prototype.getDropdownHeaderLabel = function () {\n        var dropdownHeaderLabel;\n        underscore_1.each(Dom_1.$$(this.coveoRoot.find('.coveo-tab-section')).findAll('.' + Component_1.Component.computeCssClassName(Tab_1.Tab)), function (tabElement) {\n            var tab = Component_1.Component.get(tabElement, Tab_1.Tab);\n            if (!dropdownHeaderLabel && tab && tab.options.dropdownHeaderLabel) {\n                dropdownHeaderLabel = tab.options.dropdownHeaderLabel;\n            }\n        });\n        if (!dropdownHeaderLabel) {\n            dropdownHeaderLabel = Strings_1.l(ResponsiveTabs.DROPDOWN_HEADER_LABEL_DEFAULT_VALUE);\n        }\n        return dropdownHeaderLabel;\n    };\n    ResponsiveTabs.prototype.tabIsSelected = function (tab) {\n        return Dom_1.$$(tab).hasClass('coveo-selected');\n    };\n    ResponsiveTabs.prototype.tabIsInDropdown = function (tab) {\n        return Dom_1.$$(tab).hasClass(ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS);\n    };\n    Object.defineProperty(ResponsiveTabs.prototype, \"tabsInTabSection\", {\n        get: function () {\n            var _this = this;\n            var tabsInSection = [];\n            underscore_1.each(this.tabSection.children(), function (childElement) {\n                if (Utils_1.Utils.isHtmlElement(childElement)) {\n                    var child = Dom_1.$$(childElement);\n                    var childHasTabCssClassName = child.hasClass(Component_1.Component.computeCssClassNameForType(_this.ID));\n                    if (!_this.tabIsInDropdown(child) && childHasTabCssClassName) {\n                        tabsInSection.push(child.el);\n                    }\n                }\n            });\n            return tabsInSection;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ResponsiveTabs.prototype, \"tabsInTabDropdown\", {\n        get: function () {\n            if (!this.dropdownContent) {\n                return [];\n            }\n            return this.dropdownContent.findAll(\".\" + ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ResponsiveTabs.DROPDOWN_HEADER_LABEL_DEFAULT_VALUE = 'More';\n    ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS = 'coveo-tab-dropdown';\n    ResponsiveTabs.TAB_IN_DROPDOWN_HEADER_CSS_CLASS = ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS + \"-header\";\n    ResponsiveTabs.ACTIVE_DROPDOWN_CSS_CLASS = 'coveo-dropdown-header-active';\n    return ResponsiveTabs;\n}());\nexports.ResponsiveTabs = ResponsiveTabs;\n\n\n/***/ }),\n\n/***/ 675:\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// Tab.min__aec9a3688de9d25c6748.js","import { Dom } from '../../utils/Dom';\nimport { ResponsiveDropdownContent } from './ResponsiveDropdown/ResponsiveDropdownContent';\n\nexport class ResponsiveComponentsUtils {\n  private static smallTabsClassName: string = 'coveo-small-tabs';\n  private static smallFacetClassName: string = 'coveo-small-facets';\n  private static smallRecommendationClassName: string = 'coveo-small-recommendation';\n\n  static shouldDrawFacetSlider(root: Dom, facetSliderElement: Dom): boolean {\n    return ResponsiveDropdownContent.isTargetInsideOpenedDropdown(facetSliderElement) || !this.isSmallFacetActivated(root);\n  }\n\n  static isSmallTabsActivated(root: Dom): boolean {\n    return root.hasClass(this.smallTabsClassName);\n  }\n\n  static isSmallFacetActivated(root: Dom): boolean {\n    return root.hasClass(this.smallFacetClassName);\n  }\n\n  static isSmallRecommendationActivated(root: Dom): boolean {\n    return root.hasClass(this.smallRecommendationClassName);\n  }\n\n  static activateSmallTabs(root: Dom): void {\n    root.addClass(this.smallTabsClassName);\n  }\n\n  static deactivateSmallTabs(root: Dom): void {\n    root.removeClass(this.smallTabsClassName);\n  }\n\n  static activateSmallFacet(root: Dom): void {\n    root.addClass(this.smallFacetClassName);\n  }\n\n  static deactivateSmallFacet(root: Dom): void {\n    root.removeClass(this.smallFacetClassName);\n  }\n\n  static activateSmallRecommendation(root: Dom): void {\n    root.addClass(this.smallRecommendationClassName);\n  }\n\n  static deactivateSmallRecommendation(root: Dom): void {\n    root.removeClass(this.smallRecommendationClassName);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/ResponsiveComponents/ResponsiveComponentsUtils.ts","/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.14.3\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nvar longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nvar timeoutDuration = 0;\nfor (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var css = getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);\n}\n\nfunction getWindowSizes() {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};\n  var width = sizes.width || element.clientWidth || result.right - result.left;\n  var height = sizes.height || element.clientHeight || result.bottom - result.top;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && parent.nodeName === 'HTML') {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop, 10);\n    var marginLeft = parseFloat(styles.marginLeft, 10);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var styles = getComputedStyle(element);\n  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroy the popper\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicity asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger onUpdate callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  // Avoid blurry text by using full pixel integers.\n  // For pixel-perfect positioning, top/bottom prefers rounded\n  // values, while left/right prefers floored values.\n  var offsets = {\n    left: Math.floor(popper.left),\n    top: Math.round(popper.top),\n    bottom: Math.round(popper.bottom),\n    right: Math.floor(popper.right)\n  };\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    top = -offsetParentRect.height + offsets.bottom;\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    left = -offsetParentRect.width + offsets.right;\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjuction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-right` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unitless, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the height.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * An scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper this makes sure the popper has always a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier, can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near eachothers\n   * without leaving any gap between the two. Expecially useful when the arrow is\n   * enabled and you want to assure it to point to its reference element.\n   * It cares only about the first axis, you can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjuction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations).\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position,\n     * the popper will never be placed outside of the defined boundaries\n     * (except if keepTogether is enabled)\n     */\n    boundariesElement: 'viewport'\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define you own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3d transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties.\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the informations used by Popper.js\n * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overriden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass as 3rd argument an object with the same\n * structure of this object, example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated, this callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Create a new Popper.js instance\n   * @class Popper\n   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper.\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedule an update, it will run on the next UI update available\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\nexport default Popper;\n//# sourceMappingURL=popper.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/popper.js/dist/esm/popper.js\n// module id = 173\n// module chunks = 1 3 4 5 6 18 22 39 88","import 'styling/_Tab';\nimport { each, indexOf, map } from 'underscore';\nimport { InitializationEvents } from '../../events/InitializationEvents';\nimport { IBuildingQueryEventArgs, QueryEvents } from '../../events/QueryEvents';\nimport { exportGlobally } from '../../GlobalExports';\nimport { Assert } from '../../misc/Assert';\nimport { IAttributeChangedEventArg, MODEL_EVENTS } from '../../models/Model';\nimport { QueryStateModel, QUERY_STATE_ATTRIBUTES } from '../../models/QueryStateModel';\nimport { SearchEndpoint } from '../../rest/SearchEndpoint';\nimport { AccessibleButton } from '../../utils/AccessibleButton';\nimport { $$ } from '../../utils/Dom';\nimport { Utils } from '../../utils/Utils';\nimport { analyticsActionCauseList, IAnalyticsInterfaceChange } from '../Analytics/AnalyticsActionListMeta';\nimport { Component } from '../Base/Component';\nimport { IComponentBindings } from '../Base/ComponentBindings';\nimport { ComponentOptions } from '../Base/ComponentOptions';\nimport { IQueryExpression } from '../Base/IComponentOptions';\nimport { Initialization } from '../Base/Initialization';\nimport { ResponsiveTabs } from '../ResponsiveComponents/ResponsiveTabs';\nimport { ValidLayout } from '../ResultLayoutSelector/ValidLayout';\n\nexport interface ITabOptions {\n  expression?: IQueryExpression;\n  constant?: boolean;\n  id?: string;\n  icon?: string;\n  caption?: string;\n  sort?: string;\n  layout?: string;\n  endpoint?: SearchEndpoint;\n  enableDuplicateFiltering?: boolean;\n  pipeline?: string;\n  maximumAge?: number;\n  enableResponsiveMode?: boolean;\n  dropdownHeaderLabel?: string;\n}\n\n/**\n * The Tab component renders a widget that allows the end user to select a specific search interface.\n *\n * This component attaches itself to a `div` element. It is in charge of adding an advanced expression to the outgoing\n * query in order to refine the results.\n *\n * The Tab component can also hide and show different parts of the UI. For each individual component in the UI, you can\n * specify whether you wish to include or exclude that component when the user selects a certain Tab (see [Using Components\n * Only on Specific Tabs](https://docs.coveo.com/en/508/javascript-search-framework/using-components-only-on-specific-tabs)).\n *\n * **Setting a New Endpoint for a Tab:**\n *\n * A Tab can use a custom endpoint when performing a query. Of course, you need to make sure that the endpoint exists in\n * the array of Coveo.SearchEndpoint.endpoints (see {@link SearchEndpoint.endpoints}).\n *\n * ```\n * Coveo.SearchEndpoint.endpoints[\"specialEndpoint\"] = new Coveo.SearchEndpoint({\n *     restUri : 'https://somewhere.com/rest/search'\n * })\n *\n * [ ... ]\n *\n * <div class='CoveoTab' data-endpoint='specialEndpoint'></div>\n *\n * ```\n */\nexport class Tab extends Component {\n  static ID = 'Tab';\n\n  static doExport = () => {\n    exportGlobally({\n      Tab: Tab\n    });\n  };\n\n  /**\n   * The options for a Tab\n   * @componentOptions\n   */\n  static options: ITabOptions = {\n    /**\n     * Specifies a unique ID for the Tab.\n     *\n     * Specifying a value for this option is necessary for this component to work.\n     */\n    id: ComponentOptions.buildStringOption({ required: true, section: 'Common Options' }),\n\n    /**\n     * Specifies the caption of the Tab.\n     *\n     * Specifying a value for this option is necessary for this component to work.\n     */\n    caption: ComponentOptions.buildLocalizedStringOption({ required: true, section: 'Common Options' }),\n\n    /**\n     * Specifies an icon to use for the Tab.\n     *\n     * @deprecated This options is mostly kept for legacy reasons. If possible, you should avoid using it.\n     */\n    icon: ComponentOptions.buildStringOption(),\n\n    /**\n     * Specifies an advanced expression or filter that the Tab should add to any outgoing query.\n     *\n     * **Example:**\n     *\n     * `@objecttype==Message`\n     *\n     * Default value is `undefined` and the Tab applies no additional expression or filter to the query.\n     */\n    expression: ComponentOptions.buildQueryExpressionOption({ section: 'Common Options' }),\n\n    /**\n     * Specifies the {@link SearchEndpoint} to point to when performing queries from within the Tab.\n     *\n     * By default, the Tab uses the \"default\" endpoint.\n     */\n    endpoint: ComponentOptions.buildCustomOption(endpoint => (endpoint != null ? SearchEndpoint.endpoints[endpoint] : null)),\n\n    /**\n     * Specifies the default sort criteria to use when selecting the Tab. A {@link Sort} component with the same\n     * parameter needs to be present in the search interface in order for this option to function properly.\n     *\n     * **Examples:**\n     *\n     * - `data-sort='relevancy'`\n     * - `data-sort='date descending'`\n     *\n     * Default value is `undefined` and the normal {@link Sort} component behavior applies.\n     */\n    sort: ComponentOptions.buildStringOption(),\n\n    /**\n     * Specifies the default layout to display when the user selects the Tab (see {@link ResultList.options.layout} and\n     * {@link ResultLayout}).\n     *\n     * See the {@link ValidLayout} type for the list of possible values.\n     *\n     * If not specified, it will default to 'list'.\n     *\n     * See also [Result Layouts](https://docs.coveo.com/en/360/).\n     *\n     * Default value is `undefined` and the component selects the first available layout.\n     */\n    layout: ComponentOptions.buildStringOption<ValidLayout>(),\n\n    /**\n     * Specifies whether to include the {@link Tab.options.expression} in the constant part of the query.\n     *\n     * The index specially optimizes the constant part of the query to execute faster. However, you must be careful not\n     * to include dynamic query expressions, otherwise the cache will lose its efficiency.\n     *\n     * Default value is `true`.\n     */\n    constant: ComponentOptions.buildBooleanOption({ defaultValue: true, section: 'Filtering' }),\n\n    /**\n     * Whether to filter out duplicates, so that items resembling one another only appear once in the query results.\n     *\n     * **Notes:**\n     * - Two items must be at least 85% similar to one another to be considered duplicates.\n     * - When a pair of duplicates is found, only the higher-ranked item of the two is kept in the result set.\n     * - Enabling this feature can make the total result count less precise, as only the requested page of query results is submitted to duplicate filtering.\n     * - The default value for this option can be modified through the {@link SearchInterface} component.\n     */\n    enableDuplicateFiltering: ComponentOptions.buildBooleanOption({ defaultValue: false }),\n\n    /**\n     * Specifies the name of the query pipeline to use for the queries when the Tab is selected.\n     *\n     * You can specify a value for this option if your index is in a Coveo Cloud organization in which pipelines have\n     * been created (see [Adding and Managing Query Pipelines](https://docs.coveo.com/en/1791/)).\n     *\n     * Default value is `undefined`, which means that pipeline selection conditions defined in the Coveo Cloud\n     * organization apply.\n     */\n    pipeline: ComponentOptions.buildStringOption(),\n\n    /**\n     * Specifies the maximum age (in milliseconds) that cached query results can have to still be usable as results\n     * instead of performing a new query on the index from within the Tab. The cache is located in the Coveo Search API\n     * (which resides between the index and the search interface).\n     *\n     * If cached results that are older than the age you specify in this option are available, a new query will be\n     * performed on the index anyhow.\n     *\n     * On high-volume public web sites, specifying a higher value for this option can greatly improve query response\n     * time at the cost of result freshness.\n     *\n     * **Note:**\n     *\n     * > It is also possible to set a maximum cache age for the entire {@link SearchInterface} rather than for a single\n     * > Tab (see {@link SearchInterface.options.maximumAge}).\n     *\n     * Default value is `undefined` and the Coveo Search API determines the maximum cache age. This is typically\n     * equivalent to 30 minutes (see [maximumAge](https://docs.coveo.com/en/1461/#RestQueryParameters-maximumAge)).\n     */\n    maximumAge: ComponentOptions.buildNumberOption(),\n\n    /**\n     * Specifies whether to enable responsive mode for tabs. Responsive mode makes overflowing tabs disappear, instead\n     * making them available using a dropdown button. Responsive tabs are enabled either when tabs overflow or when the\n     * width of the search interface becomes too small.\n     *\n     * Disabling responsive mode for one Tab also disables it for all tabs. Therefore, you only need to set this option\n     * to `false` on one Tab to disable responsive mode.\n     *\n     * Default value is `true`.\n     *\n     * @availablesince [October 2016 Release (v1.1550.5)](https://docs.coveo.com/en/309/#october-2016-release-v115505)\n     */\n    enableResponsiveMode: ComponentOptions.buildBooleanOption({ defaultValue: true, section: 'ResponsiveOptions' }),\n\n    /**\n     * Specifies the label of the button that allows to show the hidden tabs when in responsive mode.\n     *\n     * If more than one Tab in the search interface specifies a value for this option, then the framework uses the first\n     * occurrence of the option.\n     *\n     * The default value is `\"More\"`.\n     */\n    dropdownHeaderLabel: ComponentOptions.buildLocalizedStringOption({ section: 'ResponsiveOptions' })\n  };\n\n  /**\n   * Creates a new Tab. Binds on buildingQuery event as well as an event on click of the element.\n   * @param element The HTMLElement on which to instantiate the component. Normally a `div`.\n   * @param options The options for the Tab component.\n   * @param bindings The bindings that the component requires to function normally. If not set, these will be\n   * automatically resolved (with a slower execution time).\n   */\n  constructor(public element: HTMLElement, public options?: ITabOptions, bindings?: IComponentBindings) {\n    super(element, Tab.ID, bindings);\n\n    this.options = ComponentOptions.initComponentOptions(element, Tab, options);\n\n    this.bind.onRootElement(QueryEvents.buildingQuery, (args: IBuildingQueryEventArgs) => this.handleBuildingQuery(args));\n    this.bind.onRootElement(InitializationEvents.afterInitialization, () => this.handleAfterInitialization());\n    this.bind.onQueryState(MODEL_EVENTS.CHANGE_ONE, QUERY_STATE_ATTRIBUTES.T, (args: IAttributeChangedEventArg) =>\n      this.handleQueryStateChanged(args)\n    );\n\n    new AccessibleButton()\n      .withElement(element)\n      .withSelectAction(() => this.select())\n      .withTitle(this.options.caption)\n      .withOwner(this.bind)\n      .build();\n\n    this.render();\n    ResponsiveTabs.init(this.root, this, this.options);\n  }\n\n  /**\n   * Selects the current Tab.\n   *\n   * Also logs the `interfaceChange` event in the usage analytics with the new current {@link Tab.options.id} as metada\n   * and triggers a new query.\n   */\n  public select() {\n    if (!this.disabled) {\n      const state = {\n        t: this.options.id,\n        sort: this.options.sort || QueryStateModel.defaultAttributes.sort\n      } as any;\n\n      if (this.options.layout) {\n        state.layout = this.options.layout;\n      }\n\n      this.queryStateModel.setMultiple(state);\n\n      this.usageAnalytics.logSearchEvent<IAnalyticsInterfaceChange>(analyticsActionCauseList.interfaceChange, {\n        interfaceChangeTo: this.options.id\n      });\n      this.queryController.executeQuery();\n    }\n  }\n\n  /**\n   * Indicates whether the HTMLElement argument is included in the Tab. *Included* elements are shown when the Tab is\n   * selected, whereas *excluded* elements are not.\n   * @param element The HTMLElement to verify.\n   * @returns {boolean} `true` if the HTMLElement is included in the Tab; `false` if it is excluded.\n   */\n  public isElementIncludedInTab(element: HTMLElement): boolean {\n    Assert.exists(element);\n\n    const includedTabs = this.splitListOfTabs(element.getAttribute('data-tab'));\n    const excludedTabs = this.splitListOfTabs(element.getAttribute('data-tab-not'));\n    Assert.check(\n      !(includedTabs.length != 0 && excludedTabs.length != 0),\n      'You cannot both explicitly include and exclude an element from tabs.'\n    );\n\n    return (\n      (includedTabs.length != 0 && indexOf(includedTabs, this.options.id) != -1) ||\n      (excludedTabs.length != 0 && indexOf(excludedTabs, this.options.id) == -1) ||\n      (includedTabs.length == 0 && excludedTabs.length == 0)\n    );\n  }\n\n  private render() {\n    const icon = this.options.icon;\n    if (Utils.isNonEmptyString(icon)) {\n      const iconSpan = $$('span').el;\n      $$(iconSpan).addClass(['coveo-icon', icon]);\n      this.element.insertBefore(iconSpan, this.element.firstChild);\n    }\n\n    const caption = this.options.caption;\n    if (Utils.isNonEmptyString(caption)) {\n      const captionP = document.createElement('p');\n      $$(captionP).text(caption);\n      this.element.appendChild(captionP);\n    }\n  }\n\n  protected handleBuildingQuery(data: IBuildingQueryEventArgs) {\n    Assert.exists(data);\n    if (!this.disabled && this.isSelected()) {\n      data.queryBuilder.tab = this.options.id;\n\n      if (Utils.isNonEmptyString(this.options.expression)) {\n        if (this.options.constant) {\n          data.queryBuilder.constantExpression.add(this.options.expression);\n        } else {\n          data.queryBuilder.advancedExpression.add(this.options.expression);\n        }\n      }\n\n      if (this.options.enableDuplicateFiltering) {\n        data.queryBuilder.enableDuplicateFiltering = true;\n      }\n\n      if (this.options.pipeline != null) {\n        data.queryBuilder.pipeline = this.options.pipeline;\n      }\n\n      if (this.options.maximumAge != null) {\n        data.queryBuilder.maximumAge = this.options.maximumAge;\n      }\n    }\n  }\n\n  private handleQueryStateChanged(data: IAttributeChangedEventArg) {\n    Assert.exists(data);\n    if (!this.disabled && this.isSelected()) {\n      $$(this.element).addClass('coveo-selected');\n      this.queryController.setEndpoint(this.options.endpoint);\n      this.showAndHideAppropriateElements();\n    } else {\n      $$(this.element).removeClass('coveo-selected');\n    }\n  }\n\n  private handleAfterInitialization() {\n    if (this.isSelected() && this.options.layout) {\n      this.queryStateModel.set(QUERY_STATE_ATTRIBUTES.LAYOUT, this.options.layout);\n    }\n  }\n\n  protected isSelected(): boolean {\n    const activeTab = this.queryStateModel.get(QueryStateModel.attributesEnum.t);\n    return activeTab == this.options.id;\n  }\n\n  private showAndHideAppropriateElements() {\n    const showElements = [];\n    const hideElements = [];\n\n    each($$(this.root).findAll('[data-tab],[data-tab-not]'), element => {\n      if (this.isElementIncludedInTab(element)) {\n        this.toggleAllComponentsUnder(element, true);\n        showElements.push(element);\n      } else {\n        this.toggleAllComponentsUnder(element, false);\n        hideElements.push(element);\n      }\n    });\n\n    $$(this.root).one(QueryEvents.querySuccess, () => {\n      each(showElements, elem => $$(elem).removeClass('coveo-tab-disabled'));\n      each(hideElements, elem => $$(elem).addClass('coveo-tab-disabled'));\n    });\n  }\n\n  private splitListOfTabs(value: string): string[] {\n    if (Utils.exists(value)) {\n      return map(value.split(','), tab => Utils.trim(tab));\n    } else {\n      return [];\n    }\n  }\n\n  private toggleAllComponentsUnder(element: HTMLElement, enable: boolean) {\n    Assert.exists(element);\n\n    const togglePossibleComponent = (possibleComponent: HTMLElement) => {\n      const possibleCmp = Component.get(possibleComponent, undefined, true);\n      if (possibleCmp) {\n        if (enable) {\n          possibleCmp.enable();\n        } else {\n          possibleCmp.disable();\n        }\n      }\n    };\n\n    togglePossibleComponent(element);\n    each($$(element).findAll('*'), el => {\n      togglePossibleComponent(el);\n    });\n  }\n\n  public enable() {\n    super.enable();\n    this.element.style.display = '';\n  }\n\n  public disable() {\n    super.disable();\n    this.element.style.display = 'none';\n  }\n}\n\nInitialization.registerAutoCreateComponent(Tab);\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/Tab/Tab.ts","import * as _ from 'underscore';\n\nexport class EventsUtils {\n  private static prefixes = ['webkit', 'moz', 'MS', 'o', ''];\n\n  // eventName must be in PascalCase\n  public static addPrefixedEvent(element: HTMLElement, pascalCaseEventName: string, callback) {\n    _.each(this.prefixes, prefix => {\n      if (prefix == '') {\n        pascalCaseEventName = pascalCaseEventName.toLowerCase();\n      }\n      element.addEventListener(prefix + pascalCaseEventName, callback, false);\n    });\n  }\n\n  // eventName must be in PascalCase\n  public static removePrefixedEvent(element: HTMLElement, pascalCaseEventName: string, callback) {\n    _.each(this.prefixes, prefix => {\n      if (prefix == '') {\n        pascalCaseEventName = pascalCaseEventName.toLowerCase();\n      }\n      element.removeEventListener(prefix + pascalCaseEventName, callback, false);\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/EventsUtils.ts","import 'styling/_ResponsiveTabs';\nimport { filter, each, last } from 'underscore';\nimport { InitializationEvents } from '../../events/InitializationEvents';\nimport { Logger } from '../../misc/Logger';\nimport { l } from '../../strings/Strings';\nimport { $$, Dom } from '../../utils/Dom';\nimport { EventsUtils } from '../../utils/EventsUtils';\nimport { SVGDom } from '../../utils/SVGDom';\nimport { SVGIcons } from '../../utils/SVGIcons';\nimport { Utils } from '../../utils/Utils';\nimport { Component } from '../Base/Component';\nimport { SearchInterface } from '../SearchInterface/SearchInterface';\nimport { Tab } from '../Tab/Tab';\nimport { ResponsiveComponents } from './ResponsiveComponents';\nimport { IResponsiveComponent, IResponsiveComponentOptions, ResponsiveComponentsManager } from './ResponsiveComponentsManager';\nimport { ResponsiveComponentsUtils } from './ResponsiveComponentsUtils';\nimport { AccessibleButton } from '../../utils/AccessibleButton';\nimport Popper from 'popper.js';\nimport { KeyboardUtils, KEYBOARD } from '../../utils/KeyboardUtils';\n\nexport class ResponsiveTabs implements IResponsiveComponent {\n  private static DROPDOWN_HEADER_LABEL_DEFAULT_VALUE = 'More';\n  private static TAB_IN_DROPDOWN_CSS_CLASS = 'coveo-tab-dropdown';\n  private static TAB_IN_DROPDOWN_HEADER_CSS_CLASS = `${ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS}-header`;\n  private static ACTIVE_DROPDOWN_CSS_CLASS = 'coveo-dropdown-header-active';\n  private static logger: Logger;\n  private dropdownHeader: Dom;\n  private dropdownContent: Dom;\n  private tabSection: Dom;\n  private searchInterface: SearchInterface;\n  private dropdownHeaderLabel: string;\n  private initialTabOrder: HTMLElement[];\n\n  private documentClickListener: EventListener;\n  private dropdownClickListener: EventListener;\n  private ignoreNextDocumentClick = false;\n\n  constructor(private coveoRoot: Dom, public ID: string) {\n    this.dropdownHeaderLabel = this.getDropdownHeaderLabel();\n    this.searchInterface = <SearchInterface>Component.get(this.coveoRoot.el, SearchInterface, false);\n    this.dropdownContent = this.buildDropdownContent();\n    this.dropdownHeader = this.buildDropdownHeader();\n    this.bindDropdownContentEvents();\n    this.bindDropdownHeaderEvents();\n    this.tabSection = $$(<HTMLElement>this.coveoRoot.find('.coveo-tab-section'));\n    this.manageTabSwapping();\n    this.bindNukeEvents();\n    this.initialTabOrder = [...this.tabsInTabSection];\n  }\n\n  public static init(root: HTMLElement, component: Component, options: IResponsiveComponentOptions) {\n    this.logger = new Logger('ResponsiveTabs');\n    if (!$$(root).find('.coveo-tab-section')) {\n      this.logger.info('No element with class coveo-tab-section. Responsive tabs cannot be enabled.');\n      return;\n    }\n    ResponsiveComponentsManager.register(ResponsiveTabs, $$(root), Tab.ID, component, options);\n  }\n\n  public handleResizeEvent(): void {\n    if (this.needSmallMode() && !ResponsiveComponentsUtils.isSmallTabsActivated(this.coveoRoot)) {\n      this.changeToSmallMode();\n    } else if (!this.needSmallMode() && ResponsiveComponentsUtils.isSmallTabsActivated(this.coveoRoot)) {\n      this.changeToLargeMode();\n    }\n\n    if (this.shouldAddTabsToDropdown()) {\n      this.addTabsToDropdown();\n    } else if (this.shouldRemoveTabsFromDropdown()) {\n      this.removeTabsFromDropdown();\n    }\n\n    if (this.isDropdownOpen()) {\n      this.positionPopup();\n    }\n  }\n\n  private needSmallMode(): boolean {\n    // Ignore everything if the responsiveMode is not auto.\n    if (!this.searchInterface) {\n      return this.shouldAutoModeResolveToSmall();\n    }\n    switch (this.searchInterface.responsiveComponents.getResponsiveMode()) {\n      case 'small':\n      case 'medium':\n        return true;\n      case 'auto':\n      default:\n        return this.shouldAutoModeResolveToSmall();\n    }\n  }\n\n  private shouldAutoModeResolveToSmall() {\n    const mediumWidth = this.searchInterface\n      ? this.searchInterface.responsiveComponents.getMediumScreenWidth()\n      : new ResponsiveComponents().getMediumScreenWidth();\n    if (this.coveoRoot.width() <= mediumWidth) {\n      return true;\n    } else if (!ResponsiveComponentsUtils.isSmallTabsActivated(this.coveoRoot)) {\n      return this.isOverflowing(this.tabSection.el);\n    } else {\n      return this.isLargeFormatOverflowing();\n    }\n  }\n\n  private changeToSmallMode(): void {\n    ResponsiveComponentsUtils.activateSmallTabs(this.coveoRoot);\n  }\n\n  private changeToLargeMode(): void {\n    this.emptyDropdown();\n    this.cleanUpDropdown();\n    ResponsiveComponentsUtils.deactivateSmallTabs(this.coveoRoot);\n  }\n\n  private shouldAddTabsToDropdown(): boolean {\n    return (\n      (this.isOverflowing(this.tabSection.el) || this.tabSection.el.clientWidth === 0) &&\n      ResponsiveComponentsUtils.isSmallTabsActivated(this.coveoRoot)\n    );\n  }\n\n  private addTabsToDropdown(): void {\n    let currentTab;\n    if (!this.tabSection.find(`.${ResponsiveTabs.TAB_IN_DROPDOWN_HEADER_CSS_CLASS}`)) {\n      const facetDropdownHeader = this.tabSection.find('.coveo-facet-dropdown-header');\n      if (facetDropdownHeader) {\n        this.dropdownHeader.insertBefore(facetDropdownHeader);\n      } else {\n        this.tabSection.el.appendChild(this.dropdownHeader.el);\n      }\n    }\n    for (let i = this.initialTabOrder.length - 1; i >= 0; i--) {\n      currentTab = this.initialTabOrder[i];\n\n      if (this.tabIsSelected(currentTab) && i > 0) {\n        currentTab = this.initialTabOrder[--i];\n      }\n\n      this.addToDropdownIfNeeded(currentTab);\n\n      if (!this.isOverflowing(this.tabSection.el)) {\n        break;\n      }\n    }\n  }\n\n  private shouldRemoveTabsFromDropdown(): boolean {\n    return (\n      !this.isOverflowing(this.tabSection.el) &&\n      this.tabSection.el.clientWidth !== 0 &&\n      ResponsiveComponentsUtils.isSmallTabsActivated(this.coveoRoot) &&\n      !this.isDropdownEmpty()\n    );\n  }\n\n  private removeTabsFromDropdown() {\n    const dropdownTabs = this.tabsInTabDropdown;\n\n    let current: HTMLElement;\n    while (!this.isOverflowing(this.tabSection.el) && !this.isDropdownEmpty()) {\n      current = dropdownTabs.shift();\n      this.removeFromDropdownIfNeeded(current);\n      this.fromDropdownToTabSection($$(current));\n    }\n\n    if (this.isOverflowing(this.tabSection.el)) {\n      const unselectedTabs = filter(this.tabsInTabSection, tab => !this.tabIsSelected(tab));\n      this.addToDropdownIfNeeded(unselectedTabs.pop());\n    }\n\n    if (this.isDropdownEmpty()) {\n      this.cleanUpDropdown();\n    }\n  }\n\n  private emptyDropdown(): void {\n    if (!this.isDropdownEmpty()) {\n      const dropdownTabs = this.tabsInTabDropdown;\n      while (!this.isDropdownEmpty()) {\n        const current = dropdownTabs.shift();\n        this.removeFromDropdownIfNeeded(current);\n      }\n      this.initialTabOrder.forEach(tab => this.tabSection.append(tab));\n    }\n  }\n\n  private isLargeFormatOverflowing(): boolean {\n    const virtualTabSection = $$(<HTMLElement>this.tabSection.el.cloneNode(true));\n\n    const dropdownHeader = virtualTabSection.find(`.${ResponsiveTabs.TAB_IN_DROPDOWN_HEADER_CSS_CLASS}`);\n    if (dropdownHeader) {\n      virtualTabSection.el.removeChild(dropdownHeader);\n    }\n\n    virtualTabSection.el.style.position = 'absolute';\n    virtualTabSection.el.style.visibility = 'hidden';\n\n    if (!this.isDropdownEmpty()) {\n      each(this.dropdownContent.findAll('.CoveoTab'), tab => {\n        virtualTabSection.el.appendChild(tab.cloneNode(true));\n      });\n    }\n    virtualTabSection.insertBefore(this.tabSection.el);\n\n    ResponsiveComponentsUtils.deactivateSmallTabs(this.coveoRoot);\n    const isOverflowing = this.isOverflowing(this.tabSection.el) || this.isOverflowing(virtualTabSection.el);\n    ResponsiveComponentsUtils.activateSmallTabs(this.coveoRoot);\n\n    virtualTabSection.detach();\n    return isOverflowing;\n  }\n\n  private isOverflowing(el: HTMLElement) {\n    return el.clientWidth < el.scrollWidth;\n  }\n\n  private buildDropdownHeader(): Dom {\n    const dropdownHeader = $$('a', { className: `coveo-dropdown-header ${ResponsiveTabs.TAB_IN_DROPDOWN_HEADER_CSS_CLASS}` });\n    const content = $$('p');\n    content.text(this.dropdownHeaderLabel);\n    const icon = $$('span', { className: 'coveo-more-tabs' }, SVGIcons.icons.arrowDown);\n    SVGDom.addClassToSVGInContainer(icon.el, 'coveo-more-tabs-svg');\n    content.el.appendChild(icon.el);\n    dropdownHeader.el.appendChild(content.el);\n    return dropdownHeader;\n  }\n\n  private bindDropdownHeaderEvents() {\n    const toggle = (event: Event) => {\n      if (this.isDropdownOpen()) {\n        this.closeDropdown();\n      } else {\n        this.openDropdown();\n      }\n\n      if (event.type === 'click') {\n        this.ignoreNextDocumentClick = true;\n      }\n    };\n    new AccessibleButton()\n      .withElement(this.dropdownHeader)\n      .withSelectAction(toggle)\n      .withLabel(this.getDropdownHeaderLabel())\n      .build();\n  }\n\n  private buildDropdownContent() {\n    const dropdownContent = $$('div', {\n      className: 'coveo-tab-list-container ' + SearchInterface.SMALL_INTERFACE_CLASS_NAME\n    });\n    const contentList = $$('ol', { className: 'coveo-tab-list' });\n    dropdownContent.el.appendChild(contentList.el);\n    return dropdownContent;\n  }\n\n  private bindDropdownContentEvents() {\n    this.dropdownClickListener = () => {\n      if (this.isDropdownOpen()) {\n        this.ignoreNextDocumentClick = true;\n      }\n    };\n\n    this.documentClickListener = event => {\n      if (!this.ignoreNextDocumentClick) {\n        this.closeDropdown();\n      }\n      this.ignoreNextDocumentClick = false;\n    };\n    $$(this.dropdownHeader).on('click', this.dropdownClickListener);\n    $$(this.dropdownContent).on('click', this.dropdownClickListener);\n  }\n\n  private isDropdownOpen(): boolean {\n    return this.dropdownHeader.hasClass(ResponsiveTabs.ACTIVE_DROPDOWN_CSS_CLASS);\n  }\n\n  private closeDropdown(): void {\n    $$(document.documentElement).off('click', this.documentClickListener);\n    this.dropdownContent.detach();\n    this.dropdownHeader.removeClass(ResponsiveTabs.ACTIVE_DROPDOWN_CSS_CLASS);\n  }\n\n  private openDropdown(): void {\n    $$(document.documentElement).on('click', this.documentClickListener);\n    this.positionPopup();\n    this.dropdownHeader.addClass(ResponsiveTabs.ACTIVE_DROPDOWN_CSS_CLASS);\n  }\n\n  private addToDropdownIfNeeded(tab: HTMLElement) {\n    if (!this.canAddTabToDropdown(tab)) {\n      return;\n    }\n\n    $$(tab).addClass(ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS);\n    const list = $$(this.dropdownContent.find('ol'));\n    const listElement = $$('li', null, tab);\n    list.prepend(listElement.el);\n  }\n\n  private removeFromDropdownIfNeeded(tab: HTMLElement) {\n    if (!this.canRemoveTabFromDropdown(tab)) {\n      return;\n    }\n\n    $$(tab as HTMLElement).removeClass(ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS);\n    $$(tab.parentElement).detach();\n  }\n\n  private canAddTabToDropdown(tab: HTMLElement) {\n    return tab && !this.tabIsInDropdown(tab) && this.dropdownHeader;\n  }\n\n  private canRemoveTabFromDropdown(tab: HTMLElement) {\n    return tab && this.tabIsInDropdown(tab) && this.dropdownContent;\n  }\n\n  private cleanUpDropdown() {\n    this.dropdownHeader.removeClass(ResponsiveTabs.ACTIVE_DROPDOWN_CSS_CLASS);\n    this.dropdownHeader.detach();\n    this.dropdownContent.detach();\n  }\n\n  private isDropdownEmpty(): boolean {\n    if (this.dropdownContent) {\n      const tabs = this.dropdownContent.findAll('.CoveoTab');\n      return tabs.length == 0;\n    }\n    return false;\n  }\n\n  private manageTabSwapping() {\n    each(this.coveoRoot.findAll('.' + Component.computeCssClassNameForType(this.ID)), tabElement => {\n      const tab = $$(tabElement);\n      const fadeOutFadeIn = event => {\n        const lastTabInSection = this.tabsInTabSection.pop();\n\n        if (event.propertyName == 'opacity') {\n          if (tab.el.style.opacity == '0') {\n            $$(lastTabInSection).addClass(ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS);\n            tab.replaceWith(lastTabInSection);\n            tab.removeClass(ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS);\n\n            this.fromDropdownToTabSection(tab);\n\n            // Because of the DOM manipulation, sometimes the animation will not trigger. Accessing the computed styles makes sure\n            // the animation will happen.\n            window.getComputedStyle(tab.el).opacity;\n            window.getComputedStyle(lastTabInSection).opacity;\n\n            tab.el.style.opacity = lastTabInSection.style.opacity = '1';\n          } else if (tab.el.style.opacity == '1') {\n            this.closeDropdown();\n            EventsUtils.removePrefixedEvent(tab.el, 'TransitionEnd', fadeOutFadeIn);\n            this.handleResizeEvent();\n          }\n        }\n      };\n\n      const swapOnSelect = () => {\n        if (this.tabIsInDropdown(tab)) {\n          let lastTabInSection = this.tabsInTabSection.pop();\n          if (lastTabInSection) {\n            EventsUtils.addPrefixedEvent(tab.el, 'TransitionEnd', fadeOutFadeIn);\n            tab.el.style.opacity = lastTabInSection.style.opacity = '0';\n          }\n        }\n      };\n\n      tab.on('click', () => swapOnSelect());\n      tab.on('keyup', KeyboardUtils.keypressAction(KEYBOARD.ENTER, swapOnSelect));\n      tab.on('blur', (e: FocusEvent) => {\n        if (e.relatedTarget && !this.tabIsInDropdown(e.relatedTarget as HTMLElement)) {\n          this.closeDropdown();\n        }\n      });\n    });\n  }\n\n  private bindNukeEvents() {\n    $$(this.coveoRoot).on(InitializationEvents.nuke, () => {\n      $$(document.documentElement).off('click', this.documentClickListener);\n    });\n  }\n\n  private positionPopup() {\n    this.dropdownContent.insertAfter(this.dropdownHeader.el);\n\n    new Popper(this.dropdownHeader.el, this.dropdownContent.el, {\n      modifiers: {\n        preventOverflow: {\n          boundariesElement: this.coveoRoot.el\n        }\n      }\n    });\n  }\n\n  private fromDropdownToTabSection(tab: Dom) {\n    const lastTabInTabSection = last(this.tabsInTabSection);\n    if (!lastTabInTabSection) {\n      this.tabSection.prepend(tab.el);\n      return;\n    }\n\n    const comesAfterInitialTabOrder = this.initialTabOrder.indexOf(tab.el) > this.initialTabOrder.indexOf(lastTabInTabSection);\n    if (comesAfterInitialTabOrder) {\n      tab.insertAfter(lastTabInTabSection);\n    } else {\n      tab.insertBefore(lastTabInTabSection);\n    }\n  }\n\n  private getDropdownHeaderLabel() {\n    let dropdownHeaderLabel: string;\n    each($$(this.coveoRoot.find('.coveo-tab-section')).findAll('.' + Component.computeCssClassName(Tab)), tabElement => {\n      const tab = <Tab>Component.get(tabElement, Tab);\n      if (!dropdownHeaderLabel && tab && tab.options.dropdownHeaderLabel) {\n        dropdownHeaderLabel = tab.options.dropdownHeaderLabel;\n      }\n    });\n\n    if (!dropdownHeaderLabel) {\n      dropdownHeaderLabel = l(ResponsiveTabs.DROPDOWN_HEADER_LABEL_DEFAULT_VALUE);\n    }\n\n    return dropdownHeaderLabel;\n  }\n\n  private tabIsSelected(tab: Dom | HTMLElement) {\n    return $$(tab as HTMLElement).hasClass('coveo-selected');\n  }\n\n  private tabIsInDropdown(tab: Dom | HTMLElement) {\n    return $$(tab as HTMLElement).hasClass(ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS);\n  }\n\n  private get tabsInTabSection(): HTMLElement[] {\n    const tabsInSection = [];\n    each(this.tabSection.children(), childElement => {\n      if (Utils.isHtmlElement(childElement)) {\n        const child = $$(childElement);\n        const childHasTabCssClassName = child.hasClass(Component.computeCssClassNameForType(this.ID));\n        if (!this.tabIsInDropdown(child) && childHasTabCssClassName) {\n          tabsInSection.push(child.el);\n        }\n      }\n    });\n    return tabsInSection;\n  }\n\n  private get tabsInTabDropdown(): HTMLElement[] {\n    if (!this.dropdownContent) {\n      return [];\n    }\n    return this.dropdownContent.findAll(`.${ResponsiveTabs.TAB_IN_DROPDOWN_CSS_CLASS}`);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/ResponsiveComponents/ResponsiveTabs.ts"],"sourceRoot":""}