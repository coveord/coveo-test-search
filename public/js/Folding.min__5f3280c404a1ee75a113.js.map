{"version":3,"sources":["Folding.min__5f3280c404a1ee75a113.js","./src/ui/Folding/Folding.ts","./src/ui/Sort/SortCriteria.ts"],"names":["webpackJsonpCoveo__temporary","187","module","exports","__webpack_require__","__extends","this","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","element","options","bindings","Folding","ID","ComponentOptions","initComponentOptions","Assert","check","Utils","isCoveoField","field","exists","maximumExpandedResults","swapParentChildFoldingFields","bind","onRootElement","QueryEvents","buildingQuery","handleBuildingQuery","preprocessResults","handlepreprocessResults","_this","foldWithParent","queryResults","rootNode","score","Number","NEGATIVE_INFINITY","children","result","raw","each","queryResult","i","resultNode","findUniqueId","uniqueId","parentResult","push","parent","Math","min","without","POSITIVE_INFINITY","rootResult","resultNodeToQueryResult","attachments","attachment","defaultGetResult","results","childResults","unshift","topResult","shift","defaultGetMoreResults","map","sortBy","resultNodes","length","childField","logger","warn","parentField","child","data","disabled","queryBuilder","filterField","filterFieldRange","range","requiredFields","_folded","getResult","rearrange","forEach","getFieldValue","sort","shouldBeReversed","reverse","addLoadMoreHandler","query","direction","any","childResult","isNullOrUndefined","originalQuery","enableExpand","moreResults","clone","builder","QueryBuilder","numberOfResults","fieldValue","isNonEmptyString","advancedExpression","addFieldExpression","aq","build","q","enableQuerySyntax","expandExpression","cq","firstResult","putInQueryBuilder","sortCriteria","sortField","queryController","getEndpoint","search","then","handlePreprocessMoreResults","catch","e","error","getResults","getMoreResults","$$","trigger","preprocessMoreResults","doExport","exportGlobally","buildFieldOption","defaultValue","deprecated","buildNumberOption","buildCustomOption","SortCriteria","parse","buildBooleanOption","buildQueryExpressionOption","depend","Component","Initialization","registerAutoCreateComponent","498","VALID_SORT","VALID_DIRECTION","SortCriterion","sortIsField","isValidSort","values","sortNeedsDirection","isValidDirection","chain","contains","criteria","charAt","sortsNeedingDirection","DATE","rawCriteriaString","split","criterion","match","get","first","enumerable","configurable","toString","join","equals"],"mappings":"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","file":"Folding.min__5f3280c404a1ee75a113.js","sourcesContent":["webpackJsonpCoveo__temporary([47],{\n\n/***/ 187:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar underscore_1 = __webpack_require__(0);\r\nvar QueryEvents_1 = __webpack_require__(11);\r\nvar GlobalExports_1 = __webpack_require__(3);\r\nvar Assert_1 = __webpack_require__(5);\r\nvar Dom_1 = __webpack_require__(1);\r\nvar Utils_1 = __webpack_require__(4);\r\nvar Component_1 = __webpack_require__(7);\r\nvar ComponentOptions_1 = __webpack_require__(8);\r\nvar Initialization_1 = __webpack_require__(2);\r\nvar QueryBuilder_1 = __webpack_require__(46);\r\nvar SortCriteria_1 = __webpack_require__(498);\r\n/**\r\n * The `Folding` component makes it possible to render hierarchic representations of search results sharing a common\r\n * [`field`]{@link Folding.options.field}.\r\n *\r\n * This component has no visual impact on its own. It simply folds certain search results so that the\r\n * [`ResultFolding`]{@link ResultFolding} and [`ResultAttachments`]{@link ResultAttachments} components can then nicely\r\n * render them within result templates (see [Result Templates](https://docs.coveo.com/en/413/)).\r\n *\r\n * A typical use case of the `Folding` component is to fold email conversations and message board threads results in a\r\n * result set in order to display them in a convenient format. Messages belonging to a single conversation typically\r\n * have a unique conversation ID. By indexing this ID on a field, you can use it to fold search results (see\r\n * [Folding Results](https://docs.coveo.com/en/428/)).\r\n *\r\n * **Note:**\r\n * > There can only be one `Folding` component per [`Tab`]{@link Tab} component.\r\n *\r\n */\r\nvar Folding = /** @class */ (function (_super) {\r\n    __extends(Folding, _super);\r\n    /**\r\n     * Creates a new `Folding` component.\r\n     * @param element The HTMLElement on which to instantiate the component.\r\n     * @param options The options for the `Folding` component.\r\n     * @param bindings The bindings that the component requires to function normally. If not set, these will be\r\n     * automatically resolved (with a slower execution time).\r\n     */\r\n    function Folding(element, options, bindings) {\r\n        var _this = _super.call(this, element, Folding.ID, bindings) || this;\r\n        _this.element = element;\r\n        _this.options = options;\r\n        _this.options = ComponentOptions_1.ComponentOptions.initComponentOptions(element, Folding, options);\r\n        Assert_1.Assert.check(Utils_1.Utils.isCoveoField(_this.options.field), _this.options.field + ' is not a valid field');\r\n        Assert_1.Assert.exists(_this.options.maximumExpandedResults);\r\n        _this.swapParentChildFoldingFields();\r\n        _this.bind.onRootElement(QueryEvents_1.QueryEvents.buildingQuery, _this.handleBuildingQuery);\r\n        _this.bind.onRootElement(QueryEvents_1.QueryEvents.preprocessResults, _this.handlepreprocessResults);\r\n        return _this;\r\n    }\r\n    // From a list of results, return a list of results and their attachments\r\n    // We use parentResult to build a tree of result\r\n    Folding.foldWithParent = function (queryResults) {\r\n        var rootNode = {\r\n            score: Number.NEGATIVE_INFINITY,\r\n            children: [],\r\n            result: {\r\n                raw: false\r\n            }\r\n        };\r\n        underscore_1.each(queryResults, function (queryResult, i) {\r\n            var resultNode = Folding.findUniqueId(rootNode.children, queryResult.uniqueId);\r\n            // If he have no parent or is parent is him self, add it to the root\r\n            if (queryResult.parentResult == null || queryResult.parentResult.uniqueId == queryResult.uniqueId) {\r\n                // Add it only if he do not exist\r\n                if (resultNode == null) {\r\n                    resultNode = {\r\n                        result: queryResult,\r\n                        score: i,\r\n                        children: []\r\n                    };\r\n                    rootNode.children.push(resultNode);\r\n                    resultNode.parent = rootNode;\r\n                }\r\n            }\r\n            else {\r\n                // If the resultNode already exist\r\n                if (resultNode != null) {\r\n                    resultNode.score = Math.min(i, resultNode.score);\r\n                    // Remove himself from his parent because it will be added in his parent. This allowed to remove duplicate.\r\n                    resultNode.parent.children = underscore_1.without(resultNode.parent.children, resultNode);\r\n                }\r\n                else {\r\n                    resultNode = {\r\n                        result: queryResult,\r\n                        score: i,\r\n                        children: []\r\n                    };\r\n                }\r\n                var parentResult = Folding.findUniqueId(rootNode.children, queryResult.parentResult.uniqueId);\r\n                // If the parent does not already exist, create it and add it the root\r\n                if (parentResult == null) {\r\n                    parentResult = {\r\n                        result: queryResult.parentResult,\r\n                        score: Number.POSITIVE_INFINITY,\r\n                        children: []\r\n                    };\r\n                    rootNode.children.push(parentResult);\r\n                    parentResult.parent = rootNode;\r\n                }\r\n                // Add the resultNode to parent\r\n                parentResult.children.push(resultNode);\r\n                resultNode.parent = parentResult;\r\n                var parent_1 = parentResult;\r\n                while (parent_1 != null && resultNode.score < parent_1.score) {\r\n                    parent_1.score = resultNode.score;\r\n                    parent_1 = parent_1.parent;\r\n                }\r\n            }\r\n        });\r\n        var rootResult = Folding.resultNodeToQueryResult(rootNode);\r\n        // Remove the root from all results\r\n        underscore_1.each(rootResult.attachments, function (attachment) { return (attachment.parentResult = null); });\r\n        return rootResult.attachments;\r\n    };\r\n    // 99.9% of the folding case will be alright with those default functions.\r\n    // Otherwise use the options getResult and getMoreResults\r\n    Folding.defaultGetResult = function (result) {\r\n        var results = result.childResults || [];\r\n        // Add the top result at the top of the list\r\n        results.unshift(result);\r\n        // Empty childResults just to make it more clean\r\n        result.childResults = [];\r\n        // Fold those results\r\n        results = Folding.foldWithParent(results);\r\n        // The first result is the top one\r\n        var topResult = results.shift();\r\n        // All other the results are childResults\r\n        topResult.childResults = results;\r\n        return topResult;\r\n    };\r\n    Folding.defaultGetMoreResults = function (results) {\r\n        // The result are flat, just do the fold\r\n        return Folding.foldWithParent(results);\r\n    };\r\n    // Convert ResultNode to QueryResult\r\n    Folding.resultNodeToQueryResult = function (resultNode) {\r\n        var result = resultNode.result;\r\n        result.attachments = underscore_1.map(underscore_1.sortBy(resultNode.children, 'score'), Folding.resultNodeToQueryResult);\r\n        result.parentResult = resultNode.parent != null ? resultNode.parent.result : null;\r\n        return result;\r\n    };\r\n    Folding.findUniqueId = function (resultNodes, uniqueId) {\r\n        for (var i = 0; i < resultNodes.length; i++) {\r\n            if (resultNodes[i].result.uniqueId == uniqueId) {\r\n                return resultNodes[i];\r\n            }\r\n            var resultNode = Folding.findUniqueId(resultNodes[i].children, uniqueId);\r\n            if (resultNode != null) {\r\n                return resultNode;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Folding.prototype.swapParentChildFoldingFields = function () {\r\n        // Swap \"old\" childField and parentField and assign them to the \"new\" parent option\r\n        // This needs to be done because connectors push the default data in *reverse* order compared to what the index expect.\r\n        if (this.options.childField != null) {\r\n            this.logger.warn('Detecting usage of deprecated option \"childField\". Assigning it automatically to the \"parent\" option instead.');\r\n            this.logger.warn('The option definition was changed to support universal folding across all sources.');\r\n            this.logger.warn('To remove this warning, rename the \"childField\" option (data-child-field) to \"parent\" (data-parent).');\r\n            this.options.parent = this.options.childField;\r\n        }\r\n        if (this.options.parentField != null) {\r\n            this.logger.warn('Detecting usage of deprecated option \"parentField\". Assigning it automatically to the \"child\" option instead.');\r\n            this.logger.warn('The option definition was changed to support universal folding across all sources.');\r\n            this.logger.warn('To remove this warning, rename the \"parentField\" option (data-parent-field) to \"child\" (data-child).');\r\n            this.options.child = this.options.parentField;\r\n        }\r\n    };\r\n    Folding.prototype.handleBuildingQuery = function (data) {\r\n        Assert_1.Assert.exists(data);\r\n        if (!this.disabled) {\r\n            data.queryBuilder.childField = this.options.parent;\r\n            data.queryBuilder.parentField = this.options.child;\r\n            data.queryBuilder.filterField = this.options.field;\r\n            data.queryBuilder.filterFieldRange = this.options.range;\r\n            data.queryBuilder.requiredFields.push(this.options.field);\r\n            if (this.options.parent != null) {\r\n                data.queryBuilder.requiredFields.push(this.options.parent);\r\n            }\r\n            if (this.options.child != null) {\r\n                data.queryBuilder.requiredFields.push(this.options.child);\r\n            }\r\n        }\r\n    };\r\n    Folding.prototype.handlepreprocessResults = function (data) {\r\n        var _this = this;\r\n        Assert_1.Assert.exists(data);\r\n        Assert_1.Assert.check(!data.results._folded, 'Two or more Folding components are active at the same time for the same Tab. Cannot process the results.');\r\n        data.results._folded = true;\r\n        var queryResults = data.results;\r\n        var getResult = this.options.getResult || Folding.defaultGetResult;\r\n        queryResults.results = underscore_1.map(queryResults.results, getResult);\r\n        if (this.options.rearrange) {\r\n            queryResults.results.forEach(function (result) {\r\n                result.childResults = underscore_1.sortBy(result.childResults, function (result) { return Utils_1.Utils.getFieldValue(result, _this.options.rearrange.sort); });\r\n                if (_this.shouldBeReversed(result.childResults)) {\r\n                    result.childResults = result.childResults.reverse();\r\n                }\r\n            });\r\n        }\r\n        this.addLoadMoreHandler(queryResults.results, data.query);\r\n    };\r\n    Folding.prototype.shouldBeReversed = function (childResults) {\r\n        var _this = this;\r\n        if (this.options.rearrange.direction == 'ascending') {\r\n            return false;\r\n        }\r\n        var childMissingSortByValue = underscore_1.any(childResults, function (childResult) {\r\n            return Utils_1.Utils.isNullOrUndefined(Utils_1.Utils.getFieldValue(childResult, _this.options.rearrange.sort));\r\n        });\r\n        if (childMissingSortByValue) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    Folding.prototype.addLoadMoreHandler = function (results, originalQuery) {\r\n        var _this = this;\r\n        return underscore_1.map(results, function (result) {\r\n            if (_this.options.enableExpand && !Utils_1.Utils.isNullOrUndefined(Utils_1.Utils.getFieldValue(result, _this.options.field))) {\r\n                result.moreResults = function () {\r\n                    return _this.moreResults(result, originalQuery);\r\n                };\r\n            }\r\n            return result;\r\n        });\r\n    };\r\n    Folding.prototype.moreResults = function (result, originalQuery) {\r\n        var _this = this;\r\n        var query = underscore_1.clone(originalQuery);\r\n        var builder = new QueryBuilder_1.QueryBuilder();\r\n        query.numberOfResults = this.options.maximumExpandedResults;\r\n        var fieldValue = Utils_1.Utils.getFieldValue(result, this.options.field);\r\n        if (Utils_1.Utils.isNonEmptyString(fieldValue)) {\r\n            builder.advancedExpression.addFieldExpression(this.options.field, '=', [fieldValue]);\r\n            query.aq = builder.build().aq;\r\n        }\r\n        if (Utils_1.Utils.isNonEmptyString(originalQuery.q)) {\r\n            // We add keywords to get the highlight and we add @uri to get all results\r\n            // To ensure it plays nicely with query syntax, we ensure that the needed part of the query\r\n            // are correctly surrounded with the no syntax block\r\n            if (originalQuery.enableQuerySyntax) {\r\n                query.q = \"( \" + originalQuery.q + \" ) OR @uri\";\r\n            }\r\n            else {\r\n                query.enableQuerySyntax = true;\r\n                query.q = \"( <@- \" + originalQuery.q + \" -@> ) OR @uri\";\r\n            }\r\n        }\r\n        if (Utils_1.Utils.isNonEmptyString(this.options.expandExpression)) {\r\n            query.cq = this.options.expandExpression;\r\n        }\r\n        if (this.options.child != null) {\r\n            query.parentField = this.options.child;\r\n        }\r\n        if (this.options.parent != null) {\r\n            query.childField = this.options.parent;\r\n        }\r\n        query.filterField = null;\r\n        query.filterFieldRange = null;\r\n        query.firstResult = 0;\r\n        if (this.options.rearrange) {\r\n            this.options.rearrange.putInQueryBuilder(builder);\r\n            query.sortCriteria = builder.sortCriteria;\r\n            query.sortField = builder.sortField;\r\n        }\r\n        else {\r\n            query.sortCriteria = originalQuery.sortCriteria;\r\n            query.sortField = originalQuery.sortField;\r\n        }\r\n        return this.queryController\r\n            .getEndpoint()\r\n            .search(query)\r\n            .then(function (results) {\r\n            _this.handlePreprocessMoreResults(results);\r\n            return results.results;\r\n        })\r\n            .catch(function (e) {\r\n            _this.logger.error(\"Invalid query performed while trying to retrieve more results for folding.\", e);\r\n            return [];\r\n        });\r\n    };\r\n    Folding.prototype.handlePreprocessMoreResults = function (queryResults) {\r\n        var getResults = this.options.getMoreResults || Folding.defaultGetMoreResults;\r\n        queryResults.results = getResults(queryResults.results);\r\n        Dom_1.$$(this.element).trigger(QueryEvents_1.QueryEvents.preprocessMoreResults, {\r\n            results: queryResults\r\n        });\r\n    };\r\n    Folding.ID = 'Folding';\r\n    Folding.doExport = function () {\r\n        GlobalExports_1.exportGlobally({\r\n            Folding: Folding\r\n        });\r\n    };\r\n    /**\r\n     * The options for the component\r\n     * @componentOptions\r\n     */\r\n    Folding.options = {\r\n        /**\r\n         * Specifies the name of the field on which to do the folding.\r\n         *\r\n         * Specifying a value for this option is required for this component to work.\r\n         *\r\n         * **Note:**\r\n         * > In an Elasticsearch index, the corresponding field must be configured as a *Facet* field\r\n         * > (see [Add or Edit Fields](https://docs.coveo.com/en/1982/)).\r\n         * > This limitation does not apply to Coveo indexes.\r\n         *\r\n         * Default value is `@foldingcollection`.\r\n         */\r\n        field: ComponentOptions_1.ComponentOptions.buildFieldOption({ defaultValue: '@foldingcollection' }),\r\n        /**\r\n         * Specifies the field that determines whether a certain result is a child of another top result.\r\n         *\r\n         * **Note:**\r\n         * > In the index, the values of the corresponding field must:\r\n         * > - Contain alphanumerical characters only.\r\n         * > - Contain no more than 60 characters.\r\n         *\r\n         * Default value is `@foldingchild`.\r\n         */\r\n        child: ComponentOptions_1.ComponentOptions.buildFieldOption({ defaultValue: '@foldingchild' }),\r\n        /**\r\n         * Specifies the field that determines whether a certain result is a top result containing other child results.\r\n         *\r\n         * **Note:**\r\n         * > In the index, the values of the corresponding field must:\r\n         * > - Contain alphanumerical characters only.\r\n         * > - Contain no more than 60 characters.\r\n         *\r\n         * Default value is `@foldingparent`.\r\n         */\r\n        parent: ComponentOptions_1.ComponentOptions.buildFieldOption({ defaultValue: '@foldingparent' }),\r\n        /**\r\n         * This option is deprecated. Instead, use the {@link Folding.options.parent} option.\r\n         * @deprecated\r\n         */\r\n        childField: ComponentOptions_1.ComponentOptions.buildFieldOption({\r\n            deprecated: 'This option is deprecated. Instead, use the data-parent option.'\r\n        }),\r\n        /**\r\n         * This option is deprecated. Instead, use the {@link Folding.options.child} option.\r\n         * @deprecated\r\n         */\r\n        parentField: ComponentOptions_1.ComponentOptions.buildFieldOption({\r\n            deprecated: 'This option is deprecated. Instead, use the data-child option.'\r\n        }),\r\n        /**\r\n         * Specifies the maximum number of child results to fold.\r\n         *\r\n         * **Example:**\r\n         * > For an email thread with a total of 20 messages, using the default value of `2` means that the component loads\r\n         * > up to a maximum of 2 child messages under the original message, unless the end user expands the entire\r\n         * > conversation using the **Show More** link (see the [`enableExpand`]{@link Folding.options.enableExpand}\r\n         * > option).\r\n         *\r\n         * Default value is `2`. Minimum value is `0`.\r\n         */\r\n        range: ComponentOptions_1.ComponentOptions.buildNumberOption({ defaultValue: 2, min: 0 }),\r\n        /**\r\n         * Specifies the sort criteria to apply to the top result and its child results (e.g., `date ascending`,\r\n         * `@myfield descending`, etc.). See [sortCriteria](https://docs.coveo.com/en/1461/#RestQueryParameters-sortCriteria).\r\n         *\r\n         * This option works from the results returned by the index. This means that if only the three most relevant folded results are returned by the index\r\n         * and you choose to rearrange the folded results by date, then the three most relevant results will be rearranged by date,\r\n         * meaning that the first folded result is not necessarily the oldest or newest item.\r\n         *\r\n         * However, since clicking on the `Show More` button triggers a new query, you would receive new results based on the sort criteria of this option.\r\n         *\r\n         * **Example**\r\n         * > If you are folding email results by conversation and you specify `date descending` as the `rearrange` value of\r\n         * > the `Folding` component, the component re-arranges email conversations so that the newest email is always the\r\n         * > top result. Specifying `date ascending` instead always makes the original email the top result, as it is also\r\n         * > necessarily the oldest.\r\n         *\r\n         * By default, the component displays the results in the order that the index returns them.\r\n         */\r\n        rearrange: ComponentOptions_1.ComponentOptions.buildCustomOption(function (value) { return (Utils_1.Utils.isNonEmptyString(value) ? SortCriteria_1.SortCriteria.parse(value) : null); }),\r\n        /**\r\n         * Specifies whether to add a callback function on the top result, allowing to make an additional query to load all\r\n         * of its child results (e.g., to load all conversations of a given thread).\r\n         *\r\n         * Concretely, the [`ResultFolding`]{@link ResultFolding} component uses this for its **Show More** link.\r\n         *\r\n         * See also the [`expandExpression`]{@link Folding.options.expandExpression} and\r\n         * [`maximumExpandedResults`]{@link Folding.options.maximumExpandedResults} options.\r\n         *\r\n         * Default value is `true`.\r\n         */\r\n        enableExpand: ComponentOptions_1.ComponentOptions.buildBooleanOption({ defaultValue: true }),\r\n        /**\r\n         * If the [`enableExpand`]{@link Folding.options.enableExpand} option is `true`, specifies a custom constant\r\n         * expression to send when querying the expanded results.\r\n         *\r\n         * Default value is `undefined`.\r\n         */\r\n        expandExpression: ComponentOptions_1.ComponentOptions.buildQueryExpressionOption({ depend: 'enableExpand' }),\r\n        /**\r\n         * If the [`enableExpand`]{@link Folding.options.enableExpand} option is `true`, specifies the maximum number of\r\n         * results to load when expanding.\r\n         *\r\n         * Default value is `100`. Minimum value is `1`.\r\n         */\r\n        maximumExpandedResults: ComponentOptions_1.ComponentOptions.buildNumberOption({ defaultValue: 100, min: 1, depend: 'enableExpand' }),\r\n        /**\r\n         * Specifies the function that manages the individual folding of each result.\r\n         *\r\n         * Default value is:\r\n         *\r\n         * ```javascript\r\n         * var results = result.childResults || [];\r\n         * // Add the top result at the top of the list.\r\n         * results.unshift(result);\r\n         * // Empty childResults just to clean it.\r\n         * result.childResults = [];\r\n         * // Fold those results.\r\n         * results = Coveo.Folding.foldWithParent(results);\r\n         * // The first result is the top one.\r\n         * var topResult = results.shift();\r\n         * // All other results are childResults.\r\n         * topResult.childResults = results;\r\n         * return topResult;\r\n         * ```\r\n         *\r\n         * You can pre-process all the result with this option in the [`init`]{@link init} call of your search interface:\r\n         *\r\n         * ```javascript\r\n         * Coveo.init(document.querySelector('#search'), {\r\n         *    Folding: {\r\n         *      getResult: function(result) {\r\n         *        result = Coveo.Folding.defaultGetResult(result);\r\n         *        // Your code here\r\n         *      }\r\n         *    }\r\n         * })\r\n         * ```\r\n         */\r\n        getResult: ComponentOptions_1.ComponentOptions.buildCustomOption(function () {\r\n            return null;\r\n        }),\r\n        /**\r\n         * Specifies the function that manages the folding of all results.\r\n         *\r\n         * Default value is:\r\n         *\r\n         * ```javascript\r\n         * Coveo.Folding.defaultGetMoreResults = function(results) {\r\n         *    // The results are flat, just do the folding.\r\n         *    return Coveo.Folding.foldWithParent(results);\r\n         * }\r\n         * ```\r\n         */\r\n        getMoreResults: ComponentOptions_1.ComponentOptions.buildCustomOption(function () {\r\n            return null;\r\n        })\r\n    };\r\n    return Folding;\r\n}(Component_1.Component));\r\nexports.Folding = Folding;\r\nInitialization_1.Initialization.registerAutoCreateComponent(Folding);\r\n\n\n/***/ }),\n\n/***/ 498:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar underscore_1 = __webpack_require__(0);\r\nvar Assert_1 = __webpack_require__(5);\r\nvar VALID_SORT;\r\n(function (VALID_SORT) {\r\n    VALID_SORT[\"RELEVANCY\"] = \"relevancy\";\r\n    VALID_SORT[\"DATE\"] = \"date\";\r\n    VALID_SORT[\"QRE\"] = \"qre\";\r\n})(VALID_SORT = exports.VALID_SORT || (exports.VALID_SORT = {}));\r\nvar VALID_DIRECTION;\r\n(function (VALID_DIRECTION) {\r\n    VALID_DIRECTION[\"ASCENDING\"] = \"ascending\";\r\n    VALID_DIRECTION[\"DESCENDING\"] = \"descending\";\r\n})(VALID_DIRECTION = exports.VALID_DIRECTION || (exports.VALID_DIRECTION = {}));\r\nvar SortCriterion = /** @class */ (function () {\r\n    /**\r\n     * Create a new SortCriteria\r\n     * @param sort The sort criteria (e.g.: relevancy, date)\r\n     * @param direction The direction by which to sort (e.g.: ascending, descending)\r\n     */\r\n    function SortCriterion(sort, direction) {\r\n        if (direction === void 0) { direction = ''; }\r\n        this.sort = sort;\r\n        this.direction = direction;\r\n        if (!SortCriterion.sortIsField(sort)) {\r\n            Assert_1.Assert.check(this.isValidSort(sort), sort + \" is not a valid sort criteria. Valid values are \" + underscore_1.values(VALID_SORT) + \" or a valid index sortable index field.\");\r\n        }\r\n        if (SortCriterion.sortNeedsDirection(sort)) {\r\n            Assert_1.Assert.check(this.isValidDirection(direction), direction + \" is not a valid sort criteria direction. Valid values are \" + underscore_1.values(VALID_DIRECTION));\r\n        }\r\n        else {\r\n            Assert_1.Assert.check(direction == '');\r\n        }\r\n    }\r\n    SortCriterion.prototype.isValidDirection = function (direction) {\r\n        return underscore_1.chain(VALID_DIRECTION)\r\n            .values()\r\n            .contains(direction)\r\n            .value();\r\n    };\r\n    SortCriterion.prototype.isValidSort = function (sort) {\r\n        return underscore_1.chain(VALID_SORT)\r\n            .values()\r\n            .contains(sort)\r\n            .value();\r\n    };\r\n    SortCriterion.sortIsField = function (criteria) {\r\n        return criteria.charAt(0) == '@';\r\n    };\r\n    SortCriterion.sortNeedsDirection = function (sort) {\r\n        return underscore_1.contains(SortCriterion.sortsNeedingDirection, sort) || SortCriterion.sortIsField(sort);\r\n    };\r\n    SortCriterion.sortsNeedingDirection = [VALID_SORT.DATE];\r\n    return SortCriterion;\r\n}());\r\nexports.SortCriterion = SortCriterion;\r\nvar SortCriteria = /** @class */ (function () {\r\n    function SortCriteria(rawCriteriaString) {\r\n        var _this = this;\r\n        this.criteria = [];\r\n        var criteria = rawCriteriaString.split(';');\r\n        criteria.forEach(function (criterion) {\r\n            var split = criterion.match(/\\S+/g);\r\n            _this.criteria.push(new SortCriterion(split[0], split[1]));\r\n        });\r\n    }\r\n    Object.defineProperty(SortCriteria.prototype, \"direction\", {\r\n        get: function () {\r\n            return underscore_1.first(this.criteria).direction;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SortCriteria.prototype, \"sort\", {\r\n        get: function () {\r\n            return underscore_1.first(this.criteria).sort;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Return a new SortCriteria from a string\r\n     * @param criteria The string from which to create the SortCriteria\r\n     */\r\n    SortCriteria.parse = function (criteria) {\r\n        return new SortCriteria(criteria);\r\n    };\r\n    /**\r\n     * Put the sort criteria in the passed queryBuilder\r\n     * @param queryBuilder The queryBuilder in which to put the sort criteria.\r\n     */\r\n    SortCriteria.prototype.putInQueryBuilder = function (queryBuilder) {\r\n        Assert_1.Assert.exists(queryBuilder);\r\n        queryBuilder.sortCriteria = this.toString()\r\n            .split(';')\r\n            .join(',');\r\n    };\r\n    /**\r\n     * Returns a string representation of the sort criteria (e.g.: 'date ascending').\r\n     */\r\n    SortCriteria.prototype.toString = function () {\r\n        return this.criteria\r\n            .map(function (criterion) {\r\n            return criterion.direction ? criterion.sort + \" \" + criterion.direction : \"\" + criterion.sort;\r\n        })\r\n            .join(';');\r\n    };\r\n    /**\r\n     * Checks if the SortCriteria is equal to another.\r\n     * @param criteria The SortCriteria to compare with\r\n     */\r\n    SortCriteria.prototype.equals = function (criteria) {\r\n        return criteria.toString() == this.toString();\r\n    };\r\n    return SortCriteria;\r\n}());\r\nexports.SortCriteria = SortCriteria;\r\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// Folding.min__5f3280c404a1ee75a113.js","import { any, clone, each, map, sortBy, without } from 'underscore';\r\nimport { IBuildingQueryEventArgs, IPreprocessResultsEventArgs, QueryEvents } from '../../events/QueryEvents';\r\nimport { exportGlobally } from '../../GlobalExports';\r\nimport { Assert } from '../../misc/Assert';\r\nimport { IQuery } from '../../rest/Query';\r\nimport { IQueryResult } from '../../rest/QueryResult';\r\nimport { IQueryResults } from '../../rest/QueryResults';\r\nimport { $$ } from '../../utils/Dom';\r\nimport { Utils } from '../../utils/Utils';\r\nimport { Component } from '../Base/Component';\r\nimport { IComponentBindings } from '../Base/ComponentBindings';\r\nimport { ComponentOptions } from '../Base/ComponentOptions';\r\nimport { IFieldOption, IQueryExpression } from '../Base/IComponentOptions';\r\nimport { Initialization } from '../Base/Initialization';\r\nimport { QueryBuilder } from '../Base/QueryBuilder';\r\nimport { SortCriteria } from '../Sort/SortCriteria';\r\n\r\nexport interface IFoldingOptions {\r\n  field?: IFieldOption;\r\n  child?: IFieldOption;\r\n  parent?: IFieldOption;\r\n\r\n  childField?: IFieldOption;\r\n  parentField?: IFieldOption;\r\n\r\n  range?: number;\r\n  rearrange?: SortCriteria;\r\n\r\n  enableExpand?: boolean;\r\n  expandExpression?: IQueryExpression;\r\n  maximumExpandedResults?: number;\r\n\r\n  /**\r\n   * Manage folding for each results individually\r\n   */\r\n  getResult?: (result: IQueryResult) => IQueryResult;\r\n  /**\r\n   * Manage folding of all more results\r\n   */\r\n  getMoreResults?: (results: IQueryResult[]) => IQueryResult[];\r\n}\r\n\r\ninterface IResultNode {\r\n  score: number;\r\n  parent?: IResultNode;\r\n  result: IQueryResult;\r\n  children: IResultNode[];\r\n}\r\n\r\n/**\r\n * The `Folding` component makes it possible to render hierarchic representations of search results sharing a common\r\n * [`field`]{@link Folding.options.field}.\r\n *\r\n * This component has no visual impact on its own. It simply folds certain search results so that the\r\n * [`ResultFolding`]{@link ResultFolding} and [`ResultAttachments`]{@link ResultAttachments} components can then nicely\r\n * render them within result templates (see [Result Templates](https://docs.coveo.com/en/413/)).\r\n *\r\n * A typical use case of the `Folding` component is to fold email conversations and message board threads results in a\r\n * result set in order to display them in a convenient format. Messages belonging to a single conversation typically\r\n * have a unique conversation ID. By indexing this ID on a field, you can use it to fold search results (see\r\n * [Folding Results](https://docs.coveo.com/en/428/)).\r\n *\r\n * **Note:**\r\n * > There can only be one `Folding` component per [`Tab`]{@link Tab} component.\r\n *\r\n */\r\nexport class Folding extends Component {\r\n  static ID = 'Folding';\r\n\r\n  static doExport = () => {\r\n    exportGlobally({\r\n      Folding: Folding\r\n    });\r\n  };\r\n\r\n  /**\r\n   * The options for the component\r\n   * @componentOptions\r\n   */\r\n  static options: IFoldingOptions = {\r\n    /**\r\n     * Specifies the name of the field on which to do the folding.\r\n     *\r\n     * Specifying a value for this option is required for this component to work.\r\n     *\r\n     * **Note:**\r\n     * > In an Elasticsearch index, the corresponding field must be configured as a *Facet* field\r\n     * > (see [Add or Edit Fields](https://docs.coveo.com/en/1982/)).\r\n     * > This limitation does not apply to Coveo indexes.\r\n     *\r\n     * Default value is `@foldingcollection`.\r\n     */\r\n    field: ComponentOptions.buildFieldOption({ defaultValue: '@foldingcollection' }),\r\n    /**\r\n     * Specifies the field that determines whether a certain result is a child of another top result.\r\n     *\r\n     * **Note:**\r\n     * > In the index, the values of the corresponding field must:\r\n     * > - Contain alphanumerical characters only.\r\n     * > - Contain no more than 60 characters.\r\n     *\r\n     * Default value is `@foldingchild`.\r\n     */\r\n    child: ComponentOptions.buildFieldOption({ defaultValue: '@foldingchild' }),\r\n    /**\r\n     * Specifies the field that determines whether a certain result is a top result containing other child results.\r\n     *\r\n     * **Note:**\r\n     * > In the index, the values of the corresponding field must:\r\n     * > - Contain alphanumerical characters only.\r\n     * > - Contain no more than 60 characters.\r\n     *\r\n     * Default value is `@foldingparent`.\r\n     */\r\n    parent: ComponentOptions.buildFieldOption({ defaultValue: '@foldingparent' }),\r\n\r\n    /**\r\n     * This option is deprecated. Instead, use the {@link Folding.options.parent} option.\r\n     * @deprecated\r\n     */\r\n    childField: ComponentOptions.buildFieldOption({\r\n      deprecated: 'This option is deprecated. Instead, use the data-parent option.'\r\n    }),\r\n    /**\r\n     * This option is deprecated. Instead, use the {@link Folding.options.child} option.\r\n     * @deprecated\r\n     */\r\n    parentField: ComponentOptions.buildFieldOption({\r\n      deprecated: 'This option is deprecated. Instead, use the data-child option.'\r\n    }),\r\n\r\n    /**\r\n     * Specifies the maximum number of child results to fold.\r\n     *\r\n     * **Example:**\r\n     * > For an email thread with a total of 20 messages, using the default value of `2` means that the component loads\r\n     * > up to a maximum of 2 child messages under the original message, unless the end user expands the entire\r\n     * > conversation using the **Show More** link (see the [`enableExpand`]{@link Folding.options.enableExpand}\r\n     * > option).\r\n     *\r\n     * Default value is `2`. Minimum value is `0`.\r\n     */\r\n    range: ComponentOptions.buildNumberOption({ defaultValue: 2, min: 0 }),\r\n\r\n    /**\r\n     * Specifies the sort criteria to apply to the top result and its child results (e.g., `date ascending`,\r\n     * `@myfield descending`, etc.). See [sortCriteria](https://docs.coveo.com/en/1461/#RestQueryParameters-sortCriteria).\r\n     *\r\n     * This option works from the results returned by the index. This means that if only the three most relevant folded results are returned by the index\r\n     * and you choose to rearrange the folded results by date, then the three most relevant results will be rearranged by date,\r\n     * meaning that the first folded result is not necessarily the oldest or newest item.\r\n     *\r\n     * However, since clicking on the `Show More` button triggers a new query, you would receive new results based on the sort criteria of this option.\r\n     *\r\n     * **Example**\r\n     * > If you are folding email results by conversation and you specify `date descending` as the `rearrange` value of\r\n     * > the `Folding` component, the component re-arranges email conversations so that the newest email is always the\r\n     * > top result. Specifying `date ascending` instead always makes the original email the top result, as it is also\r\n     * > necessarily the oldest.\r\n     *\r\n     * By default, the component displays the results in the order that the index returns them.\r\n     */\r\n    rearrange: ComponentOptions.buildCustomOption(value => (Utils.isNonEmptyString(value) ? SortCriteria.parse(value) : null)),\r\n\r\n    /**\r\n     * Specifies whether to add a callback function on the top result, allowing to make an additional query to load all\r\n     * of its child results (e.g., to load all conversations of a given thread).\r\n     *\r\n     * Concretely, the [`ResultFolding`]{@link ResultFolding} component uses this for its **Show More** link.\r\n     *\r\n     * See also the [`expandExpression`]{@link Folding.options.expandExpression} and\r\n     * [`maximumExpandedResults`]{@link Folding.options.maximumExpandedResults} options.\r\n     *\r\n     * Default value is `true`.\r\n     */\r\n    enableExpand: ComponentOptions.buildBooleanOption({ defaultValue: true }),\r\n    /**\r\n     * If the [`enableExpand`]{@link Folding.options.enableExpand} option is `true`, specifies a custom constant\r\n     * expression to send when querying the expanded results.\r\n     *\r\n     * Default value is `undefined`.\r\n     */\r\n    expandExpression: ComponentOptions.buildQueryExpressionOption({ depend: 'enableExpand' }),\r\n\r\n    /**\r\n     * If the [`enableExpand`]{@link Folding.options.enableExpand} option is `true`, specifies the maximum number of\r\n     * results to load when expanding.\r\n     *\r\n     * Default value is `100`. Minimum value is `1`.\r\n     */\r\n    maximumExpandedResults: ComponentOptions.buildNumberOption({ defaultValue: 100, min: 1, depend: 'enableExpand' }),\r\n\r\n    /**\r\n     * Specifies the function that manages the individual folding of each result.\r\n     *\r\n     * Default value is:\r\n     *\r\n     * ```javascript\r\n     * var results = result.childResults || [];\r\n     * // Add the top result at the top of the list.\r\n     * results.unshift(result);\r\n     * // Empty childResults just to clean it.\r\n     * result.childResults = [];\r\n     * // Fold those results.\r\n     * results = Coveo.Folding.foldWithParent(results);\r\n     * // The first result is the top one.\r\n     * var topResult = results.shift();\r\n     * // All other results are childResults.\r\n     * topResult.childResults = results;\r\n     * return topResult;\r\n     * ```\r\n     *\r\n     * You can pre-process all the result with this option in the [`init`]{@link init} call of your search interface:\r\n     *\r\n     * ```javascript\r\n     * Coveo.init(document.querySelector('#search'), {\r\n     *    Folding: {\r\n     *      getResult: function(result) {\r\n     *        result = Coveo.Folding.defaultGetResult(result);\r\n     *        // Your code here\r\n     *      }\r\n     *    }\r\n     * })\r\n     * ```\r\n     */\r\n    getResult: ComponentOptions.buildCustomOption<(result: IQueryResult) => IQueryResult>(() => {\r\n      return null;\r\n    }),\r\n\r\n    /**\r\n     * Specifies the function that manages the folding of all results.\r\n     *\r\n     * Default value is:\r\n     *\r\n     * ```javascript\r\n     * Coveo.Folding.defaultGetMoreResults = function(results) {\r\n     *    // The results are flat, just do the folding.\r\n     *    return Coveo.Folding.foldWithParent(results);\r\n     * }\r\n     * ```\r\n     */\r\n    getMoreResults: ComponentOptions.buildCustomOption<(results: IQueryResult[]) => IQueryResult[]>(() => {\r\n      return null;\r\n    })\r\n  };\r\n\r\n  /**\r\n   * Creates a new `Folding` component.\r\n   * @param element The HTMLElement on which to instantiate the component.\r\n   * @param options The options for the `Folding` component.\r\n   * @param bindings The bindings that the component requires to function normally. If not set, these will be\r\n   * automatically resolved (with a slower execution time).\r\n   */\r\n  constructor(public element: HTMLElement, public options: IFoldingOptions, bindings?: IComponentBindings) {\r\n    super(element, Folding.ID, bindings);\r\n\r\n    this.options = ComponentOptions.initComponentOptions(element, Folding, options);\r\n\r\n    Assert.check(Utils.isCoveoField(<string>this.options.field), this.options.field + ' is not a valid field');\r\n    Assert.exists(this.options.maximumExpandedResults);\r\n\r\n    this.swapParentChildFoldingFields();\r\n\r\n    this.bind.onRootElement(QueryEvents.buildingQuery, this.handleBuildingQuery);\r\n    this.bind.onRootElement(QueryEvents.preprocessResults, this.handlepreprocessResults);\r\n  }\r\n\r\n  // From a list of results, return a list of results and their attachments\r\n  // We use parentResult to build a tree of result\r\n  static foldWithParent(queryResults: IQueryResult[]): IQueryResult[] {\r\n    const rootNode: IResultNode = {\r\n      score: Number.NEGATIVE_INFINITY,\r\n      children: [],\r\n      result: <IQueryResult>{\r\n        raw: false\r\n      }\r\n    };\r\n\r\n    each(queryResults, (queryResult: IQueryResult, i: number) => {\r\n      let resultNode = Folding.findUniqueId(rootNode.children, queryResult.uniqueId);\r\n      // If he have no parent or is parent is him self, add it to the root\r\n      if (queryResult.parentResult == null || queryResult.parentResult.uniqueId == queryResult.uniqueId) {\r\n        // Add it only if he do not exist\r\n        if (resultNode == null) {\r\n          resultNode = {\r\n            result: queryResult,\r\n            score: i,\r\n            children: []\r\n          };\r\n          rootNode.children.push(resultNode);\r\n          resultNode.parent = rootNode;\r\n        }\r\n      } else {\r\n        // If the resultNode already exist\r\n        if (resultNode != null) {\r\n          resultNode.score = Math.min(i, resultNode.score);\r\n          // Remove himself from his parent because it will be added in his parent. This allowed to remove duplicate.\r\n          resultNode.parent.children = without(resultNode.parent.children, resultNode);\r\n        } else {\r\n          resultNode = {\r\n            result: queryResult,\r\n            score: i,\r\n            children: []\r\n          };\r\n        }\r\n\r\n        let parentResult = Folding.findUniqueId(rootNode.children, queryResult.parentResult.uniqueId);\r\n        // If the parent does not already exist, create it and add it the root\r\n        if (parentResult == null) {\r\n          parentResult = {\r\n            result: queryResult.parentResult,\r\n            score: Number.POSITIVE_INFINITY,\r\n            children: []\r\n          };\r\n          rootNode.children.push(parentResult);\r\n          parentResult.parent = rootNode;\r\n        }\r\n        // Add the resultNode to parent\r\n        parentResult.children.push(resultNode);\r\n        resultNode.parent = parentResult;\r\n        let parent = parentResult;\r\n        while (parent != null && resultNode.score < parent.score) {\r\n          parent.score = resultNode.score;\r\n          parent = parent.parent;\r\n        }\r\n      }\r\n    });\r\n    const rootResult = Folding.resultNodeToQueryResult(rootNode);\r\n    // Remove the root from all results\r\n    each(rootResult.attachments, attachment => (attachment.parentResult = null));\r\n    return rootResult.attachments;\r\n  }\r\n\r\n  // 99.9% of the folding case will be alright with those default functions.\r\n  // Otherwise use the options getResult and getMoreResults\r\n  public static defaultGetResult(result: IQueryResult) {\r\n    let results: IQueryResult[] = result.childResults || [];\r\n    // Add the top result at the top of the list\r\n    results.unshift(result);\r\n    // Empty childResults just to make it more clean\r\n    result.childResults = [];\r\n    // Fold those results\r\n    results = Folding.foldWithParent(results);\r\n    // The first result is the top one\r\n    const topResult = results.shift();\r\n    // All other the results are childResults\r\n    topResult.childResults = results;\r\n\r\n    return topResult;\r\n  }\r\n\r\n  public static defaultGetMoreResults(results: IQueryResult[]) {\r\n    // The result are flat, just do the fold\r\n    return Folding.foldWithParent(results);\r\n  }\r\n\r\n  // Convert ResultNode to QueryResult\r\n  private static resultNodeToQueryResult(resultNode: IResultNode): IQueryResult {\r\n    const result = resultNode.result;\r\n    result.attachments = map(sortBy<IResultNode>(resultNode.children, 'score'), Folding.resultNodeToQueryResult);\r\n    result.parentResult = resultNode.parent != null ? resultNode.parent.result : null;\r\n    return result;\r\n  }\r\n\r\n  private static findUniqueId(resultNodes: IResultNode[], uniqueId: string): IResultNode {\r\n    for (let i = 0; i < resultNodes.length; i++) {\r\n      if (resultNodes[i].result.uniqueId == uniqueId) {\r\n        return resultNodes[i];\r\n      }\r\n      const resultNode = Folding.findUniqueId(resultNodes[i].children, uniqueId);\r\n      if (resultNode != null) {\r\n        return resultNode;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private swapParentChildFoldingFields() {\r\n    // Swap \"old\" childField and parentField and assign them to the \"new\" parent option\r\n    // This needs to be done because connectors push the default data in *reverse* order compared to what the index expect.\r\n    if (this.options.childField != null) {\r\n      this.logger.warn('Detecting usage of deprecated option \"childField\". Assigning it automatically to the \"parent\" option instead.');\r\n      this.logger.warn('The option definition was changed to support universal folding across all sources.');\r\n      this.logger.warn('To remove this warning, rename the \"childField\" option (data-child-field) to \"parent\" (data-parent).');\r\n      this.options.parent = this.options.childField;\r\n    }\r\n\r\n    if (this.options.parentField != null) {\r\n      this.logger.warn('Detecting usage of deprecated option \"parentField\". Assigning it automatically to the \"child\" option instead.');\r\n      this.logger.warn('The option definition was changed to support universal folding across all sources.');\r\n      this.logger.warn('To remove this warning, rename the \"parentField\" option (data-parent-field) to \"child\" (data-child).');\r\n      this.options.child = this.options.parentField;\r\n    }\r\n  }\r\n\r\n  private handleBuildingQuery(data: IBuildingQueryEventArgs) {\r\n    Assert.exists(data);\r\n\r\n    if (!this.disabled) {\r\n      data.queryBuilder.childField = <string>this.options.parent;\r\n      data.queryBuilder.parentField = <string>this.options.child;\r\n      data.queryBuilder.filterField = <string>this.options.field;\r\n      data.queryBuilder.filterFieldRange = this.options.range;\r\n\r\n      data.queryBuilder.requiredFields.push(<string>this.options.field);\r\n      if (this.options.parent != null) {\r\n        data.queryBuilder.requiredFields.push(<string>this.options.parent);\r\n      }\r\n      if (this.options.child != null) {\r\n        data.queryBuilder.requiredFields.push(<string>this.options.child);\r\n      }\r\n    }\r\n  }\r\n\r\n  private handlepreprocessResults(data: IPreprocessResultsEventArgs) {\r\n    Assert.exists(data);\r\n    Assert.check(\r\n      !data.results._folded,\r\n      'Two or more Folding components are active at the same time for the same Tab. Cannot process the results.'\r\n    );\r\n    data.results._folded = true;\r\n\r\n    const queryResults = data.results;\r\n\r\n    const getResult: (result: IQueryResult) => IQueryResult = this.options.getResult || Folding.defaultGetResult;\r\n    queryResults.results = map(queryResults.results, getResult);\r\n\r\n    if (this.options.rearrange) {\r\n      queryResults.results.forEach(result => {\r\n        result.childResults = sortBy(result.childResults, result => Utils.getFieldValue(result, this.options.rearrange.sort));\r\n        if (this.shouldBeReversed(result.childResults)) {\r\n          result.childResults = result.childResults.reverse();\r\n        }\r\n      });\r\n    }\r\n\r\n    this.addLoadMoreHandler(<IQueryResult[]>queryResults.results, data.query);\r\n  }\r\n\r\n  private shouldBeReversed(childResults: IQueryResult[]) {\r\n    if (this.options.rearrange.direction == 'ascending') {\r\n      return false;\r\n    }\r\n    const childMissingSortByValue = any(childResults, childResult => {\r\n      return Utils.isNullOrUndefined(Utils.getFieldValue(childResult, this.options.rearrange.sort));\r\n    });\r\n    if (childMissingSortByValue) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private addLoadMoreHandler(results: IQueryResult[], originalQuery: IQuery) {\r\n    return map(results, result => {\r\n      if (this.options.enableExpand && !Utils.isNullOrUndefined(Utils.getFieldValue(result, <string>this.options.field))) {\r\n        result.moreResults = () => {\r\n          return this.moreResults(result, originalQuery);\r\n        };\r\n      }\r\n      return result;\r\n    });\r\n  }\r\n\r\n  private moreResults(result: IQueryResult, originalQuery: IQuery): Promise<IQueryResult[]> {\r\n    const query = clone(originalQuery);\r\n    const builder = new QueryBuilder();\r\n\r\n    query.numberOfResults = this.options.maximumExpandedResults;\r\n    const fieldValue = Utils.getFieldValue(result, <string>this.options.field);\r\n\r\n    if (Utils.isNonEmptyString(fieldValue)) {\r\n      builder.advancedExpression.addFieldExpression(<string>this.options.field, '=', [fieldValue]);\r\n      query.aq = builder.build().aq;\r\n    }\r\n\r\n    if (Utils.isNonEmptyString(originalQuery.q)) {\r\n      // We add keywords to get the highlight and we add @uri to get all results\r\n      // To ensure it plays nicely with query syntax, we ensure that the needed part of the query\r\n      // are correctly surrounded with the no syntax block\r\n      if (originalQuery.enableQuerySyntax) {\r\n        query.q = `( ${originalQuery.q} ) OR @uri`;\r\n      } else {\r\n        query.enableQuerySyntax = true;\r\n        query.q = `( <@- ${originalQuery.q} -@> ) OR @uri`;\r\n      }\r\n    }\r\n\r\n    if (Utils.isNonEmptyString(this.options.expandExpression)) {\r\n      query.cq = this.options.expandExpression;\r\n    }\r\n\r\n    if (this.options.child != null) {\r\n      query.parentField = <string>this.options.child;\r\n    }\r\n\r\n    if (this.options.parent != null) {\r\n      query.childField = <string>this.options.parent;\r\n    }\r\n\r\n    query.filterField = null;\r\n    query.filterFieldRange = null;\r\n    query.firstResult = 0;\r\n\r\n    if (this.options.rearrange) {\r\n      this.options.rearrange.putInQueryBuilder(builder);\r\n      query.sortCriteria = builder.sortCriteria;\r\n      query.sortField = builder.sortField;\r\n    } else {\r\n      query.sortCriteria = originalQuery.sortCriteria;\r\n      query.sortField = originalQuery.sortField;\r\n    }\r\n\r\n    return this.queryController\r\n      .getEndpoint()\r\n      .search(query)\r\n      .then((results: IQueryResults) => {\r\n        this.handlePreprocessMoreResults(results);\r\n        return results.results;\r\n      })\r\n      .catch(e => {\r\n        this.logger.error(`Invalid query performed while trying to retrieve more results for folding.`, e);\r\n        return [];\r\n      });\r\n  }\r\n\r\n  private handlePreprocessMoreResults(queryResults: IQueryResults) {\r\n    const getResults: (results: IQueryResult[]) => IQueryResult[] = this.options.getMoreResults || Folding.defaultGetMoreResults;\r\n    queryResults.results = getResults(queryResults.results);\r\n    $$(this.element).trigger(QueryEvents.preprocessMoreResults, {\r\n      results: queryResults\r\n    });\r\n  }\r\n}\r\n\r\nInitialization.registerAutoCreateComponent(Folding);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/Folding/Folding.ts","import { chain, contains, first, values } from 'underscore';\r\nimport { Assert } from '../../misc/Assert';\r\nimport { QueryBuilder } from '../../ui/Base/QueryBuilder';\r\n\r\nexport enum VALID_SORT {\r\n  RELEVANCY = 'relevancy',\r\n  DATE = 'date',\r\n  QRE = 'qre'\r\n}\r\n\r\nexport enum VALID_DIRECTION {\r\n  ASCENDING = 'ascending',\r\n  DESCENDING = 'descending'\r\n}\r\n\r\nexport class SortCriterion {\r\n  private static sortsNeedingDirection = [VALID_SORT.DATE];\r\n\r\n  /**\r\n   * Create a new SortCriteria\r\n   * @param sort The sort criteria (e.g.: relevancy, date)\r\n   * @param direction The direction by which to sort (e.g.: ascending, descending)\r\n   */\r\n  constructor(public sort: VALID_SORT, public direction: VALID_DIRECTION | '' = '') {\r\n    if (!SortCriterion.sortIsField(sort)) {\r\n      Assert.check(\r\n        this.isValidSort(sort),\r\n        `${sort} is not a valid sort criteria. Valid values are ${values(VALID_SORT)} or a valid index sortable index field.`\r\n      );\r\n    }\r\n    if (SortCriterion.sortNeedsDirection(sort)) {\r\n      Assert.check(\r\n        this.isValidDirection(direction),\r\n        `${direction} is not a valid sort criteria direction. Valid values are ${values(VALID_DIRECTION)}`\r\n      );\r\n    } else {\r\n      Assert.check(direction == '');\r\n    }\r\n  }\r\n\r\n  private isValidDirection(direction: string): direction is VALID_DIRECTION {\r\n    return chain(VALID_DIRECTION)\r\n      .values()\r\n      .contains(direction as any)\r\n      .value();\r\n  }\r\n\r\n  private isValidSort(sort: string): sort is VALID_SORT {\r\n    return chain(VALID_SORT)\r\n      .values()\r\n      .contains(sort as any)\r\n      .value();\r\n  }\r\n\r\n  private static sortIsField(criteria: string) {\r\n    return criteria.charAt(0) == '@';\r\n  }\r\n\r\n  private static sortNeedsDirection(sort: string) {\r\n    return contains(SortCriterion.sortsNeedingDirection, sort) || SortCriterion.sortIsField(sort);\r\n  }\r\n}\r\n\r\nexport class SortCriteria {\r\n  private criteria: SortCriterion[] = [];\r\n\r\n  constructor(rawCriteriaString: string) {\r\n    const criteria = rawCriteriaString.split(';');\r\n    criteria.forEach(criterion => {\r\n      const split = criterion.match(/\\S+/g);\r\n      this.criteria.push(new SortCriterion(split[0] as VALID_SORT, split[1] as VALID_DIRECTION));\r\n    });\r\n  }\r\n\r\n  public get direction() {\r\n    return first(this.criteria).direction;\r\n  }\r\n\r\n  public get sort() {\r\n    return first(this.criteria).sort;\r\n  }\r\n\r\n  /**\r\n   * Return a new SortCriteria from a string\r\n   * @param criteria The string from which to create the SortCriteria\r\n   */\r\n  static parse(criteria: string): SortCriteria {\r\n    return new SortCriteria(criteria);\r\n  }\r\n\r\n  /**\r\n   * Put the sort criteria in the passed queryBuilder\r\n   * @param queryBuilder The queryBuilder in which to put the sort criteria.\r\n   */\r\n  public putInQueryBuilder(queryBuilder: QueryBuilder) {\r\n    Assert.exists(queryBuilder);\r\n    queryBuilder.sortCriteria = this.toString()\r\n      .split(';')\r\n      .join(',');\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of the sort criteria (e.g.: 'date ascending').\r\n   */\r\n  public toString(): string {\r\n    return this.criteria\r\n      .map(criterion => {\r\n        return criterion.direction ? `${criterion.sort} ${criterion.direction}` : `${criterion.sort}`;\r\n      })\r\n      .join(';');\r\n  }\r\n\r\n  /**\r\n   * Checks if the SortCriteria is equal to another.\r\n   * @param criteria The SortCriteria to compare with\r\n   */\r\n  public equals(criteria: SortCriteria): boolean {\r\n    return criteria.toString() == this.toString();\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/Sort/SortCriteria.ts"],"sourceRoot":""}