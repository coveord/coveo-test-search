{"version":3,"sources":["MissingTerms.min__5f3280c404a1ee75a113.js","./src/ui/MissingTerm/MissingTerms.ts"],"names":["webpackJsonpCoveo__temporary","291","module","exports","__webpack_require__","__extends","this","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","element","options","bindings","result","MissingTerms","ID","ComponentOptions","initComponentOptions","addMissingTerms","_this","get","terms","absentTerms","term","regex","createWordBoundaryDelimitedRegex","query","queryStateModel","exec","originalKeywordInQuery","push","enumerable","configurable","addTermForcedToAppear","missingTerms","indexOf","logger","warn","toString","updateTermForcedToAppear","termForcedToAppear","set","length","missingTermElement","buildContainer","hideMissingTermsOverTheNumberOfResults","map","$$","append","elements","buildCaption","el","buildMissingTerms","forEach","className","caption","filter","isValidTerm","makeTermClickableIfEnabled","executeNewQuery","missingTerm","queryController","executeQuery","clickable","termElement","on","logAnalyticsAddMissingTerm","XRegExp","MissingTermManager","wordBoundary","containsFeaturedResults","allMissingTerms","tagName","numberOfTerms","index","hide","nbMoreResults","showMore","l","showAllHiddenMissingTerms","find","parentNode","removeChild","findAll","show","removeAttribute","isNonBoundaryTerm","match","every","word","usageAnalytics","logSearchEvent","analyticsActionCauseList","addMissingTerm","buildBooleanOption","defaultValue","buildLocalizedStringOption","localizedString","buildNumberOption","min","doExport","exportGlobally","Component","Initialization","registerAutoCreateComponent","694"],"mappings":"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","file":"MissingTerms.min__5f3280c404a1ee75a113.js","sourcesContent":["webpackJsonpCoveo__temporary([68],{\n\n/***/ 291:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__webpack_require__(694);\r\nvar Core_1 = __webpack_require__(20);\r\nvar GlobalExports_1 = __webpack_require__(3);\r\nvar AnalyticsActionListMeta_1 = __webpack_require__(10);\r\nvar Component_1 = __webpack_require__(7);\r\nvar ComponentOptions_1 = __webpack_require__(8);\r\nvar MissingTermManager_1 = __webpack_require__(203);\r\nvar XRegExp = __webpack_require__(204);\r\n/**\r\n * This [result template component](https://docs.coveo.com/en/513/#using-result-template-components) renders a list of query terms\r\n * that were not matched by the associated result item.\r\n *\r\n * @availablesince [July 2019 Release (v2.6459)](https://docs.coveo.com/en/2938/)\r\n */\r\nvar MissingTerms = /** @class */ (function (_super) {\r\n    __extends(MissingTerms, _super);\r\n    /**\r\n     * Creates a new `MissingTerms` component instance.\r\n     * @param element The element on which to instantiate the component.\r\n     * @param options The configuration options for the component.\r\n     * @param bindings The bindings required by the component to function normally. If not set, these will be automatically resolved (with a slower execution time).\r\n     * @param result The query result item to associate the component with.\r\n     */\r\n    function MissingTerms(element, options, bindings, result) {\r\n        var _this = _super.call(this, element, MissingTerms.ID, bindings) || this;\r\n        _this.element = element;\r\n        _this.options = options;\r\n        _this.result = result;\r\n        _this.options = ComponentOptions_1.ComponentOptions.initComponentOptions(element, MissingTerms, options);\r\n        _this.addMissingTerms();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(MissingTerms.prototype, \"missingTerms\", {\r\n        /**\r\n         *Returns all original basic query expression terms that were not matched by the result item the component instance is associated with.\r\n         */\r\n        get: function () {\r\n            var terms = [];\r\n            for (var _i = 0, _a = this.result.absentTerms; _i < _a.length; _i++) {\r\n                var term = _a[_i];\r\n                var regex = this.createWordBoundaryDelimitedRegex(term);\r\n                var query = this.queryStateModel.get('q');\r\n                var result = regex.exec(query);\r\n                if (result) {\r\n                    var originalKeywordInQuery = result[4];\r\n                    terms.push(originalKeywordInQuery);\r\n                }\r\n            }\r\n            return terms;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Injects a term in the advanced part of the query expression (aq) to filter out items that do not match the term.\r\n     * @param term The term to add to the advanced query expression.\r\n     */\r\n    MissingTerms.prototype.addTermForcedToAppear = function (term) {\r\n        if (this.missingTerms.indexOf(term) === -1) {\r\n            this.logger.warn(\"Method execution aborted because the term to inject in aq (\\\"\" + term + \"\\\") is not a missing term.\", \"Allowed missing terms: \" + this.missingTerms.toString() + \".\");\r\n            return;\r\n        }\r\n        this.updateTermForcedToAppear();\r\n        this.termForcedToAppear.push(term);\r\n        this.queryStateModel.set('missingTerms', this.termForcedToAppear.slice());\r\n    };\r\n    MissingTerms.prototype.updateTermForcedToAppear = function () {\r\n        this.termForcedToAppear = this.queryStateModel.get('missingTerms').slice();\r\n    };\r\n    MissingTerms.prototype.addMissingTerms = function () {\r\n        var _this = this;\r\n        if (this.missingTerms.length === 0) {\r\n            return;\r\n        }\r\n        var missingTermElement = this.buildContainer();\r\n        if (missingTermElement.length > 1) {\r\n            this.hideMissingTermsOverTheNumberOfResults(missingTermElement);\r\n            missingTermElement.map(function (element) {\r\n                Core_1.$$(_this.element).append(element);\r\n            });\r\n        }\r\n    };\r\n    MissingTerms.prototype.buildContainer = function () {\r\n        var elements = [];\r\n        elements.push(this.buildCaption().el);\r\n        this.buildMissingTerms().forEach(function (term) {\r\n            if (term) {\r\n                elements.push(term.el);\r\n            }\r\n        });\r\n        return elements;\r\n    };\r\n    MissingTerms.prototype.buildCaption = function () {\r\n        return Core_1.$$('span', { className: 'coveo-field-caption' }, this.options.caption);\r\n    };\r\n    MissingTerms.prototype.buildMissingTerms = function () {\r\n        var _this = this;\r\n        var validTerms = this.missingTerms.filter(function (term) { return _this.isValidTerm(term); });\r\n        var terms = validTerms.map(function (term) {\r\n            return _this.makeTermClickableIfEnabled(term);\r\n        });\r\n        return terms;\r\n    };\r\n    MissingTerms.prototype.executeNewQuery = function (missingTerm) {\r\n        if (missingTerm === void 0) { missingTerm = this.queryStateModel.get('q'); }\r\n        this.queryController.executeQuery();\r\n    };\r\n    MissingTerms.prototype.makeTermClickableIfEnabled = function (term) {\r\n        var _this = this;\r\n        if (this.options.clickable) {\r\n            var termElement = Core_1.$$('button', { className: 'coveo-missing-term coveo-clickable' }, term);\r\n            termElement.on('click', function () {\r\n                _this.addTermForcedToAppear(term);\r\n                _this.logAnalyticsAddMissingTerm(term);\r\n                _this.executeNewQuery(term);\r\n            });\r\n            return termElement;\r\n        }\r\n        else {\r\n            return Core_1.$$('span', { className: 'coveo-missing-term' }, term);\r\n        }\r\n    };\r\n    MissingTerms.prototype.createWordBoundaryDelimitedRegex = function (term) {\r\n        return XRegExp(MissingTermManager_1.MissingTermManager.wordBoundary + \"(\" + term + \")\" + MissingTermManager_1.MissingTermManager.wordBoundary, 'gi');\r\n    };\r\n    MissingTerms.prototype.containsFeaturedResults = function (term) {\r\n        this.updateTermForcedToAppear();\r\n        return this.termForcedToAppear.indexOf(term) !== -1;\r\n    };\r\n    MissingTerms.prototype.hideMissingTermsOverTheNumberOfResults = function (elements) {\r\n        var _this = this;\r\n        var allMissingTerms = elements.filter(function (element) {\r\n            return element.tagName === 'BUTTON';\r\n        });\r\n        if (allMissingTerms.length <= this.options.numberOfTerms) {\r\n            return;\r\n        }\r\n        for (var index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\r\n            Core_1.$$(allMissingTerms[index]).hide();\r\n        }\r\n        var nbMoreResults = allMissingTerms.length - this.options.numberOfTerms;\r\n        var showMore = Core_1.$$('button', { className: 'coveo-missing-term-show-more coveo-clickable' }, Core_1.l('NMore', [nbMoreResults]));\r\n        showMore.on('click', function () {\r\n            _this.showAllHiddenMissingTerms();\r\n        });\r\n        elements.push(showMore.el);\r\n    };\r\n    MissingTerms.prototype.showAllHiddenMissingTerms = function () {\r\n        var showMore = Core_1.$$(this.element).find('.coveo-missing-term-show-more');\r\n        showMore.parentNode.removeChild(showMore);\r\n        var allMissingTerms = Core_1.$$(this.element).findAll('.coveo-missing-term');\r\n        for (var index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\r\n            Core_1.$$(allMissingTerms[index]).show();\r\n            allMissingTerms[index].removeAttribute('style');\r\n        }\r\n    };\r\n    MissingTerms.prototype.isValidTerm = function (term) {\r\n        return this.isNonBoundaryTerm(term) && !this.containsFeaturedResults(term);\r\n    };\r\n    MissingTerms.prototype.isNonBoundaryTerm = function (term) {\r\n        //p{L} is a Unicode script that matches any character in any language.\r\n        var wordWithBreakpoints = \"\\\\p{L}*[-'?*\\u2019.~=,/\\\\\\\\:`;_!&()]+\\\\p{L}*\";\r\n        var regex = XRegExp(wordWithBreakpoints, 'gi');\r\n        var query = this.queryStateModel.get('q');\r\n        var matches = query.match(regex) || [];\r\n        return matches.every(function (word) {\r\n            return word.indexOf(term) === -1;\r\n        });\r\n    };\r\n    MissingTerms.prototype.logAnalyticsAddMissingTerm = function (term) {\r\n        this.usageAnalytics.logSearchEvent(AnalyticsActionListMeta_1.analyticsActionCauseList.addMissingTerm, {\r\n            missingTerm: term\r\n        });\r\n    };\r\n    MissingTerms.ID = 'MissingTerms';\r\n    /**\r\n     * @componentOptions\r\n     */\r\n    MissingTerms.options = {\r\n        /**\r\n         * Whether to allow the end-user to click a missing term to filter out items that do not match this term.\r\n         *\r\n         * **Default:** `true`\r\n         */\r\n        clickable: ComponentOptions_1.ComponentOptions.buildBooleanOption({ defaultValue: true }),\r\n        /**\r\n         * The text to display before missing terms.\r\n         *\r\n         * **Default:** The localized string for `Missing`.\r\n         */\r\n        caption: ComponentOptions_1.ComponentOptions.buildLocalizedStringOption({\r\n            localizedString: function () { return Core_1.l('Missing'); }\r\n        }),\r\n        /**\r\n         * The maximum number of missing term to be displayed\r\n         *\r\n         * **Default:** `5`\u001d\u001c\r\n         * **Minimum value:** `1`\u001d\u001c\r\n         */\r\n        numberOfTerms: ComponentOptions_1.ComponentOptions.buildNumberOption({\r\n            defaultValue: 5,\r\n            min: 1\r\n        })\r\n    };\r\n    MissingTerms.doExport = function () {\r\n        GlobalExports_1.exportGlobally({\r\n            MissingTerms: MissingTerms\r\n        });\r\n    };\r\n    return MissingTerms;\r\n}(Component_1.Component));\r\nexports.MissingTerms = MissingTerms;\r\nCore_1.Initialization.registerAutoCreateComponent(MissingTerms);\r\n\n\n/***/ }),\n\n/***/ 694:\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// MissingTerms.min__5f3280c404a1ee75a113.js","import 'styling/_MissingTerms';\r\nimport { $$, Initialization, l } from '../../Core';\r\nimport { exportGlobally } from '../../GlobalExports';\r\nimport { IQueryResult } from '../../rest/QueryResult';\r\nimport { Dom } from '../../utils/Dom';\r\nimport { analyticsActionCauseList, IAnalyticsMissingTerm } from '../Analytics/AnalyticsActionListMeta';\r\nimport { Component } from '../Base/Component';\r\nimport { IComponentBindings } from '../Base/ComponentBindings';\r\nimport { ComponentOptions } from '../Base/ComponentOptions';\r\nimport { MissingTermManager } from './MissingTermManager';\r\nimport XRegExp = require('xregexp');\r\n\r\nexport interface IMissingTermsOptions {\r\n  caption?: string;\r\n  clickable?: boolean;\r\n  numberOfTerms?: number;\r\n}\r\n\r\n/**\r\n * This [result template component](https://docs.coveo.com/en/513/#using-result-template-components) renders a list of query terms\r\n * that were not matched by the associated result item.\r\n *\r\n * @availablesince [July 2019 Release (v2.6459)](https://docs.coveo.com/en/2938/)\r\n */\r\nexport class MissingTerms extends Component {\r\n  static ID = 'MissingTerms';\r\n\r\n  /**\r\n   * @componentOptions\r\n   */\r\n  static options: IMissingTermsOptions = {\r\n    /**\r\n     * Whether to allow the end-user to click a missing term to filter out items that do not match this term.\r\n     *\r\n     * **Default:** `true`\r\n     */\r\n    clickable: ComponentOptions.buildBooleanOption({ defaultValue: true }),\r\n    /**\r\n     * The text to display before missing terms.\r\n     *\r\n     * **Default:** The localized string for `Missing`.\r\n     */\r\n    caption: ComponentOptions.buildLocalizedStringOption({\r\n      localizedString: () => l('Missing')\r\n    }),\r\n    /**\r\n     * The maximum number of missing term to be displayed\r\n     *\r\n     * **Default:** `5`\u001d\u001c\r\n     * **Minimum value:** `1`\u001d\u001c\r\n     */\r\n    numberOfTerms: ComponentOptions.buildNumberOption({\r\n      defaultValue: 5,\r\n      min: 1\r\n    })\r\n  };\r\n\r\n  static doExport = () => {\r\n    exportGlobally({\r\n      MissingTerms: MissingTerms\r\n    });\r\n  };\r\n\r\n  private termForcedToAppear: string[];\r\n\r\n  /**\r\n   * Creates a new `MissingTerms` component instance.\r\n   * @param element The element on which to instantiate the component.\r\n   * @param options The configuration options for the component.\r\n   * @param bindings The bindings required by the component to function normally. If not set, these will be automatically resolved (with a slower execution time).\r\n   * @param result The query result item to associate the component with.\r\n   */\r\n  constructor(\r\n    public element: HTMLElement,\r\n    public options?: IMissingTermsOptions,\r\n    bindings?: IComponentBindings,\r\n    public result?: IQueryResult\r\n  ) {\r\n    super(element, MissingTerms.ID, bindings);\r\n\r\n    this.options = ComponentOptions.initComponentOptions(element, MissingTerms, options);\r\n    this.addMissingTerms();\r\n  }\r\n  /**\r\n   *Returns all original basic query expression terms that were not matched by the result item the component instance is associated with.\r\n   */\r\n  public get missingTerms(): string[] {\r\n    const terms = [];\r\n\r\n    for (const term of this.result.absentTerms) {\r\n      const regex = this.createWordBoundaryDelimitedRegex(term);\r\n      const query = this.queryStateModel.get('q');\r\n      const result = regex.exec(query);\r\n\r\n      if (result) {\r\n        const originalKeywordInQuery = result[4];\r\n        terms.push(originalKeywordInQuery);\r\n      }\r\n    }\r\n\r\n    return terms;\r\n  }\r\n\r\n  /**\r\n   * Injects a term in the advanced part of the query expression (aq) to filter out items that do not match the term.\r\n   * @param term The term to add to the advanced query expression.\r\n   */\r\n  public addTermForcedToAppear(term: string) {\r\n    if (this.missingTerms.indexOf(term) === -1) {\r\n      this.logger.warn(\r\n        `Method execution aborted because the term to inject in aq (\"${term}\") is not a missing term.`,\r\n        `Allowed missing terms: ${this.missingTerms.toString()}.`\r\n      );\r\n      return;\r\n    }\r\n    this.updateTermForcedToAppear();\r\n    this.termForcedToAppear.push(term);\r\n    this.queryStateModel.set('missingTerms', [...this.termForcedToAppear]);\r\n  }\r\n\r\n  private updateTermForcedToAppear() {\r\n    this.termForcedToAppear = [...this.queryStateModel.get('missingTerms')];\r\n  }\r\n\r\n  private addMissingTerms() {\r\n    if (this.missingTerms.length === 0) {\r\n      return;\r\n    }\r\n    const missingTermElement = this.buildContainer();\r\n    if (missingTermElement.length > 1) {\r\n      this.hideMissingTermsOverTheNumberOfResults(missingTermElement);\r\n      missingTermElement.map(element => {\r\n        $$(this.element).append(element);\r\n      });\r\n    }\r\n  }\r\n\r\n  private buildContainer(): HTMLElement[] {\r\n    const elements: HTMLElement[] = [];\r\n    elements.push(this.buildCaption().el);\r\n    this.buildMissingTerms().forEach(term => {\r\n      if (term) {\r\n        elements.push(term.el);\r\n      }\r\n    });\r\n    return elements;\r\n  }\r\n\r\n  private buildCaption(): Dom {\r\n    return $$('span', { className: 'coveo-field-caption' }, this.options.caption);\r\n  }\r\n\r\n  private buildMissingTerms(): Dom[] {\r\n    const validTerms = this.missingTerms.filter(term => this.isValidTerm(term));\r\n    const terms: Dom[] = validTerms.map(term => {\r\n      return this.makeTermClickableIfEnabled(term);\r\n    });\r\n    return terms;\r\n  }\r\n\r\n  private executeNewQuery(missingTerm: string = this.queryStateModel.get('q')) {\r\n    this.queryController.executeQuery();\r\n  }\r\n\r\n  private makeTermClickableIfEnabled(term: string): Dom {\r\n    if (this.options.clickable) {\r\n      const termElement = $$('button', { className: 'coveo-missing-term coveo-clickable' }, term);\r\n      termElement.on('click', () => {\r\n        this.addTermForcedToAppear(term);\r\n        this.logAnalyticsAddMissingTerm(term);\r\n        this.executeNewQuery(term);\r\n      });\r\n      return termElement;\r\n    } else {\r\n      return $$('span', { className: 'coveo-missing-term' }, term);\r\n    }\r\n  }\r\n\r\n  private createWordBoundaryDelimitedRegex(term: string): RegExp {\r\n    return XRegExp(`${MissingTermManager.wordBoundary}(${term})${MissingTermManager.wordBoundary}`, 'gi');\r\n  }\r\n\r\n  private containsFeaturedResults(term: string): boolean {\r\n    this.updateTermForcedToAppear();\r\n    return this.termForcedToAppear.indexOf(term) !== -1;\r\n  }\r\n\r\n  private hideMissingTermsOverTheNumberOfResults(elements: HTMLElement[]) {\r\n    const allMissingTerms = elements.filter(element => {\r\n      return element.tagName === 'BUTTON';\r\n    });\r\n    if (allMissingTerms.length <= this.options.numberOfTerms) {\r\n      return;\r\n    }\r\n    for (let index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\r\n      $$(allMissingTerms[index]).hide();\r\n    }\r\n    const nbMoreResults = allMissingTerms.length - this.options.numberOfTerms;\r\n    const showMore = $$('button', { className: 'coveo-missing-term-show-more coveo-clickable' }, l('NMore', [nbMoreResults]));\r\n\r\n    showMore.on('click', () => {\r\n      this.showAllHiddenMissingTerms();\r\n    });\r\n    elements.push(showMore.el);\r\n  }\r\n\r\n  private showAllHiddenMissingTerms() {\r\n    const showMore = $$(this.element).find('.coveo-missing-term-show-more');\r\n    showMore.parentNode.removeChild(showMore);\r\n    const allMissingTerms = $$(this.element).findAll('.coveo-missing-term');\r\n    for (let index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\r\n      $$(allMissingTerms[index]).show();\r\n      allMissingTerms[index].removeAttribute('style');\r\n    }\r\n  }\r\n\r\n  private isValidTerm(term: string) {\r\n    return this.isNonBoundaryTerm(term) && !this.containsFeaturedResults(term);\r\n  }\r\n\r\n  private isNonBoundaryTerm(term: string) {\r\n    //p{L} is a Unicode script that matches any character in any language.\r\n    const wordWithBreakpoints = `\\\\p{L}*[-'?\\*â€™.~=,\\/\\\\\\\\:\\`;_!&\\(\\)]+\\\\p{L}*`;\r\n    const regex = XRegExp(wordWithBreakpoints, 'gi');\r\n    const query = this.queryStateModel.get('q');\r\n    const matches = query.match(regex) || [];\r\n    return matches.every((word: string) => {\r\n      return word.indexOf(term) === -1;\r\n    });\r\n  }\r\n\r\n  private logAnalyticsAddMissingTerm(term: string) {\r\n    this.usageAnalytics.logSearchEvent<IAnalyticsMissingTerm>(analyticsActionCauseList.addMissingTerm, {\r\n      missingTerm: term\r\n    });\r\n  }\r\n}\r\nInitialization.registerAutoCreateComponent(MissingTerms);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/MissingTerm/MissingTerms.ts"],"sourceRoot":""}